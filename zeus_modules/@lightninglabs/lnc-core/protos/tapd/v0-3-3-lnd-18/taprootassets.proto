syntax = "proto3";

package taprpc;

option go_package = "github.com/lightninglabs/taproot-assets/taprpc";

service TaprootAssets {
    /* tapcli: `assets list`
    ListAssets lists the set of assets owned by the target daemon.
    */
    rpc ListAssets (ListAssetRequest) returns (ListAssetResponse);

    /* tapcli: `assets utxos`
    ListUtxos lists the UTXOs managed by the target daemon, and the assets they
    hold.
    */
    rpc ListUtxos (ListUtxosRequest) returns (ListUtxosResponse);

    /* tapcli: `assets groups`
    ListGroups lists the asset groups known to the target daemon, and the assets
    held in each group.
    */
    rpc ListGroups (ListGroupsRequest) returns (ListGroupsResponse);

    /* tapcli: `assets balance`
    ListBalances lists asset balances
    */
    rpc ListBalances (ListBalancesRequest) returns (ListBalancesResponse);

    /* tapcli: `assets transfers`
    ListTransfers lists outbound asset transfers tracked by the target daemon.
    */
    rpc ListTransfers (ListTransfersRequest) returns (ListTransfersResponse);

    /* tapcli: `stop`
    StopDaemon will send a shutdown request to the interrupt handler, triggering
    a graceful shutdown of the daemon.
    */
    rpc StopDaemon (StopRequest) returns (StopResponse);

    /* tapcli: `debuglevel`
    DebugLevel allows a caller to programmatically set the logging verbosity of
    tapd. The logging can be targeted according to a coarse daemon-wide logging
    level, or in a granular fashion to specify the logging for a target
    sub-system.
    */
    rpc DebugLevel (DebugLevelRequest) returns (DebugLevelResponse);

    /* tapcli: `addrs query`
    QueryAddrs queries the set of Taproot Asset addresses stored in the
    database.
    */
    rpc QueryAddrs (QueryAddrRequest) returns (QueryAddrResponse);

    /* tapcli: `addrs new`
    NewAddr makes a new address from the set of request params.
    */
    rpc NewAddr (NewAddrRequest) returns (Addr);

    /* tapcli: `addrs decode`
    DecodeAddr decode a Taproot Asset address into a partial asset message that
    represents the asset it wants to receive.
    */
    rpc DecodeAddr (DecodeAddrRequest) returns (Addr);

    /* tapcli: `addrs receives`
    List all receives for incoming asset transfers for addresses that were
    created previously.
    */
    rpc AddrReceives (AddrReceivesRequest) returns (AddrReceivesResponse);

    /* tapcli: `proofs verify`
    VerifyProof attempts to verify a given proof file that claims to be anchored
    at the specified genesis point.
    */
    rpc VerifyProof (ProofFile) returns (VerifyProofResponse);

    /* tapcli: `proofs decode`
    DecodeProof attempts to decode a given proof file into human readable
    format.
    */
    rpc DecodeProof (DecodeProofRequest) returns (DecodeProofResponse);

    /* tapcli: `proofs export`
    ExportProof exports the latest raw proof file anchored at the specified
    script_key.
    */
    rpc ExportProof (ExportProofRequest) returns (ProofFile);

    /* tapcli: `assets send`
    SendAsset uses one or multiple passed Taproot Asset address(es) to attempt
    to complete an asset send. The method returns information w.r.t the on chain
    send, as well as the proof file information the receiver needs to fully
    receive the asset.
    */
    rpc SendAsset (SendAssetRequest) returns (SendAssetResponse);

    /* tapcli: `assets burn`
    BurnAsset burns the given number of units of a given asset by sending them
    to a provably un-spendable script key. Burning means irrevocably destroying
    a certain number of assets, reducing the total supply of the asset. Because
    burning is such a destructive and non-reversible operation, some specific
    values need to be set in the request to avoid accidental burns.
    */
    rpc BurnAsset (BurnAssetRequest) returns (BurnAssetResponse);

    /* tapcli: `getinfo`
    GetInfo returns the information for the node.
    */
    rpc GetInfo (GetInfoRequest) returns (GetInfoResponse);

    /*
    SubscribeSendAssetEventNtfns registers a subscription to the event
    notification stream which relates to the asset sending process.
    */
    rpc SubscribeSendAssetEventNtfns (SubscribeSendAssetEventNtfnsRequest)
        returns (stream SendAssetEvent);

    /*
    SubscribeReceiveAssetEventNtfns registers a subscription to the event
    notification stream which relates to the asset receive process.
    */
    rpc SubscribeReceiveAssetEventNtfns (SubscribeReceiveAssetEventNtfnsRequest)
        returns (stream ReceiveAssetEvent);

    /* tapcli: `assets meta`
    FetchAssetMeta allows a caller to fetch the reveal meta data for an asset
    either by the asset ID for that asset, or a meta hash.
    */
    rpc FetchAssetMeta (FetchAssetMetaRequest) returns (AssetMeta);
}

enum AssetType {
    /*
    Indicates that an asset is capable of being split/merged, with each of the
    units being fungible, even across a key asset ID boundary (assuming the
    key group is the same).
    */
    NORMAL = 0;

    /*
    Indicates that an asset is a collectible, meaning that each of the other
    items under the same key group are not fully fungible with each other.
    Collectibles also cannot be split or merged.
    */
    COLLECTIBLE = 1;
}

enum AssetMetaType {
    /*
    Opaque is used for asset meta blobs that have no true structure and instead
    should be interpreted as opaque blobs.
    */
    META_TYPE_OPAQUE = 0;
}

message AssetMeta {
    /*
    The raw data of the asset meta data. Based on the type below, this may be
    structured data such as a text file or PDF. The size of the data is limited
    to 1MiB.
    */
    bytes data = 1;

    // The type of the asset meta data.
    AssetMetaType type = 2;

    /*
    The hash of the meta. This is the hash of the TLV serialization of the meta
    itself.
    */
    bytes meta_hash = 3;
}

message ListAssetRequest {
    bool with_witness = 1;
    bool include_spent = 2;
    bool include_leased = 3;
}

message AnchorInfo {
    // The transaction that anchors the Taproot Asset commitment where the asset
    //  resides.
    bytes anchor_tx = 1;

    // The block hash the contains the anchor transaction above.
    string anchor_block_hash = 3;

    // The outpoint (txid:vout) that stores the Taproot Asset commitment.
    string anchor_outpoint = 4;

    /*
    The raw internal key that was used to create the anchor Taproot output key.
    */
    bytes internal_key = 5;

    /*
    The Taproot merkle root hash of the anchor output the asset was committed
    to. If there is no Tapscript sibling, this is equal to the Taproot Asset
    root commitment hash.
    */
    bytes merkle_root = 6;

    /*
    The serialized preimage of a Tapscript sibling, if there was one. If this
    is empty, then the merkle_root hash is equal to the Taproot root hash of the
    anchor output.
    */
    bytes tapscript_sibling = 7;

    // The height of the block which contains the anchor transaction.
    uint32 block_height = 8;
}

message GenesisInfo {
    // The first outpoint of the transaction that created the asset (txid:vout).
    string genesis_point = 1;

    // The name of the asset.
    string name = 2;

    // The hash of the meta data for this genesis asset.
    bytes meta_hash = 3;

    // The asset ID that uniquely identifies the asset.
    bytes asset_id = 4;

    // The type of the asset.
    AssetType asset_type = 5;

    /*
    The index of the output that carries the unique Taproot Asset commitment in
    the genesis transaction.
    */
    uint32 output_index = 6;

    // The version of the Taproot Asset commitment that created this asset.
    int32 version = 7;
}

message AssetGroup {
    // The raw group key which is a normal public key.
    bytes raw_group_key = 1;

    /*
    The tweaked group key, which is derived based on the genesis point and also
    asset type.
    */
    bytes tweaked_group_key = 2;

    /*
    A witness that authorizes a specific asset to be part of the asset group
    specified by the above key.
    */
    bytes asset_witness = 3;

    // TODO(jhb): update to include tapscript_root
}

message GroupKeyReveal {
    // The raw group key which is a normal public key.
    bytes raw_group_key = 1;

    // The tapscript root included in the tweaked group key, which may be empty.
    bytes tapscript_root = 2;
}

message GenesisReveal {
    // The base genesis information in the genesis reveal.
    GenesisInfo genesis_base_reveal = 1;
}

enum AssetVersion {
    // ASSET_VERSION_V0 is the default asset version. This version will include
    // the witness vector in the leaf for a tap commitment.
    ASSET_VERSION_V0 = 0;

    // ASSET_VERSION_V1 is the asset version that leaves out the witness vector
    // from the MS-SMT leaf encoding.
    ASSET_VERSION_V1 = 1;
}

message Asset {
    // The version of the Taproot Asset.
    AssetVersion version = 1;

    // The base genesis information of an asset. This information never changes.
    GenesisInfo asset_genesis = 2;

    // The total amount of the asset stored in this Taproot Asset UTXO.
    uint64 amount = 4;

    // An optional locktime, as with Bitcoin transactions.
    int32 lock_time = 5;

    // An optional relative lock time, same as Bitcoin transactions.
    int32 relative_lock_time = 6;

    // The version of the script, only version 0 is defined at present.
    int32 script_version = 7;

    // The script key of the asset, which can be spent under Taproot semantics.
    bytes script_key = 9;

    // Indicates whether the script key is known to the wallet of the lnd node
    // connected to the Taproot Asset daemon.
    bool script_key_is_local = 10;

    // The information related to the key group of an asset (if it exists).
    AssetGroup asset_group = 11;

    // Describes where in the chain the asset is currently anchored.
    AnchorInfo chain_anchor = 12;

    repeated PrevWitness prev_witnesses = 13;

    // Indicates whether the asset has been spent.
    bool is_spent = 14;

    // If the asset has been leased, this is the owner (application ID) of the
    // lease.
    bytes lease_owner = 15;

    // If the asset has been leased, this is the expiry of the lease as a Unix
    // timestamp in seconds.
    int64 lease_expiry = 16;

    // Indicates whether this transfer was an asset burn. If true, the number of
    // assets in this output are destroyed and can no longer be spent.
    bool is_burn = 17;
}

message PrevWitness {
    PrevInputAsset prev_id = 1;

    repeated bytes tx_witness = 2;

    SplitCommitment split_commitment = 3;
}

message SplitCommitment {
    Asset root_asset = 1;
}

message ListAssetResponse {
    repeated Asset assets = 1;
}

message ListUtxosRequest {
    bool include_leased = 1;
}

message ManagedUtxo {
    // The outpoint of the UTXO.
    string out_point = 1;

    // The UTXO amount in satoshis.
    int64 amt_sat = 2;

    // The internal key used for the on-chain output.
    bytes internal_key = 3;

    // The Taproot Asset root commitment hash.
    bytes taproot_asset_root = 4;

    /*
    The Taproot merkle root hash committed to by the outpoint of this UTXO.
    If there is no Tapscript sibling, this is equal to the Taproot Asset root
    commitment hash.
    */
    bytes merkle_root = 5;

    // The assets held at this UTXO.
    repeated Asset assets = 6;
}

message ListUtxosResponse {
    // The set of UTXOs managed by the daemon.
    map<string, ManagedUtxo> managed_utxos = 1;
}

message ListGroupsRequest {
}

message AssetHumanReadable {
    // The ID of the asset.
    bytes id = 1;

    // The amount of the asset.
    uint64 amount = 2;

    // An optional locktime, as with Bitcoin transactions.
    int32 lock_time = 3;

    // An optional relative locktime, as with Bitcoin transactions.
    int32 relative_lock_time = 4;

    // The name of the asset.
    string tag = 5;

    // The metadata hash of the asset.
    bytes meta_hash = 6;

    // The type of the asset.
    AssetType type = 7;

    // The version of the asset.
    AssetVersion version = 8;
}

message GroupedAssets {
    // A list of assets with the same group key.
    repeated AssetHumanReadable assets = 1;
}

message ListGroupsResponse {
    // The set of assets with a group key.
    map<string, GroupedAssets> groups = 1;
}

message ListBalancesRequest {
    oneof group_by {
        // Group results by asset IDs.
        bool asset_id = 1;

        // Group results by group keys.
        bool group_key = 2;
    }

    // If the query results should grouped by asset ids, then an optional asset
    // filter may be provided to query balance of a specific asset.
    bytes asset_filter = 3;

    // If the query results should be grouped by group keys, then an optional
    // group key filter may be provided to query the balance of a specific
    // asset group.
    bytes group_key_filter = 4;
}

message AssetBalance {
    // The base genesis information of an asset. This information never changes.
    GenesisInfo asset_genesis = 1;

    // The balance of the asset owned by the target daemon.
    uint64 balance = 3;
}

message AssetGroupBalance {
    // The group key or nil aggregating assets that don't have a group.
    bytes group_key = 1;

    // The total balance of the assets in the group.
    uint64 balance = 2;
}

message ListBalancesResponse {
    map<string, AssetBalance> asset_balances = 1;

    map<string, AssetGroupBalance> asset_group_balances = 2;
}

message ListTransfersRequest {
}

message ListTransfersResponse {
    // The unordered list of outgoing asset transfers.
    repeated AssetTransfer transfers = 1;
}

message AssetTransfer {
    int64 transfer_timestamp = 1;

    // The new transaction that commits to the set of Taproot Assets found
    // at the above new anchor point.
    bytes anchor_tx_hash = 2;

    uint32 anchor_tx_height_hint = 3;

    int64 anchor_tx_chain_fees = 4;

    // Describes the set of spent assets.
    repeated TransferInput inputs = 5;

    // Describes the set of newly created asset outputs.
    repeated TransferOutput outputs = 6;
}

message TransferInput {
    // The old/current location of the Taproot Asset commitment that was spent
    // as an input.
    string anchor_point = 1;

    // The ID of the asset that was spent.
    bytes asset_id = 2;

    // The script key of the asset that was spent.
    bytes script_key = 3;

    // The amount of the asset that was spent.
    uint64 amount = 4;
}

message TransferOutputAnchor {
    // The new location of the Taproot Asset commitment that was created on
    // chain.
    string outpoint = 1;

    int64 value = 2;

    bytes internal_key = 3;

    bytes taproot_asset_root = 4;

    bytes merkle_root = 5;

    bytes tapscript_sibling = 6;

    uint32 num_passive_assets = 7;
}

enum OutputType {
    // OUTPUT_TYPE_SIMPLE is a plain full-value or split output that is not a
    // split root and does not carry passive assets. In case of a split, the
    // asset of this output has a split commitment.
    OUTPUT_TYPE_SIMPLE = 0;

    // OUTPUT_TYPE_SPLIT_ROOT is a split root output that carries the change
    // from a split or a tombstone from a non-interactive full value send
    // output. In either case, the asset of this output has a tx witness.
    OUTPUT_TYPE_SPLIT_ROOT = 1;

    // OUTPUT_TYPE_PASSIVE_ASSETS_ONLY indicates that this output only carries
    // passive assets and therefore the asset in this output is nil. The passive
    // assets themselves are signed in their own virtual transactions and
    // are not present in this packet.
    OUTPUT_TYPE_PASSIVE_ASSETS_ONLY = 2;

    // OUTPUT_TYPE_PASSIVE_SPLIT_ROOT is a split root output that carries the
    // change from a split or a tombstone from a non-interactive full value send
    // output, as well as passive assets.
    OUTPUT_TYPE_PASSIVE_SPLIT_ROOT = 3;

    // OUTPUT_TYPE_SIMPLE_PASSIVE_ASSETS is a plain full-value interactive send
    // output that also carries passive assets. This is a special case where we
    // send the full value of a single asset in a commitment to a new script
    // key, but also carry passive assets in the same output. This is useful for
    // key rotation (send-to-self) scenarios or asset burns where we burn the
    // full supply of a single asset within a commitment.
    OUTPUT_TYPE_SIMPLE_PASSIVE_ASSETS = 4;
}

message TransferOutput {
    TransferOutputAnchor anchor = 1;

    bytes script_key = 2;

    bool script_key_is_local = 3;

    uint64 amount = 4;

    // The new individual transition proof (not a full proof file) that proves
    // the inclusion of the new asset within the new AnchorTx.
    bytes new_proof_blob = 5;

    bytes split_commit_root_hash = 6;

    OutputType output_type = 7;

    AssetVersion asset_version = 8;
}

message StopRequest {
}

message StopResponse {
}

message DebugLevelRequest {
    // If true, all the valid debug sub-systems will be returned.
    bool show = 1;

    string level_spec = 2;
}
message DebugLevelResponse {
    string sub_systems = 1;
}

message Addr {
    // The bech32 encoded Taproot Asset address.
    string encoded = 1;

    // The asset ID that uniquely identifies the asset.
    bytes asset_id = 2;

    // The type of the asset.
    AssetType asset_type = 3;

    // The total amount of the asset stored in this Taproot Asset UTXO.
    uint64 amount = 4;

    // The group key of the asset (if it exists)
    bytes group_key = 5;

    /*
    The specific script key the asset must commit to in order to transfer
    ownership to the creator of the address.
    */
    bytes script_key = 6;

    // The internal key used for the on-chain output.
    bytes internal_key = 7;

    /*
    The optional serialized tapscript sibling preimage to use for the receiving
    asset. This is usually empty as it is only needed when there should be an
    additional script path in the Taproot tree alongside the Taproot Asset
    commitment of the asset.
    */
    bytes tapscript_sibling = 8;

    /*
    The tweaked internal key that commits to the asset and represents the
    on-chain output key the Bitcoin transaction must send to in order to
    transfer assets described in this address.
    */
    bytes taproot_output_key = 9;

    // The address of the proof courier service used in proof transfer.
    string proof_courier_addr = 10;

    // The asset version of the address.
    AssetVersion asset_version = 11;
}

message QueryAddrRequest {
    /*
    If set, then only addresses created after this Unix timestamp will be
    returned.
    */
    int64 created_after = 1;

    /*
    If set, then only addresses created before this Unix timestamp will be
    returned.
    */
    int64 created_before = 2;

    // The max number of addresses that should be returned.
    int32 limit = 3;

    // The offset from the addresses that should be returned.
    int32 offset = 4;
}

message QueryAddrResponse {
    repeated Addr addrs = 1;
}

message NewAddrRequest {
    bytes asset_id = 1;

    uint64 amt = 2;

    /*
    The optional script key that the receiving asset should be locked to. If no
    script key is provided, a normal BIP-86 key will be derived from the
    underlying wallet.

    NOTE: The script_key and internal_key fields should either both be set or
    both be empty.
    */
    ScriptKey script_key = 3;

    /*
    The optional internal key of the receiving BTC level transaction output on
    which the receiving asset transfers will be committed to. If no internal key
    is provided, a key will be derived from the underlying wallet.

    NOTE: The script_key and internal_key fields should either both be set or
    both be empty.
    */
    KeyDescriptor internal_key = 4;

    /*
    The optional serialized tapscript sibling preimage to use for the receiving
    asset. This is usually empty as it is only needed when there should be an
    additional script path in the Taproot tree alongside the Taproot Asset
    commitment of the asset.
    */
    bytes tapscript_sibling = 5;

    /*
    An optional proof courier address for use in proof transfer. If unspecified,
    the daemon configured default address will be used.
     */
    string proof_courier_addr = 6;

    /*
    The asset version to use when sending/receiving to/from this address.
    */
    AssetVersion asset_version = 7;
}

message ScriptKey {
    /*
    The full Taproot output key the asset is locked to. This is either a BIP-86
    key if the tap_tweak below is empty, or a key with the tap tweak applied to
    it.
    */
    bytes pub_key = 1;

    /*
    The key descriptor describing the internal key of the above Taproot key.
    */
    KeyDescriptor key_desc = 2;

    /*
    The optional Taproot tweak to apply to the above internal key. If this is
    empty then a BIP-86 style tweak is applied to the internal key.
    */
    bytes tap_tweak = 3;
}

message KeyLocator {
    /*
    The family of key being identified.
    */
    int32 key_family = 1;

    /*
    The precise index of the key being identified.
    */
    int32 key_index = 2;
}

message KeyDescriptor {
    /*
    The raw bytes of the key being identified.
    */
    bytes raw_key_bytes = 1;

    /*
    The key locator that identifies which key to use for signing.
    */
    KeyLocator key_loc = 2;
}

message DecodeAddrRequest {
    string addr = 1;
}

message ProofFile {
    // The raw proof file encoded as bytes. Must be a file and not just an
    // individual mint/transfer proof.
    bytes raw_proof_file = 1;

    string genesis_point = 2;
}

message DecodedProof {
    // The index depth of the decoded proof, with 0 being the latest proof.
    uint32 proof_at_depth = 1;

    // The total number of proofs contained in the decoded proof file (this will
    // always be 1 if a single mint/transition proof was given as the raw_proof
    // instead of a file).
    uint32 number_of_proofs = 2;

    // The asset referenced in the proof.
    Asset asset = 3;

    // The reveal meta data associated with the proof, if available.
    AssetMeta meta_reveal = 4;

    // The merkle proof for AnchorTx used to prove its
    // inclusion within BlockHeader.
    bytes tx_merkle_proof = 5;

    // The TaprootProof proving the new inclusion of the
    // resulting asset within AnchorTx.
    bytes inclusion_proof = 6;

    // The set of TaprootProofs proving the exclusion of
    // the resulting asset from all other Taproot outputs within AnchorTx.
    repeated bytes exclusion_proofs = 7;

    // An optional TaprootProof needed if this asset is
    // the result of a split. SplitRootProof proves inclusion of the root
    // asset of the split.
    bytes split_root_proof = 8;

    // The number of additional nested full proofs for any inputs found within
    // the resulting asset.
    uint32 num_additional_inputs = 9;

    // ChallengeWitness is an optional virtual transaction witness that serves
    // as an ownership proof for the asset. If this is non-nil, then it is a
    // valid transfer witness for a 1-input, 1-output virtual transaction that
    // spends the asset in this proof and sends it to the NUMS key, to prove
    // that the creator of the proof is able to produce a valid signature to
    // spend the asset.
    repeated bytes challenge_witness = 10;

    // Indicates whether the state transition this proof represents is a burn,
    // meaning that the assets were provably destroyed and can no longer be
    // spent.
    bool is_burn = 11;

    // GenesisReveal is an optional field that is the Genesis information for
    // the asset. This is required for minting proofs.
    GenesisReveal genesis_reveal = 12;

    // GroupKeyReveal is an optional field that includes the information needed
    // to derive the tweaked group key.
    GroupKeyReveal group_key_reveal = 13;
}

message VerifyProofResponse {
    bool valid = 1;

    // The decoded last proof in the file if the proof file was valid.
    DecodedProof decoded_proof = 2;
}

message DecodeProofRequest {
    // The raw proof bytes to decode. This can be a full proof file or a single
    // mint/transition proof. If it is a full proof file, the proof_at_depth
    // field will be used to determine which individual proof within the file to
    // decode.
    bytes raw_proof = 1;

    // The index depth of the decoded proof, with 0 being the latest proof. This
    // is ignored if the raw_proof is a single mint/transition proof and not a
    // proof file.
    uint32 proof_at_depth = 2;

    // An option to include previous witnesses in decoding.
    bool with_prev_witnesses = 3;

    // An option to attempt to retrieve the meta data associated with the proof.
    bool with_meta_reveal = 4;
}

message DecodeProofResponse {
    DecodedProof decoded_proof = 1;
}

message ExportProofRequest {
    bytes asset_id = 1;
    bytes script_key = 2;
    OutPoint outpoint = 3;

    // TODO(roasbeef): specify information to make new state transition in proof
    // file?
}

enum AddrEventStatus {
    ADDR_EVENT_STATUS_UNKNOWN = 0;
    ADDR_EVENT_STATUS_TRANSACTION_DETECTED = 1;
    ADDR_EVENT_STATUS_TRANSACTION_CONFIRMED = 2;
    ADDR_EVENT_STATUS_PROOF_RECEIVED = 3;
    ADDR_EVENT_STATUS_COMPLETED = 4;
}

message AddrEvent {
    // The time the event was created in unix timestamp seconds.
    uint64 creation_time_unix_seconds = 1;

    // The address the event was created for.
    Addr addr = 2;

    // The current status of the event.
    AddrEventStatus status = 3;

    // The outpoint that contains the inbound asset transfer.
    string outpoint = 4;

    /*
    The amount in satoshis that were transferred on chain along with the asset.
    This amount is independent of the requested asset amount, which can be
    looked up on the address.
    */
    uint64 utxo_amt_sat = 5;

    /*
    The taproot sibling hash that was used to send to the Taproot output.
    */
    bytes taproot_sibling = 6;

    /*
    The height at which the on-chain output was confirmed. If this is zero, it
    means the output is unconfirmed.
    */
    uint32 confirmation_height = 7;

    /*
    Indicates whether a proof file can be found for the address' asset ID and
    script key.
    */
    bool has_proof = 8;
}

message AddrReceivesRequest {
    // Filter receives by a specific address. Leave empty to get all receives.
    string filter_addr = 1;

    // Filter receives by a specific status. Leave empty to get all receives.
    AddrEventStatus filter_status = 2;
}

message AddrReceivesResponse {
    // The events that match the filter criteria.
    repeated AddrEvent events = 1;
}

message SendAssetRequest {
    repeated string tap_addrs = 1;

    // The optional fee rate to use for the minting transaction, in sat/kw.
    uint32 fee_rate = 2;
    // TODO(roasbeef): maybe in future add details re type of ProofCourier or
    // w/e
}

message PrevInputAsset {
    string anchor_point = 1;
    bytes asset_id = 2;
    bytes script_key = 3;
    uint64 amount = 4;
}

message SendAssetResponse {
    AssetTransfer transfer = 1;
}

message GetInfoRequest {
}

message GetInfoResponse {
    string version = 1;
    string lnd_version = 2;
    string network = 3;
    string lnd_identity_pubkey = 4;
    string node_alias = 5;
    uint32 block_height = 6;
    string block_hash = 7;
    bool sync_to_chain = 8;
}

message SubscribeSendAssetEventNtfnsRequest {
}

message SendAssetEvent {
    oneof event {
        // An event which indicates that a send state is about to be executed.
        ExecuteSendStateEvent execute_send_state_event = 1;

        // An event which indicates that the proof transfer backoff wait period
        // will start imminently.
        ProofTransferBackoffWaitEvent proof_transfer_backoff_wait_event = 2;
    }
}

message ExecuteSendStateEvent {
    // Execute timestamp (microseconds).
    int64 timestamp = 1;

    // The send state that is about to be executed.
    string send_state = 2;
}

// ProofTransferType is the type of proof transfer attempt. The transfer is
// either a proof delivery to the transfer counterparty or receiving a proof
// from the transfer counterparty. Note that the transfer counterparty is
// usually the proof courier service.
enum ProofTransferType {
    // This value indicates that the proof transfer attempt is a delivery to the
    // transfer counterparty.
    PROOF_TRANSFER_TYPE_SEND = 0;

    // This value indicates that the proof transfer attempt is a receive from
    // the transfer counterparty.
    PROOF_TRANSFER_TYPE_RECEIVE = 1;
}

message ProofTransferBackoffWaitEvent {
    // Transfer attempt timestamp (microseconds).
    int64 timestamp = 1;

    // Backoff is the active backoff wait duration.
    int64 backoff = 2;

    // Tries counter is the number of tries we've made so far during the
    // course of the current backoff procedure to deliver the proof to the
    // receiver.
    int64 tries_counter = 3;

    // The type of proof transfer attempt.
    ProofTransferType transfer_type = 4;
}

message SubscribeReceiveAssetEventNtfnsRequest {
}

message AssetReceiveCompleteEvent {
    // Event creation timestamp.
    int64 timestamp = 1;

    // The address that received the asset.
    Addr address = 2;

    // The outpoint of the transaction that was used to receive the asset.
    string outpoint = 3;
}

message ReceiveAssetEvent {
    oneof event {
        // An event which indicates that the proof transfer backoff wait period
        // will start imminently.
        ProofTransferBackoffWaitEvent proof_transfer_backoff_wait_event = 1;

        // An event which indicates that an asset receive process has finished.
        AssetReceiveCompleteEvent asset_receive_complete_event = 2;
    }
}

message FetchAssetMetaRequest {
    oneof asset {
        // The asset ID of the asset to fetch the meta for.
        bytes asset_id = 1;

        // The 32-byte meta hash of the asset meta.
        bytes meta_hash = 2;

        // The hex encoded asset ID of the asset to fetch the meta for.
        string asset_id_str = 3;

        // The hex encoded meta hash of the asset meta.
        string meta_hash_str = 4;
    }
}

message BurnAssetRequest {
    oneof asset {
        // The asset ID of the asset to burn units of.
        bytes asset_id = 1;

        // The hex encoded asset ID of the asset to burn units of.
        string asset_id_str = 2;
    }

    uint64 amount_to_burn = 3;

    // A safety check to ensure the user is aware of the destructive nature of
    // the burn. This needs to be set to the value "assets will be destroyed"
    // for the burn to succeed.
    string confirmation_text = 4;
}

message BurnAssetResponse {
    // The asset transfer that contains the asset burn as an output.
    AssetTransfer burn_transfer = 1;

    // The burn transition proof for the asset burn output.
    DecodedProof burn_proof = 2;
}

message OutPoint {
    /*
    Raw bytes representing the transaction id.
    */
    bytes txid = 1;

    /*
    The index of the output on the transaction.
    */
    uint32 output_index = 2;
}
