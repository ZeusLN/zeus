// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: lightning.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///
///`AddressType` has to be one of:
///
///- `p2wkh`: Pay to witness key hash (`WITNESS_PUBKEY_HASH` = 0)
///- `np2wkh`: Pay to nested witness key hash (`NESTED_PUBKEY_HASH` = 1)
enum Lnrpc_AddressType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case witnessPubkeyHash // = 0
  case nestedPubkeyHash // = 1
  case unusedWitnessPubkeyHash // = 2
  case unusedNestedPubkeyHash // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .witnessPubkeyHash
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .witnessPubkeyHash
    case 1: self = .nestedPubkeyHash
    case 2: self = .unusedWitnessPubkeyHash
    case 3: self = .unusedNestedPubkeyHash
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .witnessPubkeyHash: return 0
    case .nestedPubkeyHash: return 1
    case .unusedWitnessPubkeyHash: return 2
    case .unusedNestedPubkeyHash: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Lnrpc_AddressType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Lnrpc_AddressType] = [
    .witnessPubkeyHash,
    .nestedPubkeyHash,
    .unusedWitnessPubkeyHash,
    .unusedNestedPubkeyHash,
  ]
}

#endif  // swift(>=4.2)

enum Lnrpc_CommitmentType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///
  ///Returned when the commitment type isn't known or unavailable.
  case unknownCommitmentType // = 0

  ///
  ///A channel using the legacy commitment format having tweaked to_remote
  ///keys.
  case legacy // = 1

  ///
  ///A channel that uses the modern commitment format where the key in the
  ///output of the remote party does not change each state. This makes back
  ///up and recovery easier as when the channel is closed, the funds go
  ///directly to that key.
  case staticRemoteKey // = 2

  ///
  ///A channel that uses a commitment format that has anchor outputs on the
  ///commitments, allowing fee bumping after a force close transaction has
  ///been broadcast.
  case anchors // = 3

  ///
  ///A channel that uses a commitment type that builds upon the anchors
  ///commitment format, but in addition requires a CLTV clause to spend outputs
  ///paying to the channel initiator. This is intended for use on leased channels
  ///to guarantee that the channel initiator has no incentives to close a leased
  ///channel before its maturity date.
  case scriptEnforcedLease // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownCommitmentType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownCommitmentType
    case 1: self = .legacy
    case 2: self = .staticRemoteKey
    case 3: self = .anchors
    case 4: self = .scriptEnforcedLease
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownCommitmentType: return 0
    case .legacy: return 1
    case .staticRemoteKey: return 2
    case .anchors: return 3
    case .scriptEnforcedLease: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Lnrpc_CommitmentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Lnrpc_CommitmentType] = [
    .unknownCommitmentType,
    .legacy,
    .staticRemoteKey,
    .anchors,
    .scriptEnforcedLease,
  ]
}

#endif  // swift(>=4.2)

enum Lnrpc_Initiator: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case local // = 1
  case remote // = 2
  case both // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .local
    case 2: self = .remote
    case 3: self = .both
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .local: return 1
    case .remote: return 2
    case .both: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Lnrpc_Initiator: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Lnrpc_Initiator] = [
    .unknown,
    .local,
    .remote,
    .both,
  ]
}

#endif  // swift(>=4.2)

enum Lnrpc_ResolutionType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case typeUnknown // = 0

  /// We resolved an anchor output.
  case anchor // = 1

  ///
  ///We are resolving an incoming htlc on chain. This if this htlc is
  ///claimed, we swept the incoming htlc with the preimage. If it is timed
  ///out, our peer swept the timeout path.
  case incomingHtlc // = 2

  ///
  ///We are resolving an outgoing htlc on chain. If this htlc is claimed,
  ///the remote party swept the htlc with the preimage. If it is timed out,
  ///we swept it with the timeout path.
  case outgoingHtlc // = 3

  /// We force closed and need to sweep our time locked commitment output.
  case commit // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .typeUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .typeUnknown
    case 1: self = .anchor
    case 2: self = .incomingHtlc
    case 3: self = .outgoingHtlc
    case 4: self = .commit
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .typeUnknown: return 0
    case .anchor: return 1
    case .incomingHtlc: return 2
    case .outgoingHtlc: return 3
    case .commit: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Lnrpc_ResolutionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Lnrpc_ResolutionType] = [
    .typeUnknown,
    .anchor,
    .incomingHtlc,
    .outgoingHtlc,
    .commit,
  ]
}

#endif  // swift(>=4.2)

enum Lnrpc_ResolutionOutcome: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Outcome unknown.
  case outcomeUnknown // = 0

  /// An output was claimed on chain.
  case claimed // = 1

  /// An output was left unclaimed on chain.
  case unclaimed // = 2

  ///
  ///ResolverOutcomeAbandoned indicates that an output that we did not
  ///claim on chain, for example an anchor that we did not sweep and a
  ///third party claimed on chain, or a htlc that we could not decode
  ///so left unclaimed.
  case abandoned // = 3

  ///
  ///If we force closed our channel, our htlcs need to be claimed in two
  ///stages. This outcome represents the broadcast of a timeout or success
  ///transaction for this two stage htlc claim.
  case firstStage // = 4

  /// A htlc was timed out on chain.
  case timeout // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .outcomeUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .outcomeUnknown
    case 1: self = .claimed
    case 2: self = .unclaimed
    case 3: self = .abandoned
    case 4: self = .firstStage
    case 5: self = .timeout
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .outcomeUnknown: return 0
    case .claimed: return 1
    case .unclaimed: return 2
    case .abandoned: return 3
    case .firstStage: return 4
    case .timeout: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Lnrpc_ResolutionOutcome: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Lnrpc_ResolutionOutcome] = [
    .outcomeUnknown,
    .claimed,
    .unclaimed,
    .abandoned,
    .firstStage,
    .timeout,
  ]
}

#endif  // swift(>=4.2)

enum Lnrpc_NodeMetricType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case betweennessCentrality // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .betweennessCentrality
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .betweennessCentrality: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Lnrpc_NodeMetricType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Lnrpc_NodeMetricType] = [
    .unknown,
    .betweennessCentrality,
  ]
}

#endif  // swift(>=4.2)

enum Lnrpc_InvoiceHTLCState: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case accepted // = 0
  case settled // = 1
  case canceled // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .accepted
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .accepted
    case 1: self = .settled
    case 2: self = .canceled
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .accepted: return 0
    case .settled: return 1
    case .canceled: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Lnrpc_InvoiceHTLCState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Lnrpc_InvoiceHTLCState] = [
    .accepted,
    .settled,
    .canceled,
  ]
}

#endif  // swift(>=4.2)

enum Lnrpc_PaymentFailureReason: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///
  ///Payment isn't failed (yet).
  case failureReasonNone // = 0

  ///
  ///There are more routes to try, but the payment timeout was exceeded.
  case failureReasonTimeout // = 1

  ///
  ///All possible routes were tried and failed permanently. Or were no
  ///routes to the destination at all.
  case failureReasonNoRoute // = 2

  ///
  ///A non-recoverable error has occured.
  case failureReasonError // = 3

  ///
  ///Payment details incorrect (unknown hash, invalid amt or
  ///invalid final cltv delta)
  case failureReasonIncorrectPaymentDetails // = 4

  ///
  ///Insufficient local balance.
  case failureReasonInsufficientBalance // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .failureReasonNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .failureReasonNone
    case 1: self = .failureReasonTimeout
    case 2: self = .failureReasonNoRoute
    case 3: self = .failureReasonError
    case 4: self = .failureReasonIncorrectPaymentDetails
    case 5: self = .failureReasonInsufficientBalance
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .failureReasonNone: return 0
    case .failureReasonTimeout: return 1
    case .failureReasonNoRoute: return 2
    case .failureReasonError: return 3
    case .failureReasonIncorrectPaymentDetails: return 4
    case .failureReasonInsufficientBalance: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Lnrpc_PaymentFailureReason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Lnrpc_PaymentFailureReason] = [
    .failureReasonNone,
    .failureReasonTimeout,
    .failureReasonNoRoute,
    .failureReasonError,
    .failureReasonIncorrectPaymentDetails,
    .failureReasonInsufficientBalance,
  ]
}

#endif  // swift(>=4.2)

enum Lnrpc_FeatureBit: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case datalossProtectReq // = 0
  case datalossProtectOpt // = 1
  case initialRouingSync // = 3
  case upfrontShutdownScriptReq // = 4
  case upfrontShutdownScriptOpt // = 5
  case gossipQueriesReq // = 6
  case gossipQueriesOpt // = 7
  case tlvOnionReq // = 8
  case tlvOnionOpt // = 9
  case extGossipQueriesReq // = 10
  case extGossipQueriesOpt // = 11
  case staticRemoteKeyReq // = 12
  case staticRemoteKeyOpt // = 13
  case paymentAddrReq // = 14
  case paymentAddrOpt // = 15
  case mppReq // = 16
  case mppOpt // = 17
  case wumboChannelsReq // = 18
  case wumboChannelsOpt // = 19
  case anchorsReq // = 20
  case anchorsOpt // = 21
  case anchorsZeroFeeHtlcReq // = 22
  case anchorsZeroFeeHtlcOpt // = 23
  case ampReq // = 30
  case ampOpt // = 31
  case UNRECOGNIZED(Int)

  init() {
    self = .datalossProtectReq
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .datalossProtectReq
    case 1: self = .datalossProtectOpt
    case 3: self = .initialRouingSync
    case 4: self = .upfrontShutdownScriptReq
    case 5: self = .upfrontShutdownScriptOpt
    case 6: self = .gossipQueriesReq
    case 7: self = .gossipQueriesOpt
    case 8: self = .tlvOnionReq
    case 9: self = .tlvOnionOpt
    case 10: self = .extGossipQueriesReq
    case 11: self = .extGossipQueriesOpt
    case 12: self = .staticRemoteKeyReq
    case 13: self = .staticRemoteKeyOpt
    case 14: self = .paymentAddrReq
    case 15: self = .paymentAddrOpt
    case 16: self = .mppReq
    case 17: self = .mppOpt
    case 18: self = .wumboChannelsReq
    case 19: self = .wumboChannelsOpt
    case 20: self = .anchorsReq
    case 21: self = .anchorsOpt
    case 22: self = .anchorsZeroFeeHtlcReq
    case 23: self = .anchorsZeroFeeHtlcOpt
    case 30: self = .ampReq
    case 31: self = .ampOpt
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .datalossProtectReq: return 0
    case .datalossProtectOpt: return 1
    case .initialRouingSync: return 3
    case .upfrontShutdownScriptReq: return 4
    case .upfrontShutdownScriptOpt: return 5
    case .gossipQueriesReq: return 6
    case .gossipQueriesOpt: return 7
    case .tlvOnionReq: return 8
    case .tlvOnionOpt: return 9
    case .extGossipQueriesReq: return 10
    case .extGossipQueriesOpt: return 11
    case .staticRemoteKeyReq: return 12
    case .staticRemoteKeyOpt: return 13
    case .paymentAddrReq: return 14
    case .paymentAddrOpt: return 15
    case .mppReq: return 16
    case .mppOpt: return 17
    case .wumboChannelsReq: return 18
    case .wumboChannelsOpt: return 19
    case .anchorsReq: return 20
    case .anchorsOpt: return 21
    case .anchorsZeroFeeHtlcReq: return 22
    case .anchorsZeroFeeHtlcOpt: return 23
    case .ampReq: return 30
    case .ampOpt: return 31
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Lnrpc_FeatureBit: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Lnrpc_FeatureBit] = [
    .datalossProtectReq,
    .datalossProtectOpt,
    .initialRouingSync,
    .upfrontShutdownScriptReq,
    .upfrontShutdownScriptOpt,
    .gossipQueriesReq,
    .gossipQueriesOpt,
    .tlvOnionReq,
    .tlvOnionOpt,
    .extGossipQueriesReq,
    .extGossipQueriesOpt,
    .staticRemoteKeyReq,
    .staticRemoteKeyOpt,
    .paymentAddrReq,
    .paymentAddrOpt,
    .mppReq,
    .mppOpt,
    .wumboChannelsReq,
    .wumboChannelsOpt,
    .anchorsReq,
    .anchorsOpt,
    .anchorsZeroFeeHtlcReq,
    .anchorsZeroFeeHtlcOpt,
    .ampReq,
    .ampOpt,
  ]
}

#endif  // swift(>=4.2)

enum Lnrpc_UpdateFailure: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case pending // = 1
  case notFound // = 2
  case internalErr // = 3
  case invalidParameter // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .pending
    case 2: self = .notFound
    case 3: self = .internalErr
    case 4: self = .invalidParameter
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .pending: return 1
    case .notFound: return 2
    case .internalErr: return 3
    case .invalidParameter: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Lnrpc_UpdateFailure: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Lnrpc_UpdateFailure] = [
    .unknown,
    .pending,
    .notFound,
    .internalErr,
    .invalidParameter,
  ]
}

#endif  // swift(>=4.2)

struct Lnrpc_SubscribeCustomMessagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_CustomMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Peer from which the message originates
  var peer: Data = Data()

  /// Message type. This value will be in the custom range (>= 32768).
  var type: UInt32 = 0

  /// Raw message data
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_SendCustomMessageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Peer to send the message to
  var peer: Data = Data()

  /// Message type. This value needs to be in the custom range (>= 32768).
  var type: UInt32 = 0

  /// Raw message data.
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_SendCustomMessageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_Utxo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of address
  var addressType: Lnrpc_AddressType = .witnessPubkeyHash

  /// The address
  var address: String = String()

  /// The value of the unspent coin in satoshis
  var amountSat: Int64 = 0

  /// The pkscript in hex
  var pkScript: String = String()

  /// The outpoint in format txid:n
  var outpoint: Lnrpc_OutPoint {
    get {return _outpoint ?? Lnrpc_OutPoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  /// The number of confirmations for the Utxo
  var confirmations: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outpoint: Lnrpc_OutPoint? = nil
}

struct Lnrpc_Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The transaction hash
  var txHash: String = String()

  /// The transaction amount, denominated in satoshis
  var amount: Int64 = 0

  /// The number of confirmations
  var numConfirmations: Int32 = 0

  /// The hash of the block this transaction was included in
  var blockHash: String = String()

  /// The height of the block this transaction was included in
  var blockHeight: Int32 = 0

  /// Timestamp of this transaction
  var timeStamp: Int64 = 0

  /// Fees paid for this transaction
  var totalFees: Int64 = 0

  /// Addresses that received funds for this transaction
  var destAddresses: [String] = []

  /// The raw transaction hex.
  var rawTxHex: String = String()

  /// A label that was optionally set on transaction broadcast.
  var label: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_GetTransactionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The height from which to list transactions, inclusive. If this value is
  ///greater than end_height, transactions will be read in reverse.
  var startHeight: Int32 = 0

  ///
  ///The height until which to list transactions, inclusive. To include
  ///unconfirmed transactions, this value should be set to -1, which will
  ///return transactions from start_height until the current chain tip and
  ///unconfirmed transactions. If no end_height is provided, the call will
  ///default to this option.
  var endHeight: Int32 = 0

  /// An optional filter to only include transactions relevant to an account.
  var account: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_TransactionDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of transactions relevant to the wallet.
  var transactions: [Lnrpc_Transaction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_FeeLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var limit: Lnrpc_FeeLimit.OneOf_Limit? = nil

  ///
  ///The fee limit expressed as a fixed amount of satoshis.
  ///
  ///The fields fixed and fixed_msat are mutually exclusive.
  var fixed: Int64 {
    get {
      if case .fixed(let v)? = limit {return v}
      return 0
    }
    set {limit = .fixed(newValue)}
  }

  ///
  ///The fee limit expressed as a fixed amount of millisatoshis.
  ///
  ///The fields fixed and fixed_msat are mutually exclusive.
  var fixedMsat: Int64 {
    get {
      if case .fixedMsat(let v)? = limit {return v}
      return 0
    }
    set {limit = .fixedMsat(newValue)}
  }

  /// The fee limit expressed as a percentage of the payment amount.
  var percent: Int64 {
    get {
      if case .percent(let v)? = limit {return v}
      return 0
    }
    set {limit = .percent(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Limit: Equatable {
    ///
    ///The fee limit expressed as a fixed amount of satoshis.
    ///
    ///The fields fixed and fixed_msat are mutually exclusive.
    case fixed(Int64)
    ///
    ///The fee limit expressed as a fixed amount of millisatoshis.
    ///
    ///The fields fixed and fixed_msat are mutually exclusive.
    case fixedMsat(Int64)
    /// The fee limit expressed as a percentage of the payment amount.
    case percent(Int64)

  #if !swift(>=4.1)
    static func ==(lhs: Lnrpc_FeeLimit.OneOf_Limit, rhs: Lnrpc_FeeLimit.OneOf_Limit) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.fixed, .fixed): return {
        guard case .fixed(let l) = lhs, case .fixed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fixedMsat, .fixedMsat): return {
        guard case .fixedMsat(let l) = lhs, case .fixedMsat(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.percent, .percent): return {
        guard case .percent(let l) = lhs, case .percent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Lnrpc_SendRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The identity pubkey of the payment recipient. When using REST, this field
  ///must be encoded as base64.
  var dest: Data = Data()

  ///
  ///The hex-encoded identity pubkey of the payment recipient. Deprecated now
  ///that the REST gateway supports base64 encoding of bytes fields.
  var destString: String = String()

  ///
  ///The amount to send expressed in satoshis.
  ///
  ///The fields amt and amt_msat are mutually exclusive.
  var amt: Int64 = 0

  ///
  ///The amount to send expressed in millisatoshis.
  ///
  ///The fields amt and amt_msat are mutually exclusive.
  var amtMsat: Int64 = 0

  ///
  ///The hash to use within the payment's HTLC. When using REST, this field
  ///must be encoded as base64.
  var paymentHash: Data = Data()

  ///
  ///The hex-encoded hash to use within the payment's HTLC. Deprecated now
  ///that the REST gateway supports base64 encoding of bytes fields.
  var paymentHashString: String = String()

  ///
  ///A bare-bones invoice for a payment within the Lightning Network. With the
  ///details of the invoice, the sender has all the data necessary to send a
  ///payment to the recipient.
  var paymentRequest: String = String()

  ///
  ///The CLTV delta from the current height that should be used to set the
  ///timelock for the final hop.
  var finalCltvDelta: Int32 = 0

  ///
  ///The maximum number of satoshis that will be paid as a fee of the payment.
  ///This value can be represented either as a percentage of the amount being
  ///sent, or as a fixed amount of the maximum fee the user is willing the pay to
  ///send the payment.
  var feeLimit: Lnrpc_FeeLimit {
    get {return _feeLimit ?? Lnrpc_FeeLimit()}
    set {_feeLimit = newValue}
  }
  /// Returns true if `feeLimit` has been explicitly set.
  var hasFeeLimit: Bool {return self._feeLimit != nil}
  /// Clears the value of `feeLimit`. Subsequent reads from it will return its default value.
  mutating func clearFeeLimit() {self._feeLimit = nil}

  ///
  ///The channel id of the channel that must be taken to the first hop. If zero,
  ///any channel may be used.
  var outgoingChanID: UInt64 = 0

  ///
  ///The pubkey of the last hop of the route. If empty, any hop may be used.
  var lastHopPubkey: Data = Data()

  ///
  ///An optional maximum total time lock for the route. This should not exceed
  ///lnd's `--max-cltv-expiry` setting. If zero, then the value of
  ///`--max-cltv-expiry` is enforced.
  var cltvLimit: UInt32 = 0

  ///
  ///An optional field that can be used to pass an arbitrary set of TLV records
  ///to a peer which understands the new records. This can be used to pass
  ///application specific data during the payment attempt. Record types are
  ///required to be in the custom range >= 65536. When using REST, the values
  ///must be encoded as base64.
  var destCustomRecords: Dictionary<UInt64,Data> = [:]

  /// If set, circular payments to self are permitted.
  var allowSelfPayment: Bool = false

  ///
  ///Features assumed to be supported by the final node. All transitive feature
  ///dependencies must also be set properly. For a given feature bit pair, either
  ///optional or remote may be set, but not both. If this field is nil or empty,
  ///the router will try to load destination features from the graph as a
  ///fallback.
  var destFeatures: [Lnrpc_FeatureBit] = []

  ///
  ///The payment address of the generated invoice.
  var paymentAddr: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _feeLimit: Lnrpc_FeeLimit? = nil
}

struct Lnrpc_SendResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var paymentError: String = String()

  var paymentPreimage: Data = Data()

  var paymentRoute: Lnrpc_Route {
    get {return _paymentRoute ?? Lnrpc_Route()}
    set {_paymentRoute = newValue}
  }
  /// Returns true if `paymentRoute` has been explicitly set.
  var hasPaymentRoute: Bool {return self._paymentRoute != nil}
  /// Clears the value of `paymentRoute`. Subsequent reads from it will return its default value.
  mutating func clearPaymentRoute() {self._paymentRoute = nil}

  var paymentHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _paymentRoute: Lnrpc_Route? = nil
}

struct Lnrpc_SendToRouteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The payment hash to use for the HTLC. When using REST, this field must be
  ///encoded as base64.
  var paymentHash: Data = Data()

  ///
  ///An optional hex-encoded payment hash to be used for the HTLC. Deprecated now
  ///that the REST gateway supports base64 encoding of bytes fields.
  var paymentHashString: String = String()

  /// Route that should be used to attempt to complete the payment.
  var route: Lnrpc_Route {
    get {return _route ?? Lnrpc_Route()}
    set {_route = newValue}
  }
  /// Returns true if `route` has been explicitly set.
  var hasRoute: Bool {return self._route != nil}
  /// Clears the value of `route`. Subsequent reads from it will return its default value.
  mutating func clearRoute() {self._route = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _route: Lnrpc_Route? = nil
}

struct Lnrpc_ChannelAcceptRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The pubkey of the node that wishes to open an inbound channel.
  var nodePubkey: Data = Data()

  /// The hash of the genesis block that the proposed channel resides in.
  var chainHash: Data = Data()

  /// The pending channel id.
  var pendingChanID: Data = Data()

  /// The funding amount in satoshis that initiator wishes to use in the
  /// channel.
  var fundingAmt: UInt64 = 0

  /// The push amount of the proposed channel in millisatoshis.
  var pushAmt: UInt64 = 0

  /// The dust limit of the initiator's commitment tx.
  var dustLimit: UInt64 = 0

  /// The maximum amount of coins in millisatoshis that can be pending in this
  /// channel.
  var maxValueInFlight: UInt64 = 0

  /// The minimum amount of satoshis the initiator requires us to have at all
  /// times.
  var channelReserve: UInt64 = 0

  /// The smallest HTLC in millisatoshis that the initiator will accept.
  var minHtlc: UInt64 = 0

  /// The initial fee rate that the initiator suggests for both commitment
  /// transactions.
  var feePerKw: UInt64 = 0

  ///
  ///The number of blocks to use for the relative time lock in the pay-to-self
  ///output of both commitment transactions.
  var csvDelay: UInt32 = 0

  /// The total number of incoming HTLC's that the initiator will accept.
  var maxAcceptedHtlcs: UInt32 = 0

  /// A bit-field which the initiator uses to specify proposed channel
  /// behavior.
  var channelFlags: UInt32 = 0

  /// The commitment type the initiator wishes to use for the proposed channel.
  var commitmentType: Lnrpc_CommitmentType = .unknownCommitmentType

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChannelAcceptResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether or not the client accepts the channel.
  var accept: Bool = false

  /// The pending channel id to which this response applies.
  var pendingChanID: Data = Data()

  ///
  ///An optional error to send the initiating party to indicate why the channel
  ///was rejected. This field *should not* contain sensitive information, it will
  ///be sent to the initiating party. This field should only be set if accept is
  ///false, the channel will be rejected if an error is set with accept=true
  ///because the meaning of this response is ambiguous. Limited to 500
  ///characters.
  var error: String = String()

  ///
  ///The upfront shutdown address to use if the initiating peer supports option
  ///upfront shutdown script (see ListPeers for the features supported). Note
  ///that the channel open will fail if this value is set for a peer that does
  ///not support this feature bit.
  var upfrontShutdown: String = String()

  ///
  ///The csv delay (in blocks) that we require for the remote party.
  var csvDelay: UInt32 = 0

  ///
  ///The reserve amount in satoshis that we require the remote peer to adhere to.
  ///We require that the remote peer always have some reserve amount allocated to
  ///them so that there is always a disincentive to broadcast old state (if they
  ///hold 0 sats on their side of the channel, there is nothing to lose).
  var reserveSat: UInt64 = 0

  ///
  ///The maximum amount of funds in millisatoshis that we allow the remote peer
  ///to have in outstanding htlcs.
  var inFlightMaxMsat: UInt64 = 0

  ///
  ///The maximum number of htlcs that the remote peer can offer us.
  var maxHtlcCount: UInt32 = 0

  ///
  ///The minimum value in millisatoshis for incoming htlcs on the channel.
  var minHtlcIn: UInt64 = 0

  ///
  ///The number of confirmations we require before we consider the channel open.
  var minAcceptDepth: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChannelPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fundingTxid: Lnrpc_ChannelPoint.OneOf_FundingTxid? = nil

  ///
  ///Txid of the funding transaction. When using REST, this field must be
  ///encoded as base64.
  var fundingTxidBytes: Data {
    get {
      if case .fundingTxidBytes(let v)? = fundingTxid {return v}
      return Data()
    }
    set {fundingTxid = .fundingTxidBytes(newValue)}
  }

  ///
  ///Hex-encoded string representing the byte-reversed hash of the funding
  ///transaction.
  var fundingTxidStr: String {
    get {
      if case .fundingTxidStr(let v)? = fundingTxid {return v}
      return String()
    }
    set {fundingTxid = .fundingTxidStr(newValue)}
  }

  /// The index of the output of the funding transaction
  var outputIndex: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_FundingTxid: Equatable {
    ///
    ///Txid of the funding transaction. When using REST, this field must be
    ///encoded as base64.
    case fundingTxidBytes(Data)
    ///
    ///Hex-encoded string representing the byte-reversed hash of the funding
    ///transaction.
    case fundingTxidStr(String)

  #if !swift(>=4.1)
    static func ==(lhs: Lnrpc_ChannelPoint.OneOf_FundingTxid, rhs: Lnrpc_ChannelPoint.OneOf_FundingTxid) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.fundingTxidBytes, .fundingTxidBytes): return {
        guard case .fundingTxidBytes(let l) = lhs, case .fundingTxidBytes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fundingTxidStr, .fundingTxidStr): return {
        guard case .fundingTxidStr(let l) = lhs, case .fundingTxidStr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Lnrpc_OutPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Raw bytes representing the transaction id.
  var txidBytes: Data = Data()

  /// Reversed, hex-encoded string representing the transaction id.
  var txidStr: String = String()

  /// The index of the output on the transaction.
  var outputIndex: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_LightningAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identity pubkey of the Lightning node
  var pubkey: String = String()

  /// The network location of the lightning node, e.g. `69.69.69.69:1337` or
  /// `localhost:10011`
  var host: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_EstimateFeeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The map from addresses to amounts for the transaction.
  var addrToAmount: Dictionary<String,Int64> = [:]

  /// The target number of blocks that this transaction should be confirmed
  /// by.
  var targetConf: Int32 = 0

  /// The minimum number of confirmations each one of your outputs used for
  /// the transaction must satisfy.
  var minConfs: Int32 = 0

  /// Whether unconfirmed outputs should be used as inputs for the transaction.
  var spendUnconfirmed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_EstimateFeeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The total fee in satoshis.
  var feeSat: Int64 = 0

  /// Deprecated, use sat_per_vbyte.
  /// The fee rate in satoshi/vbyte.
  var feerateSatPerByte: Int64 = 0

  /// The fee rate in satoshi/vbyte.
  var satPerVbyte: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_SendManyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The map from addresses to amounts
  var addrToAmount: Dictionary<String,Int64> = [:]

  /// The target number of blocks that this transaction should be confirmed
  /// by.
  var targetConf: Int32 = 0

  /// A manual fee rate set in sat/vbyte that should be used when crafting the
  /// transaction.
  var satPerVbyte: UInt64 = 0

  /// Deprecated, use sat_per_vbyte.
  /// A manual fee rate set in sat/vbyte that should be used when crafting the
  /// transaction.
  var satPerByte: Int64 = 0

  /// An optional label for the transaction, limited to 500 characters.
  var label: String = String()

  /// The minimum number of confirmations each one of your outputs used for
  /// the transaction must satisfy.
  var minConfs: Int32 = 0

  /// Whether unconfirmed outputs should be used as inputs for the transaction.
  var spendUnconfirmed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_SendManyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the transaction
  var txid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_SendCoinsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The address to send coins to
  var addr: String = String()

  /// The amount in satoshis to send
  var amount: Int64 = 0

  /// The target number of blocks that this transaction should be confirmed
  /// by.
  var targetConf: Int32 = 0

  /// A manual fee rate set in sat/vbyte that should be used when crafting the
  /// transaction.
  var satPerVbyte: UInt64 = 0

  /// Deprecated, use sat_per_vbyte.
  /// A manual fee rate set in sat/vbyte that should be used when crafting the
  /// transaction.
  var satPerByte: Int64 = 0

  ///
  ///If set, then the amount field will be ignored, and lnd will attempt to
  ///send all the coins under control of the internal wallet to the specified
  ///address.
  var sendAll: Bool = false

  /// An optional label for the transaction, limited to 500 characters.
  var label: String = String()

  /// The minimum number of confirmations each one of your outputs used for
  /// the transaction must satisfy.
  var minConfs: Int32 = 0

  /// Whether unconfirmed outputs should be used as inputs for the transaction.
  var spendUnconfirmed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_SendCoinsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The transaction ID of the transaction
  var txid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListUnspentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The minimum number of confirmations to be included.
  var minConfs: Int32 = 0

  /// The maximum number of confirmations to be included.
  var maxConfs: Int32 = 0

  /// An optional filter to only include outputs belonging to an account.
  var account: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListUnspentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of utxos
  var utxos: [Lnrpc_Utxo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_NewAddressRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of address to generate.
  var type: Lnrpc_AddressType = .witnessPubkeyHash

  ///
  ///The name of the account to generate a new address for. If empty, the
  ///default wallet account is used.
  var account: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_NewAddressResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The newly generated wallet address
  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_SignMessageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The message to be signed. When using REST, this field must be encoded as
  ///base64.
  var msg: Data = Data()

  ///
  ///Instead of the default double-SHA256 hashing of the message before signing,
  ///only use one round of hashing instead.
  var singleHash: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_SignMessageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The signature for the given message
  var signature: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_VerifyMessageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The message over which the signature is to be verified. When using REST,
  ///this field must be encoded as base64.
  var msg: Data = Data()

  /// The signature to be verified over the given message
  var signature: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_VerifyMessageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the signature was valid over the given message
  var valid: Bool = false

  /// The pubkey recovered from the signature
  var pubkey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ConnectPeerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Lightning address of the peer, in the format `<pubkey>@host`
  var addr: Lnrpc_LightningAddress {
    get {return _addr ?? Lnrpc_LightningAddress()}
    set {_addr = newValue}
  }
  /// Returns true if `addr` has been explicitly set.
  var hasAddr: Bool {return self._addr != nil}
  /// Clears the value of `addr`. Subsequent reads from it will return its default value.
  mutating func clearAddr() {self._addr = nil}

  /// If set, the daemon will attempt to persistently connect to the target
  /// peer. Otherwise, the call will be synchronous. 
  var perm: Bool = false

  ///
  ///The connection timeout value (in seconds) for this request. It won't affect
  ///other requests.
  var timeout: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _addr: Lnrpc_LightningAddress? = nil
}

struct Lnrpc_ConnectPeerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_DisconnectPeerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The pubkey of the node to disconnect from
  var pubKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_DisconnectPeerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_HTLC {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var incoming: Bool = false

  var amount: Int64 = 0

  var hashLock: Data = Data()

  var expirationHeight: UInt32 = 0

  /// Index identifying the htlc on the channel.
  var htlcIndex: UInt64 = 0

  /// If this HTLC is involved in a forwarding operation, this field indicates
  /// the forwarding channel. For an outgoing htlc, it is the incoming channel.
  /// For an incoming htlc, it is the outgoing channel. When the htlc
  /// originates from this node or this node is the final destination,
  /// forwarding_channel will be zero. The forwarding channel will also be zero
  /// for htlcs that need to be forwarded but don't have a forwarding decision
  /// persisted yet.
  var forwardingChannel: UInt64 = 0

  /// Index identifying the htlc on the forwarding channel.
  var forwardingHtlcIndex: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChannelConstraints {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The CSV delay expressed in relative blocks. If the channel is force closed,
  ///we will need to wait for this many blocks before we can regain our funds.
  var csvDelay: UInt32 = 0

  /// The minimum satoshis this node is required to reserve in its balance.
  var chanReserveSat: UInt64 = 0

  /// The dust limit (in satoshis) of the initiator's commitment tx.
  var dustLimitSat: UInt64 = 0

  /// The maximum amount of coins in millisatoshis that can be pending in this
  /// channel.
  var maxPendingAmtMsat: UInt64 = 0

  /// The smallest HTLC in millisatoshis that the initiator will accept.
  var minHtlcMsat: UInt64 = 0

  /// The total number of incoming HTLC's that the initiator will accept.
  var maxAcceptedHtlcs: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_Channel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether this channel is active or not
  var active: Bool {
    get {return _storage._active}
    set {_uniqueStorage()._active = newValue}
  }

  /// The identity pubkey of the remote node
  var remotePubkey: String {
    get {return _storage._remotePubkey}
    set {_uniqueStorage()._remotePubkey = newValue}
  }

  ///
  ///The outpoint (txid:index) of the funding transaction. With this value, Bob
  ///will be able to generate a signature for Alice's version of the commitment
  ///transaction.
  var channelPoint: String {
    get {return _storage._channelPoint}
    set {_uniqueStorage()._channelPoint = newValue}
  }

  ///
  ///The unique channel ID for the channel. The first 3 bytes are the block
  ///height, the next 3 the index within the block, and the last 2 bytes are the
  ///output index for the channel.
  var chanID: UInt64 {
    get {return _storage._chanID}
    set {_uniqueStorage()._chanID = newValue}
  }

  /// The total amount of funds held in this channel
  var capacity: Int64 {
    get {return _storage._capacity}
    set {_uniqueStorage()._capacity = newValue}
  }

  /// This node's current balance in this channel
  var localBalance: Int64 {
    get {return _storage._localBalance}
    set {_uniqueStorage()._localBalance = newValue}
  }

  /// The counterparty's current balance in this channel
  var remoteBalance: Int64 {
    get {return _storage._remoteBalance}
    set {_uniqueStorage()._remoteBalance = newValue}
  }

  ///
  ///The amount calculated to be paid in fees for the current set of commitment
  ///transactions. The fee amount is persisted with the channel in order to
  ///allow the fee amount to be removed and recalculated with each channel state
  ///update, including updates that happen after a system restart.
  var commitFee: Int64 {
    get {return _storage._commitFee}
    set {_uniqueStorage()._commitFee = newValue}
  }

  /// The weight of the commitment transaction
  var commitWeight: Int64 {
    get {return _storage._commitWeight}
    set {_uniqueStorage()._commitWeight = newValue}
  }

  ///
  ///The required number of satoshis per kilo-weight that the requester will pay
  ///at all times, for both the funding transaction and commitment transaction.
  ///This value can later be updated once the channel is open.
  var feePerKw: Int64 {
    get {return _storage._feePerKw}
    set {_uniqueStorage()._feePerKw = newValue}
  }

  /// The unsettled balance in this channel
  var unsettledBalance: Int64 {
    get {return _storage._unsettledBalance}
    set {_uniqueStorage()._unsettledBalance = newValue}
  }

  ///
  ///The total number of satoshis we've sent within this channel.
  var totalSatoshisSent: Int64 {
    get {return _storage._totalSatoshisSent}
    set {_uniqueStorage()._totalSatoshisSent = newValue}
  }

  ///
  ///The total number of satoshis we've received within this channel.
  var totalSatoshisReceived: Int64 {
    get {return _storage._totalSatoshisReceived}
    set {_uniqueStorage()._totalSatoshisReceived = newValue}
  }

  ///
  ///The total number of updates conducted within this channel.
  var numUpdates: UInt64 {
    get {return _storage._numUpdates}
    set {_uniqueStorage()._numUpdates = newValue}
  }

  ///
  ///The list of active, uncleared HTLCs currently pending within the channel.
  var pendingHtlcs: [Lnrpc_HTLC] {
    get {return _storage._pendingHtlcs}
    set {_uniqueStorage()._pendingHtlcs = newValue}
  }

  ///
  ///Deprecated. The CSV delay expressed in relative blocks. If the channel is
  ///force closed, we will need to wait for this many blocks before we can regain
  ///our funds.
  var csvDelay: UInt32 {
    get {return _storage._csvDelay}
    set {_uniqueStorage()._csvDelay = newValue}
  }

  /// Whether this channel is advertised to the network or not.
  var `private`: Bool {
    get {return _storage._private}
    set {_uniqueStorage()._private = newValue}
  }

  /// True if we were the ones that created the channel.
  var initiator: Bool {
    get {return _storage._initiator}
    set {_uniqueStorage()._initiator = newValue}
  }

  /// A set of flags showing the current state of the channel.
  var chanStatusFlags: String {
    get {return _storage._chanStatusFlags}
    set {_uniqueStorage()._chanStatusFlags = newValue}
  }

  /// Deprecated. The minimum satoshis this node is required to reserve in its
  /// balance.
  var localChanReserveSat: Int64 {
    get {return _storage._localChanReserveSat}
    set {_uniqueStorage()._localChanReserveSat = newValue}
  }

  ///
  ///Deprecated. The minimum satoshis the other node is required to reserve in
  ///its balance.
  var remoteChanReserveSat: Int64 {
    get {return _storage._remoteChanReserveSat}
    set {_uniqueStorage()._remoteChanReserveSat = newValue}
  }

  /// Deprecated. Use commitment_type.
  var staticRemoteKey: Bool {
    get {return _storage._staticRemoteKey}
    set {_uniqueStorage()._staticRemoteKey = newValue}
  }

  /// The commitment type used by this channel.
  var commitmentType: Lnrpc_CommitmentType {
    get {return _storage._commitmentType}
    set {_uniqueStorage()._commitmentType = newValue}
  }

  ///
  ///The number of seconds that the channel has been monitored by the channel
  ///scoring system. Scores are currently not persisted, so this value may be
  ///less than the lifetime of the channel [EXPERIMENTAL].
  var lifetime: Int64 {
    get {return _storage._lifetime}
    set {_uniqueStorage()._lifetime = newValue}
  }

  ///
  ///The number of seconds that the remote peer has been observed as being online
  ///by the channel scoring system over the lifetime of the channel
  ///[EXPERIMENTAL].
  var uptime: Int64 {
    get {return _storage._uptime}
    set {_uniqueStorage()._uptime = newValue}
  }

  ///
  ///Close address is the address that we will enforce payout to on cooperative
  ///close if the channel was opened utilizing option upfront shutdown. This
  ///value can be set on channel open by setting close_address in an open channel
  ///request. If this value is not set, you can still choose a payout address by
  ///cooperatively closing with the delivery_address field set.
  var closeAddress: String {
    get {return _storage._closeAddress}
    set {_uniqueStorage()._closeAddress = newValue}
  }

  ///
  ///The amount that the initiator of the channel optionally pushed to the remote
  ///party on channel open. This amount will be zero if the channel initiator did
  ///not push any funds to the remote peer. If the initiator field is true, we
  ///pushed this amount to our peer, if it is false, the remote peer pushed this
  ///amount to us.
  var pushAmountSat: UInt64 {
    get {return _storage._pushAmountSat}
    set {_uniqueStorage()._pushAmountSat = newValue}
  }

  ///
  ///This uint32 indicates if this channel is to be considered 'frozen'. A
  ///frozen channel doest not allow a cooperative channel close by the
  ///initiator. The thaw_height is the height that this restriction stops
  ///applying to the channel. This field is optional, not setting it or using a
  ///value of zero will mean the channel has no additional restrictions. The
  ///height can be interpreted in two ways: as a relative height if the value is
  ///less than 500,000, or as an absolute height otherwise.
  var thawHeight: UInt32 {
    get {return _storage._thawHeight}
    set {_uniqueStorage()._thawHeight = newValue}
  }

  /// List constraints for the local node.
  var localConstraints: Lnrpc_ChannelConstraints {
    get {return _storage._localConstraints ?? Lnrpc_ChannelConstraints()}
    set {_uniqueStorage()._localConstraints = newValue}
  }
  /// Returns true if `localConstraints` has been explicitly set.
  var hasLocalConstraints: Bool {return _storage._localConstraints != nil}
  /// Clears the value of `localConstraints`. Subsequent reads from it will return its default value.
  mutating func clearLocalConstraints() {_uniqueStorage()._localConstraints = nil}

  /// List constraints for the remote node.
  var remoteConstraints: Lnrpc_ChannelConstraints {
    get {return _storage._remoteConstraints ?? Lnrpc_ChannelConstraints()}
    set {_uniqueStorage()._remoteConstraints = newValue}
  }
  /// Returns true if `remoteConstraints` has been explicitly set.
  var hasRemoteConstraints: Bool {return _storage._remoteConstraints != nil}
  /// Clears the value of `remoteConstraints`. Subsequent reads from it will return its default value.
  mutating func clearRemoteConstraints() {_uniqueStorage()._remoteConstraints = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_ListChannelsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var activeOnly: Bool = false

  var inactiveOnly: Bool = false

  var publicOnly: Bool = false

  var privateOnly: Bool = false

  ///
  ///Filters the response for channels with a target peer's pubkey. If peer is
  ///empty, all channels will be returned.
  var peer: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListChannelsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of active channels
  var channels: [Lnrpc_Channel] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChannelCloseSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The outpoint (txid:index) of the funding transaction.
  var channelPoint: String = String()

  ///  The unique channel ID for the channel.
  var chanID: UInt64 = 0

  /// The hash of the genesis block that this channel resides within.
  var chainHash: String = String()

  /// The txid of the transaction which ultimately closed this channel.
  var closingTxHash: String = String()

  /// Public key of the remote peer that we formerly had a channel with.
  var remotePubkey: String = String()

  /// Total capacity of the channel.
  var capacity: Int64 = 0

  /// Height at which the funding transaction was spent.
  var closeHeight: UInt32 = 0

  /// Settled balance at the time of channel closure
  var settledBalance: Int64 = 0

  /// The sum of all the time-locked outputs at the time of channel closure
  var timeLockedBalance: Int64 = 0

  /// Details on how the channel was closed.
  var closeType: Lnrpc_ChannelCloseSummary.ClosureType = .cooperativeClose

  ///
  ///Open initiator is the party that initiated opening the channel. Note that
  ///this value may be unknown if the channel was closed before we migrated to
  ///store open channel information after close.
  var openInitiator: Lnrpc_Initiator = .unknown

  ///
  ///Close initiator indicates which party initiated the close. This value will
  ///be unknown for channels that were cooperatively closed before we started
  ///tracking cooperative close initiators. Note that this indicates which party
  ///initiated a close, and it is possible for both to initiate cooperative or
  ///force closes, although only one party's close will be confirmed on chain.
  var closeInitiator: Lnrpc_Initiator = .unknown

  var resolutions: [Lnrpc_Resolution] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ClosureType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case cooperativeClose // = 0
    case localForceClose // = 1
    case remoteForceClose // = 2
    case breachClose // = 3
    case fundingCanceled // = 4
    case abandoned // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .cooperativeClose
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .cooperativeClose
      case 1: self = .localForceClose
      case 2: self = .remoteForceClose
      case 3: self = .breachClose
      case 4: self = .fundingCanceled
      case 5: self = .abandoned
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .cooperativeClose: return 0
      case .localForceClose: return 1
      case .remoteForceClose: return 2
      case .breachClose: return 3
      case .fundingCanceled: return 4
      case .abandoned: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Lnrpc_ChannelCloseSummary.ClosureType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Lnrpc_ChannelCloseSummary.ClosureType] = [
    .cooperativeClose,
    .localForceClose,
    .remoteForceClose,
    .breachClose,
    .fundingCanceled,
    .abandoned,
  ]
}

#endif  // swift(>=4.2)

struct Lnrpc_Resolution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of output we are resolving.
  var resolutionType: Lnrpc_ResolutionType = .typeUnknown

  /// The outcome of our on chain action that resolved the outpoint.
  var outcome: Lnrpc_ResolutionOutcome = .outcomeUnknown

  /// The outpoint that was spent by the resolution.
  var outpoint: Lnrpc_OutPoint {
    get {return _outpoint ?? Lnrpc_OutPoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  /// The amount that was claimed by the resolution.
  var amountSat: UInt64 = 0

  /// The hex-encoded transaction ID of the sweep transaction that spent the
  /// output.
  var sweepTxid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outpoint: Lnrpc_OutPoint? = nil
}

struct Lnrpc_ClosedChannelsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cooperative: Bool = false

  var localForce: Bool = false

  var remoteForce: Bool = false

  var breach: Bool = false

  var fundingCanceled: Bool = false

  var abandoned: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ClosedChannelsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channels: [Lnrpc_ChannelCloseSummary] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_Peer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identity pubkey of the peer
  var pubKey: String = String()

  /// Network address of the peer; eg `127.0.0.1:10011`
  var address: String = String()

  /// Bytes of data transmitted to this peer
  var bytesSent: UInt64 = 0

  /// Bytes of data transmitted from this peer
  var bytesRecv: UInt64 = 0

  /// Satoshis sent to this peer
  var satSent: Int64 = 0

  /// Satoshis received from this peer
  var satRecv: Int64 = 0

  /// A channel is inbound if the counterparty initiated the channel
  var inbound: Bool = false

  /// Ping time to this peer
  var pingTime: Int64 = 0

  /// The type of sync we are currently performing with this peer.
  var syncType: Lnrpc_Peer.SyncType = .unknownSync

  /// Features advertised by the remote peer in their init message.
  var features: Dictionary<UInt32,Lnrpc_Feature> = [:]

  ///
  ///The latest errors received from our peer with timestamps, limited to the 10
  ///most recent errors. These errors are tracked across peer connections, but
  ///are not persisted across lnd restarts. Note that these errors are only
  ///stored for peers that we have channels open with, to prevent peers from
  ///spamming us with errors at no cost.
  var errors: [Lnrpc_TimestampedError] = []

  ///
  ///The number of times we have recorded this peer going offline or coming
  ///online, recorded across restarts. Note that this value is decreased over
  ///time if the peer has not recently flapped, so that we can forgive peers
  ///with historically high flap counts.
  var flapCount: Int32 = 0

  ///
  ///The timestamp of the last flap we observed for this peer. If this value is
  ///zero, we have not observed any flaps for this peer.
  var lastFlapNs: Int64 = 0

  ///
  ///The last ping payload the peer has sent to us.
  var lastPingPayload: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum SyncType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///
    ///Denotes that we cannot determine the peer's current sync type.
    case unknownSync // = 0

    ///
    ///Denotes that we are actively receiving new graph updates from the peer.
    case activeSync // = 1

    ///
    ///Denotes that we are not receiving new graph updates from the peer.
    case passiveSync // = 2

    ///
    ///Denotes that this peer is pinned into an active sync.
    case pinnedSync // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unknownSync
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownSync
      case 1: self = .activeSync
      case 2: self = .passiveSync
      case 3: self = .pinnedSync
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownSync: return 0
      case .activeSync: return 1
      case .passiveSync: return 2
      case .pinnedSync: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Lnrpc_Peer.SyncType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Lnrpc_Peer.SyncType] = [
    .unknownSync,
    .activeSync,
    .passiveSync,
    .pinnedSync,
  ]
}

#endif  // swift(>=4.2)

struct Lnrpc_TimestampedError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unix timestamp in seconds when the error occurred.
  var timestamp: UInt64 = 0

  /// The string representation of the error sent by our peer.
  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListPeersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///If true, only the last error that our peer sent us will be returned with
  ///the peer's information, rather than the full set of historic errors we have
  ///stored.
  var latestError: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListPeersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of currently connected peers
  var peers: [Lnrpc_Peer] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_PeerEventSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_PeerEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identity pubkey of the peer.
  var pubKey: String = String()

  var type: Lnrpc_PeerEvent.EventType = .peerOnline

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum EventType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case peerOnline // = 0
    case peerOffline // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .peerOnline
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .peerOnline
      case 1: self = .peerOffline
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .peerOnline: return 0
      case .peerOffline: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Lnrpc_PeerEvent.EventType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Lnrpc_PeerEvent.EventType] = [
    .peerOnline,
    .peerOffline,
  ]
}

#endif  // swift(>=4.2)

struct Lnrpc_GetInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_GetInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The version of the LND software that the node is running.
  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// The SHA1 commit hash that the daemon is compiled with.
  var commitHash: String {
    get {return _storage._commitHash}
    set {_uniqueStorage()._commitHash = newValue}
  }

  /// The identity pubkey of the current node.
  var identityPubkey: String {
    get {return _storage._identityPubkey}
    set {_uniqueStorage()._identityPubkey = newValue}
  }

  /// If applicable, the alias of the current node, e.g. "bob"
  var alias: String {
    get {return _storage._alias}
    set {_uniqueStorage()._alias = newValue}
  }

  /// The color of the current node in hex code format
  var color: String {
    get {return _storage._color}
    set {_uniqueStorage()._color = newValue}
  }

  /// Number of pending channels
  var numPendingChannels: UInt32 {
    get {return _storage._numPendingChannels}
    set {_uniqueStorage()._numPendingChannels = newValue}
  }

  /// Number of active channels
  var numActiveChannels: UInt32 {
    get {return _storage._numActiveChannels}
    set {_uniqueStorage()._numActiveChannels = newValue}
  }

  /// Number of inactive channels
  var numInactiveChannels: UInt32 {
    get {return _storage._numInactiveChannels}
    set {_uniqueStorage()._numInactiveChannels = newValue}
  }

  /// Number of peers
  var numPeers: UInt32 {
    get {return _storage._numPeers}
    set {_uniqueStorage()._numPeers = newValue}
  }

  /// The node's current view of the height of the best block
  var blockHeight: UInt32 {
    get {return _storage._blockHeight}
    set {_uniqueStorage()._blockHeight = newValue}
  }

  /// The node's current view of the hash of the best block
  var blockHash: String {
    get {return _storage._blockHash}
    set {_uniqueStorage()._blockHash = newValue}
  }

  /// Timestamp of the block best known to the wallet
  var bestHeaderTimestamp: Int64 {
    get {return _storage._bestHeaderTimestamp}
    set {_uniqueStorage()._bestHeaderTimestamp = newValue}
  }

  /// Whether the wallet's view is synced to the main chain
  var syncedToChain: Bool {
    get {return _storage._syncedToChain}
    set {_uniqueStorage()._syncedToChain = newValue}
  }

  /// Whether we consider ourselves synced with the public channel graph.
  var syncedToGraph: Bool {
    get {return _storage._syncedToGraph}
    set {_uniqueStorage()._syncedToGraph = newValue}
  }

  ///
  ///Whether the current node is connected to testnet. This field is
  ///deprecated and the network field should be used instead
  var testnet: Bool {
    get {return _storage._testnet}
    set {_uniqueStorage()._testnet = newValue}
  }

  /// A list of active chains the node is connected to
  var chains: [Lnrpc_Chain] {
    get {return _storage._chains}
    set {_uniqueStorage()._chains = newValue}
  }

  /// The URIs of the current node.
  var uris: [String] {
    get {return _storage._uris}
    set {_uniqueStorage()._uris = newValue}
  }

  ///
  ///Features that our node has advertised in our init message, node
  ///announcements and invoices.
  var features: Dictionary<UInt32,Lnrpc_Feature> {
    get {return _storage._features}
    set {_uniqueStorage()._features = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_GetRecoveryInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_GetRecoveryInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the wallet is in recovery mode
  var recoveryMode: Bool = false

  /// Whether the wallet recovery progress is finished
  var recoveryFinished: Bool = false

  /// The recovery progress, ranging from 0 to 1.
  var progress: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_Chain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The blockchain the node is on (eg bitcoin, litecoin)
  var chain: String = String()

  /// The network the node is on (eg regtest, testnet, mainnet)
  var network: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ConfirmationUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blockSha: Data = Data()

  var blockHeight: Int32 = 0

  var numConfsLeft: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChannelOpenUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channelPoint: Lnrpc_ChannelPoint {
    get {return _channelPoint ?? Lnrpc_ChannelPoint()}
    set {_channelPoint = newValue}
  }
  /// Returns true if `channelPoint` has been explicitly set.
  var hasChannelPoint: Bool {return self._channelPoint != nil}
  /// Clears the value of `channelPoint`. Subsequent reads from it will return its default value.
  mutating func clearChannelPoint() {self._channelPoint = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _channelPoint: Lnrpc_ChannelPoint? = nil
}

struct Lnrpc_ChannelCloseUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var closingTxid: Data = Data()

  var success: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_CloseChannelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The outpoint (txid:index) of the funding transaction. With this value, Bob
  ///will be able to generate a signature for Alice's version of the commitment
  ///transaction.
  var channelPoint: Lnrpc_ChannelPoint {
    get {return _channelPoint ?? Lnrpc_ChannelPoint()}
    set {_channelPoint = newValue}
  }
  /// Returns true if `channelPoint` has been explicitly set.
  var hasChannelPoint: Bool {return self._channelPoint != nil}
  /// Clears the value of `channelPoint`. Subsequent reads from it will return its default value.
  mutating func clearChannelPoint() {self._channelPoint = nil}

  /// If true, then the channel will be closed forcibly. This means the
  /// current commitment transaction will be signed and broadcast.
  var force: Bool = false

  /// The target number of blocks that the closure transaction should be
  /// confirmed by.
  var targetConf: Int32 = 0

  /// Deprecated, use sat_per_vbyte.
  /// A manual fee rate set in sat/vbyte that should be used when crafting the
  /// closure transaction.
  var satPerByte: Int64 = 0

  ///
  ///An optional address to send funds to in the case of a cooperative close.
  ///If the channel was opened with an upfront shutdown script and this field
  ///is set, the request to close will fail because the channel must pay out
  ///to the upfront shutdown addresss.
  var deliveryAddress: String = String()

  /// A manual fee rate set in sat/vbyte that should be used when crafting the
  /// closure transaction.
  var satPerVbyte: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _channelPoint: Lnrpc_ChannelPoint? = nil
}

struct Lnrpc_CloseStatusUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var update: Lnrpc_CloseStatusUpdate.OneOf_Update? = nil

  var closePending: Lnrpc_PendingUpdate {
    get {
      if case .closePending(let v)? = update {return v}
      return Lnrpc_PendingUpdate()
    }
    set {update = .closePending(newValue)}
  }

  var chanClose: Lnrpc_ChannelCloseUpdate {
    get {
      if case .chanClose(let v)? = update {return v}
      return Lnrpc_ChannelCloseUpdate()
    }
    set {update = .chanClose(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Update: Equatable {
    case closePending(Lnrpc_PendingUpdate)
    case chanClose(Lnrpc_ChannelCloseUpdate)

  #if !swift(>=4.1)
    static func ==(lhs: Lnrpc_CloseStatusUpdate.OneOf_Update, rhs: Lnrpc_CloseStatusUpdate.OneOf_Update) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.closePending, .closePending): return {
        guard case .closePending(let l) = lhs, case .closePending(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chanClose, .chanClose): return {
        guard case .chanClose(let l) = lhs, case .chanClose(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Lnrpc_PendingUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txid: Data = Data()

  var outputIndex: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ReadyForPsbtFunding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The P2WSH address of the channel funding multisig address that the below
  ///specified amount in satoshis needs to be sent to.
  var fundingAddress: String = String()

  ///
  ///The exact amount in satoshis that needs to be sent to the above address to
  ///fund the pending channel.
  var fundingAmount: Int64 = 0

  ///
  ///A raw PSBT that contains the pending channel output. If a base PSBT was
  ///provided in the PsbtShim, this is the base PSBT with one additional output.
  ///If no base PSBT was specified, this is an otherwise empty PSBT with exactly
  ///one output.
  var psbt: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_BatchOpenChannelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of channels to open.
  var channels: [Lnrpc_BatchOpenChannel] = []

  /// The target number of blocks that the funding transaction should be
  /// confirmed by.
  var targetConf: Int32 = 0

  /// A manual fee rate set in sat/vByte that should be used when crafting the
  /// funding transaction.
  var satPerVbyte: Int64 = 0

  /// The minimum number of confirmations each one of your outputs used for
  /// the funding transaction must satisfy.
  var minConfs: Int32 = 0

  /// Whether unconfirmed outputs should be used as inputs for the funding
  /// transaction.
  var spendUnconfirmed: Bool = false

  /// An optional label for the batch transaction, limited to 500 characters.
  var label: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_BatchOpenChannel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The pubkey of the node to open a channel with. When using REST, this
  /// field must be encoded as base64.
  var nodePubkey: Data = Data()

  /// The number of satoshis the wallet should commit to the channel.
  var localFundingAmount: Int64 = 0

  /// The number of satoshis to push to the remote side as part of the initial
  /// commitment state.
  var pushSat: Int64 = 0

  /// Whether this channel should be private, not announced to the greater
  /// network.
  var `private`: Bool = false

  /// The minimum value in millisatoshi we will require for incoming HTLCs on
  /// the channel.
  var minHtlcMsat: Int64 = 0

  /// The delay we require on the remote's commitment transaction. If this is
  /// not set, it will be scaled automatically with the channel size.
  var remoteCsvDelay: UInt32 = 0

  ///
  ///Close address is an optional address which specifies the address to which
  ///funds should be paid out to upon cooperative close. This field may only be
  ///set if the peer supports the option upfront feature bit (call listpeers
  ///to check). The remote peer will only accept cooperative closes to this
  ///address if it is set.
  ///
  ///Note: If this value is set on channel creation, you will *not* be able to
  ///cooperatively close out to a different address.
  var closeAddress: String = String()

  ///
  ///An optional, unique identifier of 32 random bytes that will be used as the
  ///pending channel ID to identify the channel while it is in the pre-pending
  ///state.
  var pendingChanID: Data = Data()

  ///
  ///The explicit commitment type to use. Note this field will only be used if
  ///the remote peer supports explicit channel negotiation.
  var commitmentType: Lnrpc_CommitmentType = .unknownCommitmentType

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_BatchOpenChannelResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pendingChannels: [Lnrpc_PendingUpdate] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_OpenChannelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A manual fee rate set in sat/vbyte that should be used when crafting the
  /// funding transaction.
  var satPerVbyte: UInt64 {
    get {return _storage._satPerVbyte}
    set {_uniqueStorage()._satPerVbyte = newValue}
  }

  ///
  ///The pubkey of the node to open a channel with. When using REST, this field
  ///must be encoded as base64.
  var nodePubkey: Data {
    get {return _storage._nodePubkey}
    set {_uniqueStorage()._nodePubkey = newValue}
  }

  ///
  ///The hex encoded pubkey of the node to open a channel with. Deprecated now
  ///that the REST gateway supports base64 encoding of bytes fields.
  var nodePubkeyString: String {
    get {return _storage._nodePubkeyString}
    set {_uniqueStorage()._nodePubkeyString = newValue}
  }

  /// The number of satoshis the wallet should commit to the channel
  var localFundingAmount: Int64 {
    get {return _storage._localFundingAmount}
    set {_uniqueStorage()._localFundingAmount = newValue}
  }

  /// The number of satoshis to push to the remote side as part of the initial
  /// commitment state
  var pushSat: Int64 {
    get {return _storage._pushSat}
    set {_uniqueStorage()._pushSat = newValue}
  }

  /// The target number of blocks that the funding transaction should be
  /// confirmed by.
  var targetConf: Int32 {
    get {return _storage._targetConf}
    set {_uniqueStorage()._targetConf = newValue}
  }

  /// Deprecated, use sat_per_vbyte.
  /// A manual fee rate set in sat/vbyte that should be used when crafting the
  /// funding transaction.
  var satPerByte: Int64 {
    get {return _storage._satPerByte}
    set {_uniqueStorage()._satPerByte = newValue}
  }

  /// Whether this channel should be private, not announced to the greater
  /// network.
  var `private`: Bool {
    get {return _storage._private}
    set {_uniqueStorage()._private = newValue}
  }

  /// The minimum value in millisatoshi we will require for incoming HTLCs on
  /// the channel.
  var minHtlcMsat: Int64 {
    get {return _storage._minHtlcMsat}
    set {_uniqueStorage()._minHtlcMsat = newValue}
  }

  /// The delay we require on the remote's commitment transaction. If this is
  /// not set, it will be scaled automatically with the channel size.
  var remoteCsvDelay: UInt32 {
    get {return _storage._remoteCsvDelay}
    set {_uniqueStorage()._remoteCsvDelay = newValue}
  }

  /// The minimum number of confirmations each one of your outputs used for
  /// the funding transaction must satisfy.
  var minConfs: Int32 {
    get {return _storage._minConfs}
    set {_uniqueStorage()._minConfs = newValue}
  }

  /// Whether unconfirmed outputs should be used as inputs for the funding
  /// transaction.
  var spendUnconfirmed: Bool {
    get {return _storage._spendUnconfirmed}
    set {_uniqueStorage()._spendUnconfirmed = newValue}
  }

  ///
  ///Close address is an optional address which specifies the address to which
  ///funds should be paid out to upon cooperative close. This field may only be
  ///set if the peer supports the option upfront feature bit (call listpeers
  ///to check). The remote peer will only accept cooperative closes to this
  ///address if it is set.
  ///
  ///Note: If this value is set on channel creation, you will *not* be able to
  ///cooperatively close out to a different address.
  var closeAddress: String {
    get {return _storage._closeAddress}
    set {_uniqueStorage()._closeAddress = newValue}
  }

  ///
  ///Funding shims are an optional argument that allow the caller to intercept
  ///certain funding functionality. For example, a shim can be provided to use a
  ///particular key for the commitment key (ideally cold) rather than use one
  ///that is generated by the wallet as normal, or signal that signing will be
  ///carried out in an interactive manner (PSBT based).
  var fundingShim: Lnrpc_FundingShim {
    get {return _storage._fundingShim ?? Lnrpc_FundingShim()}
    set {_uniqueStorage()._fundingShim = newValue}
  }
  /// Returns true if `fundingShim` has been explicitly set.
  var hasFundingShim: Bool {return _storage._fundingShim != nil}
  /// Clears the value of `fundingShim`. Subsequent reads from it will return its default value.
  mutating func clearFundingShim() {_uniqueStorage()._fundingShim = nil}

  ///
  ///The maximum amount of coins in millisatoshi that can be pending within
  ///the channel. It only applies to the remote party.
  var remoteMaxValueInFlightMsat: UInt64 {
    get {return _storage._remoteMaxValueInFlightMsat}
    set {_uniqueStorage()._remoteMaxValueInFlightMsat = newValue}
  }

  ///
  ///The maximum number of concurrent HTLCs we will allow the remote party to add
  ///to the commitment transaction.
  var remoteMaxHtlcs: UInt32 {
    get {return _storage._remoteMaxHtlcs}
    set {_uniqueStorage()._remoteMaxHtlcs = newValue}
  }

  ///
  ///Max local csv is the maximum csv delay we will allow for our own commitment
  ///transaction.
  var maxLocalCsv: UInt32 {
    get {return _storage._maxLocalCsv}
    set {_uniqueStorage()._maxLocalCsv = newValue}
  }

  ///
  ///The explicit commitment type to use. Note this field will only be used if
  ///the remote peer supports explicit channel negotiation.
  var commitmentType: Lnrpc_CommitmentType {
    get {return _storage._commitmentType}
    set {_uniqueStorage()._commitmentType = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_OpenStatusUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var update: Lnrpc_OpenStatusUpdate.OneOf_Update? = nil

  ///
  ///Signals that the channel is now fully negotiated and the funding
  ///transaction published.
  var chanPending: Lnrpc_PendingUpdate {
    get {
      if case .chanPending(let v)? = update {return v}
      return Lnrpc_PendingUpdate()
    }
    set {update = .chanPending(newValue)}
  }

  ///
  ///Signals that the channel's funding transaction has now reached the
  ///required number of confirmations on chain and can be used.
  var chanOpen: Lnrpc_ChannelOpenUpdate {
    get {
      if case .chanOpen(let v)? = update {return v}
      return Lnrpc_ChannelOpenUpdate()
    }
    set {update = .chanOpen(newValue)}
  }

  ///
  ///Signals that the funding process has been suspended and the construction
  ///of a PSBT that funds the channel PK script is now required.
  var psbtFund: Lnrpc_ReadyForPsbtFunding {
    get {
      if case .psbtFund(let v)? = update {return v}
      return Lnrpc_ReadyForPsbtFunding()
    }
    set {update = .psbtFund(newValue)}
  }

  ///
  ///The pending channel ID of the created channel. This value may be used to
  ///further the funding flow manually via the FundingStateStep method.
  var pendingChanID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Update: Equatable {
    ///
    ///Signals that the channel is now fully negotiated and the funding
    ///transaction published.
    case chanPending(Lnrpc_PendingUpdate)
    ///
    ///Signals that the channel's funding transaction has now reached the
    ///required number of confirmations on chain and can be used.
    case chanOpen(Lnrpc_ChannelOpenUpdate)
    ///
    ///Signals that the funding process has been suspended and the construction
    ///of a PSBT that funds the channel PK script is now required.
    case psbtFund(Lnrpc_ReadyForPsbtFunding)

  #if !swift(>=4.1)
    static func ==(lhs: Lnrpc_OpenStatusUpdate.OneOf_Update, rhs: Lnrpc_OpenStatusUpdate.OneOf_Update) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.chanPending, .chanPending): return {
        guard case .chanPending(let l) = lhs, case .chanPending(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chanOpen, .chanOpen): return {
        guard case .chanOpen(let l) = lhs, case .chanOpen(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.psbtFund, .psbtFund): return {
        guard case .psbtFund(let l) = lhs, case .psbtFund(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Lnrpc_KeyLocator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The family of key being identified.
  var keyFamily: Int32 = 0

  /// The precise index of the key being identified.
  var keyIndex: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_KeyDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The raw bytes of the key being identified.
  var rawKeyBytes: Data = Data()

  ///
  ///The key locator that identifies which key to use for signing.
  var keyLoc: Lnrpc_KeyLocator {
    get {return _keyLoc ?? Lnrpc_KeyLocator()}
    set {_keyLoc = newValue}
  }
  /// Returns true if `keyLoc` has been explicitly set.
  var hasKeyLoc: Bool {return self._keyLoc != nil}
  /// Clears the value of `keyLoc`. Subsequent reads from it will return its default value.
  mutating func clearKeyLoc() {self._keyLoc = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _keyLoc: Lnrpc_KeyLocator? = nil
}

struct Lnrpc_ChanPointShim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The size of the pre-crafted output to be used as the channel point for this
  ///channel funding.
  var amt: Int64 = 0

  /// The target channel point to refrence in created commitment transactions.
  var chanPoint: Lnrpc_ChannelPoint {
    get {return _chanPoint ?? Lnrpc_ChannelPoint()}
    set {_chanPoint = newValue}
  }
  /// Returns true if `chanPoint` has been explicitly set.
  var hasChanPoint: Bool {return self._chanPoint != nil}
  /// Clears the value of `chanPoint`. Subsequent reads from it will return its default value.
  mutating func clearChanPoint() {self._chanPoint = nil}

  /// Our local key to use when creating the multi-sig output.
  var localKey: Lnrpc_KeyDescriptor {
    get {return _localKey ?? Lnrpc_KeyDescriptor()}
    set {_localKey = newValue}
  }
  /// Returns true if `localKey` has been explicitly set.
  var hasLocalKey: Bool {return self._localKey != nil}
  /// Clears the value of `localKey`. Subsequent reads from it will return its default value.
  mutating func clearLocalKey() {self._localKey = nil}

  /// The key of the remote party to use when creating the multi-sig output.
  var remoteKey: Data = Data()

  ///
  ///If non-zero, then this will be used as the pending channel ID on the wire
  ///protocol to initate the funding request. This is an optional field, and
  ///should only be set if the responder is already expecting a specific pending
  ///channel ID.
  var pendingChanID: Data = Data()

  ///
  ///This uint32 indicates if this channel is to be considered 'frozen'. A frozen
  ///channel does not allow a cooperative channel close by the initiator. The
  ///thaw_height is the height that this restriction stops applying to the
  ///channel. The height can be interpreted in two ways: as a relative height if
  ///the value is less than 500,000, or as an absolute height otherwise.
  var thawHeight: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _chanPoint: Lnrpc_ChannelPoint? = nil
  fileprivate var _localKey: Lnrpc_KeyDescriptor? = nil
}

struct Lnrpc_PsbtShim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///A unique identifier of 32 random bytes that will be used as the pending
  ///channel ID to identify the PSBT state machine when interacting with it and
  ///on the wire protocol to initiate the funding request.
  var pendingChanID: Data = Data()

  ///
  ///An optional base PSBT the new channel output will be added to. If this is
  ///non-empty, it must be a binary serialized PSBT.
  var basePsbt: Data = Data()

  ///
  ///If a channel should be part of a batch (multiple channel openings in one
  ///transaction), it can be dangerous if the whole batch transaction is
  ///published too early before all channel opening negotiations are completed.
  ///This flag prevents this particular channel from broadcasting the transaction
  ///after the negotiation with the remote peer. In a batch of channel openings
  ///this flag should be set to true for every channel but the very last.
  var noPublish: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_FundingShim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var shim: Lnrpc_FundingShim.OneOf_Shim? = nil

  ///
  ///A channel shim where the channel point was fully constructed outside
  ///of lnd's wallet and the transaction might already be published.
  var chanPointShim: Lnrpc_ChanPointShim {
    get {
      if case .chanPointShim(let v)? = shim {return v}
      return Lnrpc_ChanPointShim()
    }
    set {shim = .chanPointShim(newValue)}
  }

  ///
  ///A channel shim that uses a PSBT to fund and sign the channel funding
  ///transaction.
  var psbtShim: Lnrpc_PsbtShim {
    get {
      if case .psbtShim(let v)? = shim {return v}
      return Lnrpc_PsbtShim()
    }
    set {shim = .psbtShim(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Shim: Equatable {
    ///
    ///A channel shim where the channel point was fully constructed outside
    ///of lnd's wallet and the transaction might already be published.
    case chanPointShim(Lnrpc_ChanPointShim)
    ///
    ///A channel shim that uses a PSBT to fund and sign the channel funding
    ///transaction.
    case psbtShim(Lnrpc_PsbtShim)

  #if !swift(>=4.1)
    static func ==(lhs: Lnrpc_FundingShim.OneOf_Shim, rhs: Lnrpc_FundingShim.OneOf_Shim) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.chanPointShim, .chanPointShim): return {
        guard case .chanPointShim(let l) = lhs, case .chanPointShim(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.psbtShim, .psbtShim): return {
        guard case .psbtShim(let l) = lhs, case .psbtShim(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Lnrpc_FundingShimCancel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The pending channel ID of the channel to cancel the funding shim for.
  var pendingChanID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_FundingPsbtVerify {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The funded but not yet signed PSBT that sends the exact channel capacity
  ///amount to the PK script returned in the open channel message in a previous
  ///step.
  var fundedPsbt: Data = Data()

  /// The pending channel ID of the channel to get the PSBT for.
  var pendingChanID: Data = Data()

  ///
  ///Can only be used if the no_publish flag was set to true in the OpenChannel
  ///call meaning that the caller is solely responsible for publishing the final
  ///funding transaction. If skip_finalize is set to true then lnd will not wait
  ///for a FundingPsbtFinalize state step and instead assumes that a transaction
  ///with the same TXID as the passed in PSBT will eventually confirm.
  ///IT IS ABSOLUTELY IMPERATIVE that the TXID of the transaction that is
  ///eventually published does have the _same TXID_ as the verified PSBT. That
  ///means no inputs or outputs can change, only signatures can be added. If the
  ///TXID changes between this call and the publish step then the channel will
  ///never be created and the funds will be in limbo.
  var skipFinalize: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_FundingPsbtFinalize {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The funded PSBT that contains all witness data to send the exact channel
  ///capacity amount to the PK script returned in the open channel message in a
  ///previous step. Cannot be set at the same time as final_raw_tx.
  var signedPsbt: Data = Data()

  /// The pending channel ID of the channel to get the PSBT for.
  var pendingChanID: Data = Data()

  ///
  ///As an alternative to the signed PSBT with all witness data, the final raw
  ///wire format transaction can also be specified directly. Cannot be set at the
  ///same time as signed_psbt.
  var finalRawTx: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_FundingTransitionMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var trigger: Lnrpc_FundingTransitionMsg.OneOf_Trigger? = nil

  ///
  ///The funding shim to register. This should be used before any
  ///channel funding has began by the remote party, as it is intended as a
  ///preparatory step for the full channel funding.
  var shimRegister: Lnrpc_FundingShim {
    get {
      if case .shimRegister(let v)? = trigger {return v}
      return Lnrpc_FundingShim()
    }
    set {trigger = .shimRegister(newValue)}
  }

  /// Used to cancel an existing registered funding shim.
  var shimCancel: Lnrpc_FundingShimCancel {
    get {
      if case .shimCancel(let v)? = trigger {return v}
      return Lnrpc_FundingShimCancel()
    }
    set {trigger = .shimCancel(newValue)}
  }

  ///
  ///Used to continue a funding flow that was initiated to be executed
  ///through a PSBT. This step verifies that the PSBT contains the correct
  ///outputs to fund the channel.
  var psbtVerify: Lnrpc_FundingPsbtVerify {
    get {
      if case .psbtVerify(let v)? = trigger {return v}
      return Lnrpc_FundingPsbtVerify()
    }
    set {trigger = .psbtVerify(newValue)}
  }

  ///
  ///Used to continue a funding flow that was initiated to be executed
  ///through a PSBT. This step finalizes the funded and signed PSBT, finishes
  ///negotiation with the peer and finally publishes the resulting funding
  ///transaction.
  var psbtFinalize: Lnrpc_FundingPsbtFinalize {
    get {
      if case .psbtFinalize(let v)? = trigger {return v}
      return Lnrpc_FundingPsbtFinalize()
    }
    set {trigger = .psbtFinalize(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Trigger: Equatable {
    ///
    ///The funding shim to register. This should be used before any
    ///channel funding has began by the remote party, as it is intended as a
    ///preparatory step for the full channel funding.
    case shimRegister(Lnrpc_FundingShim)
    /// Used to cancel an existing registered funding shim.
    case shimCancel(Lnrpc_FundingShimCancel)
    ///
    ///Used to continue a funding flow that was initiated to be executed
    ///through a PSBT. This step verifies that the PSBT contains the correct
    ///outputs to fund the channel.
    case psbtVerify(Lnrpc_FundingPsbtVerify)
    ///
    ///Used to continue a funding flow that was initiated to be executed
    ///through a PSBT. This step finalizes the funded and signed PSBT, finishes
    ///negotiation with the peer and finally publishes the resulting funding
    ///transaction.
    case psbtFinalize(Lnrpc_FundingPsbtFinalize)

  #if !swift(>=4.1)
    static func ==(lhs: Lnrpc_FundingTransitionMsg.OneOf_Trigger, rhs: Lnrpc_FundingTransitionMsg.OneOf_Trigger) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.shimRegister, .shimRegister): return {
        guard case .shimRegister(let l) = lhs, case .shimRegister(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.shimCancel, .shimCancel): return {
        guard case .shimCancel(let l) = lhs, case .shimCancel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.psbtVerify, .psbtVerify): return {
        guard case .psbtVerify(let l) = lhs, case .psbtVerify(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.psbtFinalize, .psbtFinalize): return {
        guard case .psbtFinalize(let l) = lhs, case .psbtFinalize(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Lnrpc_FundingStateStepResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_PendingHTLC {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The direction within the channel that the htlc was sent
  var incoming: Bool = false

  /// The total value of the htlc
  var amount: Int64 = 0

  /// The final output to be swept back to the user's wallet
  var outpoint: String = String()

  /// The next block height at which we can spend the current stage
  var maturityHeight: UInt32 = 0

  ///
  ///The number of blocks remaining until the current stage can be swept.
  ///Negative values indicate how many blocks have passed since becoming
  ///mature.
  var blocksTilMaturity: Int32 = 0

  /// Indicates whether the htlc is in its first or second stage of recovery
  var stage: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_PendingChannelsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_PendingChannelsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The balance in satoshis encumbered in pending channels
  var totalLimboBalance: Int64 = 0

  /// Channels pending opening
  var pendingOpenChannels: [Lnrpc_PendingChannelsResponse.PendingOpenChannel] = []

  ///
  ///Deprecated: Channels pending closing previously contained cooperatively
  ///closed channels with a single confirmation. These channels are now
  ///considered closed from the time we see them on chain.
  var pendingClosingChannels: [Lnrpc_PendingChannelsResponse.ClosedChannel] = []

  /// Channels pending force closing
  var pendingForceClosingChannels: [Lnrpc_PendingChannelsResponse.ForceClosedChannel] = []

  /// Channels waiting for closing tx to confirm
  var waitingCloseChannels: [Lnrpc_PendingChannelsResponse.WaitingCloseChannel] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct PendingChannel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var remoteNodePub: String = String()

    var channelPoint: String = String()

    var capacity: Int64 = 0

    var localBalance: Int64 = 0

    var remoteBalance: Int64 = 0

    /// The minimum satoshis this node is required to reserve in its
    /// balance.
    var localChanReserveSat: Int64 = 0

    ///
    ///The minimum satoshis the other node is required to reserve in its
    ///balance.
    var remoteChanReserveSat: Int64 = 0

    /// The party that initiated opening the channel.
    var initiator: Lnrpc_Initiator = .unknown

    /// The commitment type used by this channel.
    var commitmentType: Lnrpc_CommitmentType = .unknownCommitmentType

    /// Total number of forwarding packages created in this channel.
    var numForwardingPackages: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PendingOpenChannel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The pending channel
    var channel: Lnrpc_PendingChannelsResponse.PendingChannel {
      get {return _channel ?? Lnrpc_PendingChannelsResponse.PendingChannel()}
      set {_channel = newValue}
    }
    /// Returns true if `channel` has been explicitly set.
    var hasChannel: Bool {return self._channel != nil}
    /// Clears the value of `channel`. Subsequent reads from it will return its default value.
    mutating func clearChannel() {self._channel = nil}

    /// The height at which this channel will be confirmed
    var confirmationHeight: UInt32 = 0

    ///
    ///The amount calculated to be paid in fees for the current set of
    ///commitment transactions. The fee amount is persisted with the channel
    ///in order to allow the fee amount to be removed and recalculated with
    ///each channel state update, including updates that happen after a system
    ///restart.
    var commitFee: Int64 = 0

    /// The weight of the commitment transaction
    var commitWeight: Int64 = 0

    ///
    ///The required number of satoshis per kilo-weight that the requester will
    ///pay at all times, for both the funding transaction and commitment
    ///transaction. This value can later be updated once the channel is open.
    var feePerKw: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _channel: Lnrpc_PendingChannelsResponse.PendingChannel? = nil
  }

  struct WaitingCloseChannel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The pending channel waiting for closing tx to confirm
    var channel: Lnrpc_PendingChannelsResponse.PendingChannel {
      get {return _storage._channel ?? Lnrpc_PendingChannelsResponse.PendingChannel()}
      set {_uniqueStorage()._channel = newValue}
    }
    /// Returns true if `channel` has been explicitly set.
    var hasChannel: Bool {return _storage._channel != nil}
    /// Clears the value of `channel`. Subsequent reads from it will return its default value.
    mutating func clearChannel() {_uniqueStorage()._channel = nil}

    /// The balance in satoshis encumbered in this channel
    var limboBalance: Int64 {
      get {return _storage._limboBalance}
      set {_uniqueStorage()._limboBalance = newValue}
    }

    ///
    ///A list of valid commitment transactions. Any of these can confirm at
    ///this point.
    var commitments: Lnrpc_PendingChannelsResponse.Commitments {
      get {return _storage._commitments ?? Lnrpc_PendingChannelsResponse.Commitments()}
      set {_uniqueStorage()._commitments = newValue}
    }
    /// Returns true if `commitments` has been explicitly set.
    var hasCommitments: Bool {return _storage._commitments != nil}
    /// Clears the value of `commitments`. Subsequent reads from it will return its default value.
    mutating func clearCommitments() {_uniqueStorage()._commitments = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Commitments {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Hash of the local version of the commitment tx.
    var localTxid: String = String()

    /// Hash of the remote version of the commitment tx.
    var remoteTxid: String = String()

    /// Hash of the remote pending version of the commitment tx.
    var remotePendingTxid: String = String()

    ///
    ///The amount in satoshis calculated to be paid in fees for the local
    ///commitment.
    var localCommitFeeSat: UInt64 = 0

    ///
    ///The amount in satoshis calculated to be paid in fees for the remote
    ///commitment.
    var remoteCommitFeeSat: UInt64 = 0

    ///
    ///The amount in satoshis calculated to be paid in fees for the remote
    ///pending commitment.
    var remotePendingCommitFeeSat: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ClosedChannel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The pending channel to be closed
    var channel: Lnrpc_PendingChannelsResponse.PendingChannel {
      get {return _channel ?? Lnrpc_PendingChannelsResponse.PendingChannel()}
      set {_channel = newValue}
    }
    /// Returns true if `channel` has been explicitly set.
    var hasChannel: Bool {return self._channel != nil}
    /// Clears the value of `channel`. Subsequent reads from it will return its default value.
    mutating func clearChannel() {self._channel = nil}

    /// The transaction id of the closing transaction
    var closingTxid: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _channel: Lnrpc_PendingChannelsResponse.PendingChannel? = nil
  }

  struct ForceClosedChannel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The pending channel to be force closed
    var channel: Lnrpc_PendingChannelsResponse.PendingChannel {
      get {return _storage._channel ?? Lnrpc_PendingChannelsResponse.PendingChannel()}
      set {_uniqueStorage()._channel = newValue}
    }
    /// Returns true if `channel` has been explicitly set.
    var hasChannel: Bool {return _storage._channel != nil}
    /// Clears the value of `channel`. Subsequent reads from it will return its default value.
    mutating func clearChannel() {_uniqueStorage()._channel = nil}

    /// The transaction id of the closing transaction
    var closingTxid: String {
      get {return _storage._closingTxid}
      set {_uniqueStorage()._closingTxid = newValue}
    }

    /// The balance in satoshis encumbered in this pending channel
    var limboBalance: Int64 {
      get {return _storage._limboBalance}
      set {_uniqueStorage()._limboBalance = newValue}
    }

    /// The height at which funds can be swept into the wallet
    var maturityHeight: UInt32 {
      get {return _storage._maturityHeight}
      set {_uniqueStorage()._maturityHeight = newValue}
    }

    ///
    ///Remaining # of blocks until the commitment output can be swept.
    ///Negative values indicate how many blocks have passed since becoming
    ///mature.
    var blocksTilMaturity: Int32 {
      get {return _storage._blocksTilMaturity}
      set {_uniqueStorage()._blocksTilMaturity = newValue}
    }

    /// The total value of funds successfully recovered from this channel
    var recoveredBalance: Int64 {
      get {return _storage._recoveredBalance}
      set {_uniqueStorage()._recoveredBalance = newValue}
    }

    var pendingHtlcs: [Lnrpc_PendingHTLC] {
      get {return _storage._pendingHtlcs}
      set {_uniqueStorage()._pendingHtlcs = newValue}
    }

    var anchor: Lnrpc_PendingChannelsResponse.ForceClosedChannel.AnchorState {
      get {return _storage._anchor}
      set {_uniqueStorage()._anchor = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum AnchorState: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case limbo // = 0
      case recovered // = 1
      case lost // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .limbo
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .limbo
        case 1: self = .recovered
        case 2: self = .lost
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .limbo: return 0
        case .recovered: return 1
        case .lost: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

#if swift(>=4.2)

extension Lnrpc_PendingChannelsResponse.ForceClosedChannel.AnchorState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Lnrpc_PendingChannelsResponse.ForceClosedChannel.AnchorState] = [
    .limbo,
    .recovered,
    .lost,
  ]
}

#endif  // swift(>=4.2)

struct Lnrpc_ChannelEventSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChannelEventUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channel: Lnrpc_ChannelEventUpdate.OneOf_Channel? = nil

  var openChannel: Lnrpc_Channel {
    get {
      if case .openChannel(let v)? = channel {return v}
      return Lnrpc_Channel()
    }
    set {channel = .openChannel(newValue)}
  }

  var closedChannel: Lnrpc_ChannelCloseSummary {
    get {
      if case .closedChannel(let v)? = channel {return v}
      return Lnrpc_ChannelCloseSummary()
    }
    set {channel = .closedChannel(newValue)}
  }

  var activeChannel: Lnrpc_ChannelPoint {
    get {
      if case .activeChannel(let v)? = channel {return v}
      return Lnrpc_ChannelPoint()
    }
    set {channel = .activeChannel(newValue)}
  }

  var inactiveChannel: Lnrpc_ChannelPoint {
    get {
      if case .inactiveChannel(let v)? = channel {return v}
      return Lnrpc_ChannelPoint()
    }
    set {channel = .inactiveChannel(newValue)}
  }

  var pendingOpenChannel: Lnrpc_PendingUpdate {
    get {
      if case .pendingOpenChannel(let v)? = channel {return v}
      return Lnrpc_PendingUpdate()
    }
    set {channel = .pendingOpenChannel(newValue)}
  }

  var fullyResolvedChannel: Lnrpc_ChannelPoint {
    get {
      if case .fullyResolvedChannel(let v)? = channel {return v}
      return Lnrpc_ChannelPoint()
    }
    set {channel = .fullyResolvedChannel(newValue)}
  }

  var type: Lnrpc_ChannelEventUpdate.UpdateType = .openChannel

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Channel: Equatable {
    case openChannel(Lnrpc_Channel)
    case closedChannel(Lnrpc_ChannelCloseSummary)
    case activeChannel(Lnrpc_ChannelPoint)
    case inactiveChannel(Lnrpc_ChannelPoint)
    case pendingOpenChannel(Lnrpc_PendingUpdate)
    case fullyResolvedChannel(Lnrpc_ChannelPoint)

  #if !swift(>=4.1)
    static func ==(lhs: Lnrpc_ChannelEventUpdate.OneOf_Channel, rhs: Lnrpc_ChannelEventUpdate.OneOf_Channel) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.openChannel, .openChannel): return {
        guard case .openChannel(let l) = lhs, case .openChannel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.closedChannel, .closedChannel): return {
        guard case .closedChannel(let l) = lhs, case .closedChannel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.activeChannel, .activeChannel): return {
        guard case .activeChannel(let l) = lhs, case .activeChannel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.inactiveChannel, .inactiveChannel): return {
        guard case .inactiveChannel(let l) = lhs, case .inactiveChannel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pendingOpenChannel, .pendingOpenChannel): return {
        guard case .pendingOpenChannel(let l) = lhs, case .pendingOpenChannel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fullyResolvedChannel, .fullyResolvedChannel): return {
        guard case .fullyResolvedChannel(let l) = lhs, case .fullyResolvedChannel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  enum UpdateType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case openChannel // = 0
    case closedChannel // = 1
    case activeChannel // = 2
    case inactiveChannel // = 3
    case pendingOpenChannel // = 4
    case fullyResolvedChannel // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .openChannel
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .openChannel
      case 1: self = .closedChannel
      case 2: self = .activeChannel
      case 3: self = .inactiveChannel
      case 4: self = .pendingOpenChannel
      case 5: self = .fullyResolvedChannel
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .openChannel: return 0
      case .closedChannel: return 1
      case .activeChannel: return 2
      case .inactiveChannel: return 3
      case .pendingOpenChannel: return 4
      case .fullyResolvedChannel: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Lnrpc_ChannelEventUpdate.UpdateType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Lnrpc_ChannelEventUpdate.UpdateType] = [
    .openChannel,
    .closedChannel,
    .activeChannel,
    .inactiveChannel,
    .pendingOpenChannel,
    .fullyResolvedChannel,
  ]
}

#endif  // swift(>=4.2)

struct Lnrpc_WalletAccountBalance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The confirmed balance of the account (with >= 1 confirmations).
  var confirmedBalance: Int64 = 0

  /// The unconfirmed balance of the account (with 0 confirmations).
  var unconfirmedBalance: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_WalletBalanceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_WalletBalanceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The balance of the wallet
  var totalBalance: Int64 = 0

  /// The confirmed balance of a wallet(with >= 1 confirmations)
  var confirmedBalance: Int64 = 0

  /// The unconfirmed balance of a wallet(with 0 confirmations)
  var unconfirmedBalance: Int64 = 0

  /// A mapping of each wallet account's name to its balance.
  var accountBalance: Dictionary<String,Lnrpc_WalletAccountBalance> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_Amount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Value denominated in satoshis.
  var sat: UInt64 = 0

  /// Value denominated in milli-satoshis.
  var msat: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChannelBalanceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChannelBalanceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. Sum of channels balances denominated in satoshis
  var balance: Int64 = 0

  /// Deprecated. Sum of channels pending balances denominated in satoshis
  var pendingOpenBalance: Int64 = 0

  /// Sum of channels local balances.
  var localBalance: Lnrpc_Amount {
    get {return _localBalance ?? Lnrpc_Amount()}
    set {_localBalance = newValue}
  }
  /// Returns true if `localBalance` has been explicitly set.
  var hasLocalBalance: Bool {return self._localBalance != nil}
  /// Clears the value of `localBalance`. Subsequent reads from it will return its default value.
  mutating func clearLocalBalance() {self._localBalance = nil}

  /// Sum of channels remote balances.
  var remoteBalance: Lnrpc_Amount {
    get {return _remoteBalance ?? Lnrpc_Amount()}
    set {_remoteBalance = newValue}
  }
  /// Returns true if `remoteBalance` has been explicitly set.
  var hasRemoteBalance: Bool {return self._remoteBalance != nil}
  /// Clears the value of `remoteBalance`. Subsequent reads from it will return its default value.
  mutating func clearRemoteBalance() {self._remoteBalance = nil}

  /// Sum of channels local unsettled balances.
  var unsettledLocalBalance: Lnrpc_Amount {
    get {return _unsettledLocalBalance ?? Lnrpc_Amount()}
    set {_unsettledLocalBalance = newValue}
  }
  /// Returns true if `unsettledLocalBalance` has been explicitly set.
  var hasUnsettledLocalBalance: Bool {return self._unsettledLocalBalance != nil}
  /// Clears the value of `unsettledLocalBalance`. Subsequent reads from it will return its default value.
  mutating func clearUnsettledLocalBalance() {self._unsettledLocalBalance = nil}

  /// Sum of channels remote unsettled balances.
  var unsettledRemoteBalance: Lnrpc_Amount {
    get {return _unsettledRemoteBalance ?? Lnrpc_Amount()}
    set {_unsettledRemoteBalance = newValue}
  }
  /// Returns true if `unsettledRemoteBalance` has been explicitly set.
  var hasUnsettledRemoteBalance: Bool {return self._unsettledRemoteBalance != nil}
  /// Clears the value of `unsettledRemoteBalance`. Subsequent reads from it will return its default value.
  mutating func clearUnsettledRemoteBalance() {self._unsettledRemoteBalance = nil}

  /// Sum of channels pending local balances.
  var pendingOpenLocalBalance: Lnrpc_Amount {
    get {return _pendingOpenLocalBalance ?? Lnrpc_Amount()}
    set {_pendingOpenLocalBalance = newValue}
  }
  /// Returns true if `pendingOpenLocalBalance` has been explicitly set.
  var hasPendingOpenLocalBalance: Bool {return self._pendingOpenLocalBalance != nil}
  /// Clears the value of `pendingOpenLocalBalance`. Subsequent reads from it will return its default value.
  mutating func clearPendingOpenLocalBalance() {self._pendingOpenLocalBalance = nil}

  /// Sum of channels pending remote balances.
  var pendingOpenRemoteBalance: Lnrpc_Amount {
    get {return _pendingOpenRemoteBalance ?? Lnrpc_Amount()}
    set {_pendingOpenRemoteBalance = newValue}
  }
  /// Returns true if `pendingOpenRemoteBalance` has been explicitly set.
  var hasPendingOpenRemoteBalance: Bool {return self._pendingOpenRemoteBalance != nil}
  /// Clears the value of `pendingOpenRemoteBalance`. Subsequent reads from it will return its default value.
  mutating func clearPendingOpenRemoteBalance() {self._pendingOpenRemoteBalance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _localBalance: Lnrpc_Amount? = nil
  fileprivate var _remoteBalance: Lnrpc_Amount? = nil
  fileprivate var _unsettledLocalBalance: Lnrpc_Amount? = nil
  fileprivate var _unsettledRemoteBalance: Lnrpc_Amount? = nil
  fileprivate var _pendingOpenLocalBalance: Lnrpc_Amount? = nil
  fileprivate var _pendingOpenRemoteBalance: Lnrpc_Amount? = nil
}

struct Lnrpc_QueryRoutesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The 33-byte hex-encoded public key for the payment destination
  var pubKey: String = String()

  ///
  ///The amount to send expressed in satoshis.
  ///
  ///The fields amt and amt_msat are mutually exclusive.
  var amt: Int64 = 0

  ///
  ///The amount to send expressed in millisatoshis.
  ///
  ///The fields amt and amt_msat are mutually exclusive.
  var amtMsat: Int64 = 0

  ///
  ///An optional CLTV delta from the current height that should be used for the
  ///timelock of the final hop. Note that unlike SendPayment, QueryRoutes does
  ///not add any additional block padding on top of final_ctlv_delta. This
  ///padding of a few blocks needs to be added manually or otherwise failures may
  ///happen when a block comes in while the payment is in flight.
  var finalCltvDelta: Int32 = 0

  ///
  ///The maximum number of satoshis that will be paid as a fee of the payment.
  ///This value can be represented either as a percentage of the amount being
  ///sent, or as a fixed amount of the maximum fee the user is willing the pay to
  ///send the payment.
  var feeLimit: Lnrpc_FeeLimit {
    get {return _feeLimit ?? Lnrpc_FeeLimit()}
    set {_feeLimit = newValue}
  }
  /// Returns true if `feeLimit` has been explicitly set.
  var hasFeeLimit: Bool {return self._feeLimit != nil}
  /// Clears the value of `feeLimit`. Subsequent reads from it will return its default value.
  mutating func clearFeeLimit() {self._feeLimit = nil}

  ///
  ///A list of nodes to ignore during path finding. When using REST, these fields
  ///must be encoded as base64.
  var ignoredNodes: [Data] = []

  ///
  ///Deprecated. A list of edges to ignore during path finding.
  var ignoredEdges: [Lnrpc_EdgeLocator] = []

  ///
  ///The source node where the request route should originated from. If empty,
  ///self is assumed.
  var sourcePubKey: String = String()

  ///
  ///If set to true, edge probabilities from mission control will be used to get
  ///the optimal route.
  var useMissionControl: Bool = false

  ///
  ///A list of directed node pairs that will be ignored during path finding.
  var ignoredPairs: [Lnrpc_NodePair] = []

  ///
  ///An optional maximum total time lock for the route. If the source is empty or
  ///ourselves, this should not exceed lnd's `--max-cltv-expiry` setting. If
  ///zero, then the value of `--max-cltv-expiry` is used as the limit.
  var cltvLimit: UInt32 = 0

  ///
  ///An optional field that can be used to pass an arbitrary set of TLV records
  ///to a peer which understands the new records. This can be used to pass
  ///application specific data during the payment attempt. If the destination
  ///does not support the specified records, an error will be returned.
  ///Record types are required to be in the custom range >= 65536. When using
  ///REST, the values must be encoded as base64.
  var destCustomRecords: Dictionary<UInt64,Data> = [:]

  ///
  ///The channel id of the channel that must be taken to the first hop. If zero,
  ///any channel may be used.
  var outgoingChanID: UInt64 = 0

  ///
  ///The pubkey of the last hop of the route. If empty, any hop may be used.
  var lastHopPubkey: Data = Data()

  ///
  ///Optional route hints to reach the destination through private channels.
  var routeHints: [Lnrpc_RouteHint] = []

  ///
  ///Features assumed to be supported by the final node. All transitive feature
  ///dependencies must also be set properly. For a given feature bit pair, either
  ///optional or remote may be set, but not both. If this field is nil or empty,
  ///the router will try to load destination features from the graph as a
  ///fallback.
  var destFeatures: [Lnrpc_FeatureBit] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _feeLimit: Lnrpc_FeeLimit? = nil
}

struct Lnrpc_NodePair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The sending node of the pair. When using REST, this field must be encoded as
  ///base64.
  var from: Data = Data()

  ///
  ///The receiving node of the pair. When using REST, this field must be encoded
  ///as base64.
  var to: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_EdgeLocator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The short channel id of this edge.
  var channelID: UInt64 = 0

  ///
  ///The direction of this edge. If direction_reverse is false, the direction
  ///of this edge is from the channel endpoint with the lexicographically smaller
  ///pub key to the endpoint with the larger pub key. If direction_reverse is
  ///is true, the edge goes the other way.
  var directionReverse: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_QueryRoutesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The route that results from the path finding operation. This is still a
  ///repeated field to retain backwards compatibility.
  var routes: [Lnrpc_Route] = []

  ///
  ///The success probability of the returned route based on the current mission
  ///control state. [EXPERIMENTAL]
  var successProb: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_Hop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The unique channel ID for the channel. The first 3 bytes are the block
  ///height, the next 3 the index within the block, and the last 2 bytes are the
  ///output index for the channel.
  var chanID: UInt64 = 0

  var chanCapacity: Int64 = 0

  var amtToForward: Int64 = 0

  var fee: Int64 = 0

  var expiry: UInt32 = 0

  var amtToForwardMsat: Int64 = 0

  var feeMsat: Int64 = 0

  ///
  ///An optional public key of the hop. If the public key is given, the payment
  ///can be executed without relying on a copy of the channel graph.
  var pubKey: String = String()

  ///
  ///If set to true, then this hop will be encoded using the new variable length
  ///TLV format. Note that if any custom tlv_records below are specified, then
  ///this field MUST be set to true for them to be encoded properly.
  var tlvPayload: Bool = false

  ///
  ///An optional TLV record that signals the use of an MPP payment. If present,
  ///the receiver will enforce that the same mpp_record is included in the final
  ///hop payload of all non-zero payments in the HTLC set. If empty, a regular
  ///single-shot payment is or was attempted.
  var mppRecord: Lnrpc_MPPRecord {
    get {return _mppRecord ?? Lnrpc_MPPRecord()}
    set {_mppRecord = newValue}
  }
  /// Returns true if `mppRecord` has been explicitly set.
  var hasMppRecord: Bool {return self._mppRecord != nil}
  /// Clears the value of `mppRecord`. Subsequent reads from it will return its default value.
  mutating func clearMppRecord() {self._mppRecord = nil}

  ///
  ///An optional TLV record that signals the use of an AMP payment. If present,
  ///the receiver will treat all received payments including the same
  ///(payment_addr, set_id) pair  as being part of one logical payment. The
  ///payment will be settled by XORing the root_share's together and deriving the
  ///child hashes and preimages according to BOLT XX. Must be used in conjunction
  ///with mpp_record.
  var ampRecord: Lnrpc_AMPRecord {
    get {return _ampRecord ?? Lnrpc_AMPRecord()}
    set {_ampRecord = newValue}
  }
  /// Returns true if `ampRecord` has been explicitly set.
  var hasAmpRecord: Bool {return self._ampRecord != nil}
  /// Clears the value of `ampRecord`. Subsequent reads from it will return its default value.
  mutating func clearAmpRecord() {self._ampRecord = nil}

  ///
  ///An optional set of key-value TLV records. This is useful within the context
  ///of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
  ///to drop off at each hop within the onion.
  var customRecords: Dictionary<UInt64,Data> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mppRecord: Lnrpc_MPPRecord? = nil
  fileprivate var _ampRecord: Lnrpc_AMPRecord? = nil
}

struct Lnrpc_MPPRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///A unique, random identifier used to authenticate the sender as the intended
  ///payer of a multi-path payment. The payment_addr must be the same for all
  ///subpayments, and match the payment_addr provided in the receiver's invoice.
  ///The same payment_addr must be used on all subpayments.
  var paymentAddr: Data = Data()

  ///
  ///The total amount in milli-satoshis being sent as part of a larger multi-path
  ///payment. The caller is responsible for ensuring subpayments to the same node
  ///and payment_hash sum exactly to total_amt_msat. The same
  ///total_amt_msat must be used on all subpayments.
  var totalAmtMsat: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_AMPRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rootShare: Data = Data()

  var setID: Data = Data()

  var childIndex: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
///A path through the channel graph which runs over one or more channels in
///succession. This struct carries all the information required to craft the
///Sphinx onion packet, and send the payment along the first hop in the path. A
///route is only selected as valid if all the channels have sufficient capacity to
///carry the initial payment amount after fees are accounted for.
struct Lnrpc_Route {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The cumulative (final) time lock across the entire route. This is the CLTV
  ///value that should be extended to the first hop in the route. All other hops
  ///will decrement the time-lock as advertised, leaving enough time for all
  ///hops to wait for or present the payment preimage to complete the payment.
  var totalTimeLock: UInt32 = 0

  ///
  ///The sum of the fees paid at each hop within the final route. In the case
  ///of a one-hop payment, this value will be zero as we don't need to pay a fee
  ///to ourselves.
  var totalFees: Int64 = 0

  ///
  ///The total amount of funds required to complete a payment over this route.
  ///This value includes the cumulative fees at each hop. As a result, the HTLC
  ///extended to the first-hop in the route will need to have at least this many
  ///satoshis, otherwise the route will fail at an intermediate node due to an
  ///insufficient amount of fees.
  var totalAmt: Int64 = 0

  ///
  ///Contains details concerning the specific forwarding details at each hop.
  var hops: [Lnrpc_Hop] = []

  ///
  ///The total fees in millisatoshis.
  var totalFeesMsat: Int64 = 0

  ///
  ///The total amount in millisatoshis.
  var totalAmtMsat: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_NodeInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The 33-byte hex-encoded compressed public of the target node
  var pubKey: String = String()

  /// If true, will include all known channels associated with the node.
  var includeChannels: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_NodeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///An individual vertex/node within the channel graph. A node is
  ///connected to other nodes by one or more channel edges emanating from it. As
  ///the graph is directed, a node will also have an incoming edge attached to
  ///it for each outgoing edge.
  var node: Lnrpc_LightningNode {
    get {return _node ?? Lnrpc_LightningNode()}
    set {_node = newValue}
  }
  /// Returns true if `node` has been explicitly set.
  var hasNode: Bool {return self._node != nil}
  /// Clears the value of `node`. Subsequent reads from it will return its default value.
  mutating func clearNode() {self._node = nil}

  /// The total number of channels for the node.
  var numChannels: UInt32 = 0

  /// The sum of all channels capacity for the node, denominated in satoshis.
  var totalCapacity: Int64 = 0

  /// A list of all public channels for the node.
  var channels: [Lnrpc_ChannelEdge] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _node: Lnrpc_LightningNode? = nil
}

///
///An individual vertex/node within the channel graph. A node is
///connected to other nodes by one or more channel edges emanating from it. As the
///graph is directed, a node will also have an incoming edge attached to it for
///each outgoing edge.
struct Lnrpc_LightningNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lastUpdate: UInt32 = 0

  var pubKey: String = String()

  var alias: String = String()

  var addresses: [Lnrpc_NodeAddress] = []

  var color: String = String()

  var features: Dictionary<UInt32,Lnrpc_Feature> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_NodeAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var network: String = String()

  var addr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_RoutingPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timeLockDelta: UInt32 = 0

  var minHtlc: Int64 = 0

  var feeBaseMsat: Int64 = 0

  var feeRateMilliMsat: Int64 = 0

  var disabled: Bool = false

  var maxHtlcMsat: UInt64 = 0

  var lastUpdate: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
///A fully authenticated channel along with all its unique attributes.
///Once an authenticated channel announcement has been processed on the network,
///then an instance of ChannelEdgeInfo encapsulating the channels attributes is
///stored. The other portions relevant to routing policy of a channel are stored
///within a ChannelEdgePolicy for each direction of the channel.
struct Lnrpc_ChannelEdge {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The unique channel ID for the channel. The first 3 bytes are the block
  ///height, the next 3 the index within the block, and the last 2 bytes are the
  ///output index for the channel.
  var channelID: UInt64 {
    get {return _storage._channelID}
    set {_uniqueStorage()._channelID = newValue}
  }

  var chanPoint: String {
    get {return _storage._chanPoint}
    set {_uniqueStorage()._chanPoint = newValue}
  }

  var lastUpdate: UInt32 {
    get {return _storage._lastUpdate}
    set {_uniqueStorage()._lastUpdate = newValue}
  }

  var node1Pub: String {
    get {return _storage._node1Pub}
    set {_uniqueStorage()._node1Pub = newValue}
  }

  var node2Pub: String {
    get {return _storage._node2Pub}
    set {_uniqueStorage()._node2Pub = newValue}
  }

  var capacity: Int64 {
    get {return _storage._capacity}
    set {_uniqueStorage()._capacity = newValue}
  }

  var node1Policy: Lnrpc_RoutingPolicy {
    get {return _storage._node1Policy ?? Lnrpc_RoutingPolicy()}
    set {_uniqueStorage()._node1Policy = newValue}
  }
  /// Returns true if `node1Policy` has been explicitly set.
  var hasNode1Policy: Bool {return _storage._node1Policy != nil}
  /// Clears the value of `node1Policy`. Subsequent reads from it will return its default value.
  mutating func clearNode1Policy() {_uniqueStorage()._node1Policy = nil}

  var node2Policy: Lnrpc_RoutingPolicy {
    get {return _storage._node2Policy ?? Lnrpc_RoutingPolicy()}
    set {_uniqueStorage()._node2Policy = newValue}
  }
  /// Returns true if `node2Policy` has been explicitly set.
  var hasNode2Policy: Bool {return _storage._node2Policy != nil}
  /// Clears the value of `node2Policy`. Subsequent reads from it will return its default value.
  mutating func clearNode2Policy() {_uniqueStorage()._node2Policy = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_ChannelGraphRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///Whether unannounced channels are included in the response or not. If set,
  ///unannounced channels are included. Unannounced channels are both private
  ///channels, and public channels that are not yet announced to the network.
  var includeUnannounced: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Returns a new instance of the directed channel graph.
struct Lnrpc_ChannelGraph {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of `LightningNode`s in this channel graph
  var nodes: [Lnrpc_LightningNode] = []

  /// The list of `ChannelEdge`s in this channel graph
  var edges: [Lnrpc_ChannelEdge] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_NodeMetricsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested node metrics.
  var types: [Lnrpc_NodeMetricType] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_NodeMetricsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///Betweenness centrality is the sum of the ratio of shortest paths that pass
  ///through the node for each pair of nodes in the graph (not counting paths
  ///starting or ending at this node).
  ///Map of node pubkey to betweenness centrality of the node. Normalized
  ///values are in the [0,1] closed interval.
  var betweennessCentrality: Dictionary<String,Lnrpc_FloatMetric> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_FloatMetric {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Arbitrary float value.
  var value: Double = 0

  /// The value normalized to [0,1] or [-1,1].
  var normalizedValue: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChanInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The unique channel ID for the channel. The first 3 bytes are the block
  ///height, the next 3 the index within the block, and the last 2 bytes are the
  ///output index for the channel.
  var chanID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_NetworkInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_NetworkInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var graphDiameter: UInt32 = 0

  var avgOutDegree: Double = 0

  var maxOutDegree: UInt32 = 0

  var numNodes: UInt32 = 0

  var numChannels: UInt32 = 0

  var totalNetworkCapacity: Int64 = 0

  var avgChannelSize: Double = 0

  var minChannelSize: Int64 = 0

  var maxChannelSize: Int64 = 0

  var medianChannelSizeSat: Int64 = 0

  /// The number of edges marked as zombies.
  var numZombieChans: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_StopRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_StopResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_GraphTopologySubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_GraphTopologyUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodeUpdates: [Lnrpc_NodeUpdate] = []

  var channelUpdates: [Lnrpc_ChannelEdgeUpdate] = []

  var closedChans: [Lnrpc_ClosedChannelUpdate] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_NodeUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///Deprecated, use node_addresses.
  var addresses: [String] = []

  var identityKey: String = String()

  ///
  ///Deprecated, use features.
  var globalFeatures: Data = Data()

  var alias: String = String()

  var color: String = String()

  var nodeAddresses: [Lnrpc_NodeAddress] = []

  ///
  ///Features that the node has advertised in the init message, node
  ///announcements and invoices.
  var features: Dictionary<UInt32,Lnrpc_Feature> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChannelEdgeUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The unique channel ID for the channel. The first 3 bytes are the block
  ///height, the next 3 the index within the block, and the last 2 bytes are the
  ///output index for the channel.
  var chanID: UInt64 = 0

  var chanPoint: Lnrpc_ChannelPoint {
    get {return _chanPoint ?? Lnrpc_ChannelPoint()}
    set {_chanPoint = newValue}
  }
  /// Returns true if `chanPoint` has been explicitly set.
  var hasChanPoint: Bool {return self._chanPoint != nil}
  /// Clears the value of `chanPoint`. Subsequent reads from it will return its default value.
  mutating func clearChanPoint() {self._chanPoint = nil}

  var capacity: Int64 = 0

  var routingPolicy: Lnrpc_RoutingPolicy {
    get {return _routingPolicy ?? Lnrpc_RoutingPolicy()}
    set {_routingPolicy = newValue}
  }
  /// Returns true if `routingPolicy` has been explicitly set.
  var hasRoutingPolicy: Bool {return self._routingPolicy != nil}
  /// Clears the value of `routingPolicy`. Subsequent reads from it will return its default value.
  mutating func clearRoutingPolicy() {self._routingPolicy = nil}

  var advertisingNode: String = String()

  var connectingNode: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _chanPoint: Lnrpc_ChannelPoint? = nil
  fileprivate var _routingPolicy: Lnrpc_RoutingPolicy? = nil
}

struct Lnrpc_ClosedChannelUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The unique channel ID for the channel. The first 3 bytes are the block
  ///height, the next 3 the index within the block, and the last 2 bytes are the
  ///output index for the channel.
  var chanID: UInt64 = 0

  var capacity: Int64 = 0

  var closedHeight: UInt32 = 0

  var chanPoint: Lnrpc_ChannelPoint {
    get {return _chanPoint ?? Lnrpc_ChannelPoint()}
    set {_chanPoint = newValue}
  }
  /// Returns true if `chanPoint` has been explicitly set.
  var hasChanPoint: Bool {return self._chanPoint != nil}
  /// Clears the value of `chanPoint`. Subsequent reads from it will return its default value.
  mutating func clearChanPoint() {self._chanPoint = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _chanPoint: Lnrpc_ChannelPoint? = nil
}

struct Lnrpc_HopHint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key of the node at the start of the channel.
  var nodeID: String = String()

  /// The unique identifier of the channel.
  var chanID: UInt64 = 0

  /// The base fee of the channel denominated in millisatoshis.
  var feeBaseMsat: UInt32 = 0

  ///
  ///The fee rate of the channel for sending one satoshi across it denominated in
  ///millionths of a satoshi.
  var feeProportionalMillionths: UInt32 = 0

  /// The time-lock delta of the channel.
  var cltvExpiryDelta: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_SetID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var setID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_RouteHint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///A list of hop hints that when chained together can assist in reaching a
  ///specific destination.
  var hopHints: [Lnrpc_HopHint] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_AMPInvoiceState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The state the HTLCs associated with this setID are in.
  var state: Lnrpc_InvoiceHTLCState = .accepted

  /// The settle index of this HTLC set, if the invoice state is settled.
  var settleIndex: UInt64 = 0

  /// The time this HTLC set was settled expressed in unix epoch.
  var settleTime: Int64 = 0

  /// The total amount paid for the sub-invoice expressed in milli satoshis.
  var amtPaidMsat: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_Invoice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///An optional memo to attach along with the invoice. Used for record keeping
  ///purposes for the invoice's creator, and will also be set in the description
  ///field of the encoded payment request if the description_hash field is not
  ///being used.
  var memo: String {
    get {return _storage._memo}
    set {_uniqueStorage()._memo = newValue}
  }

  ///
  ///The hex-encoded preimage (32 byte) which will allow settling an incoming
  ///HTLC payable to this preimage. When using REST, this field must be encoded
  ///as base64.
  var rPreimage: Data {
    get {return _storage._rPreimage}
    set {_uniqueStorage()._rPreimage = newValue}
  }

  ///
  ///The hash of the preimage. When using REST, this field must be encoded as
  ///base64.
  var rHash: Data {
    get {return _storage._rHash}
    set {_uniqueStorage()._rHash = newValue}
  }

  ///
  ///The value of this invoice in satoshis
  ///
  ///The fields value and value_msat are mutually exclusive.
  var value: Int64 {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  ///
  ///The value of this invoice in millisatoshis
  ///
  ///The fields value and value_msat are mutually exclusive.
  var valueMsat: Int64 {
    get {return _storage._valueMsat}
    set {_uniqueStorage()._valueMsat = newValue}
  }

  /// Whether this invoice has been fulfilled
  var settled: Bool {
    get {return _storage._settled}
    set {_uniqueStorage()._settled = newValue}
  }

  /// When this invoice was created
  var creationDate: Int64 {
    get {return _storage._creationDate}
    set {_uniqueStorage()._creationDate = newValue}
  }

  /// When this invoice was settled
  var settleDate: Int64 {
    get {return _storage._settleDate}
    set {_uniqueStorage()._settleDate = newValue}
  }

  ///
  ///A bare-bones invoice for a payment within the Lightning Network. With the
  ///details of the invoice, the sender has all the data necessary to send a
  ///payment to the recipient.
  var paymentRequest: String {
    get {return _storage._paymentRequest}
    set {_uniqueStorage()._paymentRequest = newValue}
  }

  ///
  ///Hash (SHA-256) of a description of the payment. Used if the description of
  ///payment (memo) is too long to naturally fit within the description field
  ///of an encoded payment request. When using REST, this field must be encoded
  ///as base64.
  var descriptionHash: Data {
    get {return _storage._descriptionHash}
    set {_uniqueStorage()._descriptionHash = newValue}
  }

  /// Payment request expiry time in seconds. Default is 3600 (1 hour).
  var expiry: Int64 {
    get {return _storage._expiry}
    set {_uniqueStorage()._expiry = newValue}
  }

  /// Fallback on-chain address.
  var fallbackAddr: String {
    get {return _storage._fallbackAddr}
    set {_uniqueStorage()._fallbackAddr = newValue}
  }

  /// Delta to use for the time-lock of the CLTV extended to the final hop.
  var cltvExpiry: UInt64 {
    get {return _storage._cltvExpiry}
    set {_uniqueStorage()._cltvExpiry = newValue}
  }

  ///
  ///Route hints that can each be individually used to assist in reaching the
  ///invoice's destination.
  var routeHints: [Lnrpc_RouteHint] {
    get {return _storage._routeHints}
    set {_uniqueStorage()._routeHints = newValue}
  }

  /// Whether this invoice should include routing hints for private channels.
  var `private`: Bool {
    get {return _storage._private}
    set {_uniqueStorage()._private = newValue}
  }

  ///
  ///The "add" index of this invoice. Each newly created invoice will increment
  ///this index making it monotonically increasing. Callers to the
  ///SubscribeInvoices call can use this to instantly get notified of all added
  ///invoices with an add_index greater than this one.
  var addIndex: UInt64 {
    get {return _storage._addIndex}
    set {_uniqueStorage()._addIndex = newValue}
  }

  ///
  ///The "settle" index of this invoice. Each newly settled invoice will
  ///increment this index making it monotonically increasing. Callers to the
  ///SubscribeInvoices call can use this to instantly get notified of all
  ///settled invoices with an settle_index greater than this one.
  var settleIndex: UInt64 {
    get {return _storage._settleIndex}
    set {_uniqueStorage()._settleIndex = newValue}
  }

  /// Deprecated, use amt_paid_sat or amt_paid_msat.
  var amtPaid: Int64 {
    get {return _storage._amtPaid}
    set {_uniqueStorage()._amtPaid = newValue}
  }

  ///
  ///The amount that was accepted for this invoice, in satoshis. This will ONLY
  ///be set if this invoice has been settled. We provide this field as if the
  ///invoice was created with a zero value, then we need to record what amount
  ///was ultimately accepted. Additionally, it's possible that the sender paid
  ///MORE that was specified in the original invoice. So we'll record that here
  ///as well.
  var amtPaidSat: Int64 {
    get {return _storage._amtPaidSat}
    set {_uniqueStorage()._amtPaidSat = newValue}
  }

  ///
  ///The amount that was accepted for this invoice, in millisatoshis. This will
  ///ONLY be set if this invoice has been settled. We provide this field as if
  ///the invoice was created with a zero value, then we need to record what
  ///amount was ultimately accepted. Additionally, it's possible that the sender
  ///paid MORE that was specified in the original invoice. So we'll record that
  ///here as well.
  var amtPaidMsat: Int64 {
    get {return _storage._amtPaidMsat}
    set {_uniqueStorage()._amtPaidMsat = newValue}
  }

  ///
  ///The state the invoice is in.
  var state: Lnrpc_Invoice.InvoiceState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// List of HTLCs paying to this invoice [EXPERIMENTAL].
  var htlcs: [Lnrpc_InvoiceHTLC] {
    get {return _storage._htlcs}
    set {_uniqueStorage()._htlcs = newValue}
  }

  /// List of features advertised on the invoice.
  var features: Dictionary<UInt32,Lnrpc_Feature> {
    get {return _storage._features}
    set {_uniqueStorage()._features = newValue}
  }

  ///
  ///Indicates if this invoice was a spontaneous payment that arrived via keysend
  ///[EXPERIMENTAL].
  var isKeysend: Bool {
    get {return _storage._isKeysend}
    set {_uniqueStorage()._isKeysend = newValue}
  }

  ///
  ///The payment address of this invoice. This value will be used in MPP
  ///payments, and also for newer invoices that always require the MPP payload
  ///for added end-to-end security.
  var paymentAddr: Data {
    get {return _storage._paymentAddr}
    set {_uniqueStorage()._paymentAddr = newValue}
  }

  ///
  ///Signals whether or not this is an AMP invoice.
  var isAmp: Bool {
    get {return _storage._isAmp}
    set {_uniqueStorage()._isAmp = newValue}
  }

  ///
  ///[EXPERIMENTAL]:
  ///
  ///Maps a 32-byte hex-encoded set ID to the sub-invoice AMP state for the
  ///given set ID. This field is always populated for AMP invoices, and can be
  ///used along side LookupInvoice to obtain the HTLC information related to a
  ///given sub-invoice.
  var ampInvoiceState: Dictionary<String,Lnrpc_AMPInvoiceState> {
    get {return _storage._ampInvoiceState}
    set {_uniqueStorage()._ampInvoiceState = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum InvoiceState: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case `open` // = 0
    case settled // = 1
    case canceled // = 2
    case accepted // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .open
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .open
      case 1: self = .settled
      case 2: self = .canceled
      case 3: self = .accepted
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .open: return 0
      case .settled: return 1
      case .canceled: return 2
      case .accepted: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Lnrpc_Invoice.InvoiceState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Lnrpc_Invoice.InvoiceState] = [
    .open,
    .settled,
    .canceled,
    .accepted,
  ]
}

#endif  // swift(>=4.2)

/// Details of an HTLC that paid to an invoice
struct Lnrpc_InvoiceHTLC {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Short channel id over which the htlc was received.
  var chanID: UInt64 = 0

  /// Index identifying the htlc on the channel.
  var htlcIndex: UInt64 = 0

  /// The amount of the htlc in msat.
  var amtMsat: UInt64 = 0

  /// Block height at which this htlc was accepted.
  var acceptHeight: Int32 = 0

  /// Time at which this htlc was accepted.
  var acceptTime: Int64 = 0

  /// Time at which this htlc was settled or canceled.
  var resolveTime: Int64 = 0

  /// Block height at which this htlc expires.
  var expiryHeight: Int32 = 0

  /// Current state the htlc is in.
  var state: Lnrpc_InvoiceHTLCState = .accepted

  /// Custom tlv records.
  var customRecords: Dictionary<UInt64,Data> = [:]

  /// The total amount of the mpp payment in msat.
  var mppTotalAmtMsat: UInt64 = 0

  /// Details relevant to AMP HTLCs, only populated if this is an AMP HTLC.
  var amp: Lnrpc_AMP {
    get {return _amp ?? Lnrpc_AMP()}
    set {_amp = newValue}
  }
  /// Returns true if `amp` has been explicitly set.
  var hasAmp: Bool {return self._amp != nil}
  /// Clears the value of `amp`. Subsequent reads from it will return its default value.
  mutating func clearAmp() {self._amp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amp: Lnrpc_AMP? = nil
}

/// Details specific to AMP HTLCs.
struct Lnrpc_AMP {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An n-of-n secret share of the root seed from which child payment hashes
  /// and preimages are derived.
  var rootShare: Data = Data()

  /// An identifier for the HTLC set that this HTLC belongs to.
  var setID: Data = Data()

  /// A nonce used to randomize the child preimage and child hash from a given
  /// root_share.
  var childIndex: UInt32 = 0

  /// The payment hash of the AMP HTLC.
  var hash: Data = Data()

  /// The preimage used to settle this AMP htlc. This field will only be
  /// populated if the invoice is in InvoiceState_ACCEPTED or
  /// InvoiceState_SETTLED.
  var preimage: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_AddInvoiceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rHash: Data = Data()

  ///
  ///A bare-bones invoice for a payment within the Lightning Network. With the
  ///details of the invoice, the sender has all the data necessary to send a
  ///payment to the recipient.
  var paymentRequest: String = String()

  ///
  ///The "add" index of this invoice. Each newly created invoice will increment
  ///this index making it monotonically increasing. Callers to the
  ///SubscribeInvoices call can use this to instantly get notified of all added
  ///invoices with an add_index greater than this one.
  var addIndex: UInt64 = 0

  ///
  ///The payment address of the generated invoice. This value should be used
  ///in all payments for this invoice as we require it for end to end
  ///security.
  var paymentAddr: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_PaymentHash {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The hex-encoded payment hash of the invoice to be looked up. The passed
  ///payment hash must be exactly 32 bytes, otherwise an error is returned.
  ///Deprecated now that the REST gateway supports base64 encoding of bytes
  ///fields.
  var rHashStr: String = String()

  ///
  ///The payment hash of the invoice to be looked up. When using REST, this field
  ///must be encoded as base64.
  var rHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListInvoiceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///If set, only invoices that are not settled and not canceled will be returned
  ///in the response.
  var pendingOnly: Bool = false

  ///
  ///The index of an invoice that will be used as either the start or end of a
  ///query to determine which invoices should be returned in the response.
  var indexOffset: UInt64 = 0

  /// The max number of invoices to return in the response to this query.
  var numMaxInvoices: UInt64 = 0

  ///
  ///If set, the invoices returned will result from seeking backwards from the
  ///specified index offset. This can be used to paginate backwards.
  var reversed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListInvoiceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///A list of invoices from the time slice of the time series specified in the
  ///request.
  var invoices: [Lnrpc_Invoice] = []

  ///
  ///The index of the last item in the set of returned invoices. This can be used
  ///to seek further, pagination style.
  var lastIndexOffset: UInt64 = 0

  ///
  ///The index of the last item in the set of returned invoices. This can be used
  ///to seek backwards, pagination style.
  var firstIndexOffset: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_InvoiceSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///If specified (non-zero), then we'll first start by sending out
  ///notifications for all added indexes with an add_index greater than this
  ///value. This allows callers to catch up on any events they missed while they
  ///weren't connected to the streaming RPC.
  var addIndex: UInt64 = 0

  ///
  ///If specified (non-zero), then we'll first start by sending out
  ///notifications for all settled indexes with an settle_index greater than
  ///this value. This allows callers to catch up on any events they missed while
  ///they weren't connected to the streaming RPC.
  var settleIndex: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_Payment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The payment hash
  var paymentHash: String = String()

  /// Deprecated, use value_sat or value_msat.
  var value: Int64 = 0

  /// Deprecated, use creation_time_ns
  var creationDate: Int64 = 0

  /// Deprecated, use fee_sat or fee_msat.
  var fee: Int64 = 0

  /// The payment preimage
  var paymentPreimage: String = String()

  /// The value of the payment in satoshis
  var valueSat: Int64 = 0

  /// The value of the payment in milli-satoshis
  var valueMsat: Int64 = 0

  /// The optional payment request being fulfilled.
  var paymentRequest: String = String()

  /// The status of the payment.
  var status: Lnrpc_Payment.PaymentStatus = .unknown

  ///  The fee paid for this payment in satoshis
  var feeSat: Int64 = 0

  ///  The fee paid for this payment in milli-satoshis
  var feeMsat: Int64 = 0

  /// The time in UNIX nanoseconds at which the payment was created.
  var creationTimeNs: Int64 = 0

  /// The HTLCs made in attempt to settle the payment.
  var htlcs: [Lnrpc_HTLCAttempt] = []

  ///
  ///The creation index of this payment. Each payment can be uniquely identified
  ///by this index, which may not strictly increment by 1 for payments made in
  ///older versions of lnd.
  var paymentIndex: UInt64 = 0

  var failureReason: Lnrpc_PaymentFailureReason = .failureReasonNone

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PaymentStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case inFlight // = 1
    case succeeded // = 2
    case failed // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .inFlight
      case 2: self = .succeeded
      case 3: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .inFlight: return 1
      case .succeeded: return 2
      case .failed: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Lnrpc_Payment.PaymentStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Lnrpc_Payment.PaymentStatus] = [
    .unknown,
    .inFlight,
    .succeeded,
    .failed,
  ]
}

#endif  // swift(>=4.2)

struct Lnrpc_HTLCAttempt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique ID that is used for this attempt.
  var attemptID: UInt64 = 0

  /// The status of the HTLC.
  var status: Lnrpc_HTLCAttempt.HTLCStatus = .inFlight

  /// The route taken by this HTLC.
  var route: Lnrpc_Route {
    get {return _route ?? Lnrpc_Route()}
    set {_route = newValue}
  }
  /// Returns true if `route` has been explicitly set.
  var hasRoute: Bool {return self._route != nil}
  /// Clears the value of `route`. Subsequent reads from it will return its default value.
  mutating func clearRoute() {self._route = nil}

  /// The time in UNIX nanoseconds at which this HTLC was sent.
  var attemptTimeNs: Int64 = 0

  ///
  ///The time in UNIX nanoseconds at which this HTLC was settled or failed.
  ///This value will not be set if the HTLC is still IN_FLIGHT.
  var resolveTimeNs: Int64 = 0

  /// Detailed htlc failure info.
  var failure: Lnrpc_Failure {
    get {return _failure ?? Lnrpc_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  mutating func clearFailure() {self._failure = nil}

  /// The preimage that was used to settle the HTLC.
  var preimage: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum HTLCStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case inFlight // = 0
    case succeeded // = 1
    case failed // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .inFlight
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .inFlight
      case 1: self = .succeeded
      case 2: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .inFlight: return 0
      case .succeeded: return 1
      case .failed: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _route: Lnrpc_Route? = nil
  fileprivate var _failure: Lnrpc_Failure? = nil
}

#if swift(>=4.2)

extension Lnrpc_HTLCAttempt.HTLCStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Lnrpc_HTLCAttempt.HTLCStatus] = [
    .inFlight,
    .succeeded,
    .failed,
  ]
}

#endif  // swift(>=4.2)

struct Lnrpc_ListPaymentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///If true, then return payments that have not yet fully completed. This means
  ///that pending payments, as well as failed payments will show up if this
  ///field is set to true. This flag doesn't change the meaning of the indices,
  ///which are tied to individual payments.
  var includeIncomplete: Bool = false

  ///
  ///The index of a payment that will be used as either the start or end of a
  ///query to determine which payments should be returned in the response. The
  ///index_offset is exclusive. In the case of a zero index_offset, the query
  ///will start with the oldest payment when paginating forwards, or will end
  ///with the most recent payment when paginating backwards.
  var indexOffset: UInt64 = 0

  /// The maximal number of payments returned in the response to this query.
  var maxPayments: UInt64 = 0

  ///
  ///If set, the payments returned will result from seeking backwards from the
  ///specified index offset. This can be used to paginate backwards. The order
  ///of the returned payments is always oldest first (ascending index order).
  var reversed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListPaymentsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of payments
  var payments: [Lnrpc_Payment] = []

  ///
  ///The index of the first item in the set of returned payments. This can be
  ///used as the index_offset to continue seeking backwards in the next request.
  var firstIndexOffset: UInt64 = 0

  ///
  ///The index of the last item in the set of returned payments. This can be used
  ///as the index_offset to continue seeking forwards in the next request.
  var lastIndexOffset: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_DeletePaymentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Payment hash to delete.
  var paymentHash: Data = Data()

  ///
  ///Only delete failed HTLCs from the payment, not the payment itself.
  var failedHtlcsOnly: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_DeleteAllPaymentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Only delete failed payments.
  var failedPaymentsOnly: Bool = false

  ///
  ///Only delete failed HTLCs from payments, not the payment itself.
  var failedHtlcsOnly: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_DeletePaymentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_DeleteAllPaymentsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_AbandonChannelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channelPoint: Lnrpc_ChannelPoint {
    get {return _channelPoint ?? Lnrpc_ChannelPoint()}
    set {_channelPoint = newValue}
  }
  /// Returns true if `channelPoint` has been explicitly set.
  var hasChannelPoint: Bool {return self._channelPoint != nil}
  /// Clears the value of `channelPoint`. Subsequent reads from it will return its default value.
  mutating func clearChannelPoint() {self._channelPoint = nil}

  var pendingFundingShimOnly: Bool = false

  ///
  ///Override the requirement for being in dev mode by setting this to true and
  ///confirming the user knows what they are doing and this is a potential foot
  ///gun to lose funds if used on active channels.
  var iKnowWhatIAmDoing: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _channelPoint: Lnrpc_ChannelPoint? = nil
}

struct Lnrpc_AbandonChannelResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_DebugLevelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var show: Bool = false

  var levelSpec: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_DebugLevelResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subSystems: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_PayReqString {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The payment request string to be decoded
  var payReq: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_PayReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var destination: String = String()

  var paymentHash: String = String()

  var numSatoshis: Int64 = 0

  var timestamp: Int64 = 0

  var expiry: Int64 = 0

  var description_p: String = String()

  var descriptionHash: String = String()

  var fallbackAddr: String = String()

  var cltvExpiry: Int64 = 0

  var routeHints: [Lnrpc_RouteHint] = []

  var paymentAddr: Data = Data()

  var numMsat: Int64 = 0

  var features: Dictionary<UInt32,Lnrpc_Feature> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_Feature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var isRequired: Bool = false

  var isKnown: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_FeeReportRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChannelFeeReport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The short channel id that this fee report belongs to.
  var chanID: UInt64 = 0

  /// The channel that this fee report belongs to.
  var channelPoint: String = String()

  /// The base fee charged regardless of the number of milli-satoshis sent.
  var baseFeeMsat: Int64 = 0

  /// The amount charged per milli-satoshis transferred expressed in
  /// millionths of a satoshi.
  var feePerMil: Int64 = 0

  /// The effective fee rate in milli-satoshis. Computed by dividing the
  /// fee_per_mil value by 1 million.
  var feeRate: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_FeeReportResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An array of channel fee reports which describes the current fee schedule
  /// for each channel.
  var channelFees: [Lnrpc_ChannelFeeReport] = []

  /// The total amount of fee revenue (in satoshis) the switch has collected
  /// over the past 24 hrs.
  var dayFeeSum: UInt64 = 0

  /// The total amount of fee revenue (in satoshis) the switch has collected
  /// over the past 1 week.
  var weekFeeSum: UInt64 = 0

  /// The total amount of fee revenue (in satoshis) the switch has collected
  /// over the past 1 month.
  var monthFeeSum: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_PolicyUpdateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var scope: Lnrpc_PolicyUpdateRequest.OneOf_Scope? = nil

  /// If set, then this update applies to all currently active channels.
  var global: Bool {
    get {
      if case .global(let v)? = scope {return v}
      return false
    }
    set {scope = .global(newValue)}
  }

  /// If set, this update will target a specific channel.
  var chanPoint: Lnrpc_ChannelPoint {
    get {
      if case .chanPoint(let v)? = scope {return v}
      return Lnrpc_ChannelPoint()
    }
    set {scope = .chanPoint(newValue)}
  }

  /// The base fee charged regardless of the number of milli-satoshis sent.
  var baseFeeMsat: Int64 = 0

  /// The effective fee rate in milli-satoshis. The precision of this value
  /// goes up to 6 decimal places, so 1e-6.
  var feeRate: Double = 0

  /// The required timelock delta for HTLCs forwarded over the channel.
  var timeLockDelta: UInt32 = 0

  /// If set, the maximum HTLC size in milli-satoshis. If unset, the maximum
  /// HTLC will be unchanged.
  var maxHtlcMsat: UInt64 = 0

  /// The minimum HTLC size in milli-satoshis. Only applied if
  /// min_htlc_msat_specified is true.
  var minHtlcMsat: UInt64 = 0

  /// If true, min_htlc_msat is applied.
  var minHtlcMsatSpecified: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Scope: Equatable {
    /// If set, then this update applies to all currently active channels.
    case global(Bool)
    /// If set, this update will target a specific channel.
    case chanPoint(Lnrpc_ChannelPoint)

  #if !swift(>=4.1)
    static func ==(lhs: Lnrpc_PolicyUpdateRequest.OneOf_Scope, rhs: Lnrpc_PolicyUpdateRequest.OneOf_Scope) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.global, .global): return {
        guard case .global(let l) = lhs, case .global(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chanPoint, .chanPoint): return {
        guard case .chanPoint(let l) = lhs, case .chanPoint(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Lnrpc_FailedUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The outpoint in format txid:n
  var outpoint: Lnrpc_OutPoint {
    get {return _outpoint ?? Lnrpc_OutPoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  /// Reason for the policy update failure.
  var reason: Lnrpc_UpdateFailure = .unknown

  /// A string representation of the policy update error.
  var updateError: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outpoint: Lnrpc_OutPoint? = nil
}

struct Lnrpc_PolicyUpdateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of failed policy updates.
  var failedUpdates: [Lnrpc_FailedUpdate] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ForwardingHistoryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Start time is the starting point of the forwarding history request. All
  /// records beyond this point will be included, respecting the end time, and
  /// the index offset.
  var startTime: UInt64 = 0

  /// End time is the end point of the forwarding history request. The
  /// response will carry at most 50k records between the start time and the
  /// end time. The index offset can be used to implement pagination.
  var endTime: UInt64 = 0

  /// Index offset is the offset in the time series to start at. As each
  /// response can only contain 50k records, callers can use this to skip
  /// around within a packed time series.
  var indexOffset: UInt32 = 0

  /// The max number of events to return in the response to this query.
  var numMaxEvents: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ForwardingEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Timestamp is the time (unix epoch offset) that this circuit was
  /// completed. Deprecated by timestamp_ns.
  var timestamp: UInt64 = 0

  /// The incoming channel ID that carried the HTLC that created the circuit.
  var chanIDIn: UInt64 = 0

  /// The outgoing channel ID that carried the preimage that completed the
  /// circuit.
  var chanIDOut: UInt64 = 0

  /// The total amount (in satoshis) of the incoming HTLC that created half
  /// the circuit.
  var amtIn: UInt64 = 0

  /// The total amount (in satoshis) of the outgoing HTLC that created the
  /// second half of the circuit.
  var amtOut: UInt64 = 0

  /// The total fee (in satoshis) that this payment circuit carried.
  var fee: UInt64 = 0

  /// The total fee (in milli-satoshis) that this payment circuit carried.
  var feeMsat: UInt64 = 0

  /// The total amount (in milli-satoshis) of the incoming HTLC that created
  /// half the circuit.
  var amtInMsat: UInt64 = 0

  /// The total amount (in milli-satoshis) of the outgoing HTLC that created
  /// the second half of the circuit.
  var amtOutMsat: UInt64 = 0

  /// The number of nanoseconds elapsed since January 1, 1970 UTC when this
  /// circuit was completed.
  var timestampNs: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ForwardingHistoryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of forwarding events from the time slice of the time series
  /// specified in the request.
  var forwardingEvents: [Lnrpc_ForwardingEvent] = []

  /// The index of the last time in the set of returned forwarding events. Can
  /// be used to seek further, pagination style.
  var lastOffsetIndex: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ExportChannelBackupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The target channel point to obtain a back up for.
  var chanPoint: Lnrpc_ChannelPoint {
    get {return _chanPoint ?? Lnrpc_ChannelPoint()}
    set {_chanPoint = newValue}
  }
  /// Returns true if `chanPoint` has been explicitly set.
  var hasChanPoint: Bool {return self._chanPoint != nil}
  /// Clears the value of `chanPoint`. Subsequent reads from it will return its default value.
  mutating func clearChanPoint() {self._chanPoint = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _chanPoint: Lnrpc_ChannelPoint? = nil
}

struct Lnrpc_ChannelBackup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///Identifies the channel that this backup belongs to.
  var chanPoint: Lnrpc_ChannelPoint {
    get {return _chanPoint ?? Lnrpc_ChannelPoint()}
    set {_chanPoint = newValue}
  }
  /// Returns true if `chanPoint` has been explicitly set.
  var hasChanPoint: Bool {return self._chanPoint != nil}
  /// Clears the value of `chanPoint`. Subsequent reads from it will return its default value.
  mutating func clearChanPoint() {self._chanPoint = nil}

  ///
  ///Is an encrypted single-chan backup. this can be passed to
  ///RestoreChannelBackups, or the WalletUnlocker Init and Unlock methods in
  ///order to trigger the recovery protocol. When using REST, this field must be
  ///encoded as base64.
  var chanBackup: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _chanPoint: Lnrpc_ChannelPoint? = nil
}

struct Lnrpc_MultiChanBackup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///Is the set of all channels that are included in this multi-channel backup.
  var chanPoints: [Lnrpc_ChannelPoint] = []

  ///
  ///A single encrypted blob containing all the static channel backups of the
  ///channel listed above. This can be stored as a single file or blob, and
  ///safely be replaced with any prior/future versions. When using REST, this
  ///field must be encoded as base64.
  var multiChanBackup: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChanBackupExportRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChanBackupSnapshot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The set of new channels that have been added since the last channel backup
  ///snapshot was requested.
  var singleChanBackups: Lnrpc_ChannelBackups {
    get {return _singleChanBackups ?? Lnrpc_ChannelBackups()}
    set {_singleChanBackups = newValue}
  }
  /// Returns true if `singleChanBackups` has been explicitly set.
  var hasSingleChanBackups: Bool {return self._singleChanBackups != nil}
  /// Clears the value of `singleChanBackups`. Subsequent reads from it will return its default value.
  mutating func clearSingleChanBackups() {self._singleChanBackups = nil}

  ///
  ///A multi-channel backup that covers all open channels currently known to
  ///lnd.
  var multiChanBackup: Lnrpc_MultiChanBackup {
    get {return _multiChanBackup ?? Lnrpc_MultiChanBackup()}
    set {_multiChanBackup = newValue}
  }
  /// Returns true if `multiChanBackup` has been explicitly set.
  var hasMultiChanBackup: Bool {return self._multiChanBackup != nil}
  /// Clears the value of `multiChanBackup`. Subsequent reads from it will return its default value.
  mutating func clearMultiChanBackup() {self._multiChanBackup = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _singleChanBackups: Lnrpc_ChannelBackups? = nil
  fileprivate var _multiChanBackup: Lnrpc_MultiChanBackup? = nil
}

struct Lnrpc_ChannelBackups {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///A set of single-chan static channel backups.
  var chanBackups: [Lnrpc_ChannelBackup] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_RestoreChanBackupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var backup: Lnrpc_RestoreChanBackupRequest.OneOf_Backup? = nil

  ///
  ///The channels to restore as a list of channel/backup pairs.
  var chanBackups: Lnrpc_ChannelBackups {
    get {
      if case .chanBackups(let v)? = backup {return v}
      return Lnrpc_ChannelBackups()
    }
    set {backup = .chanBackups(newValue)}
  }

  ///
  ///The channels to restore in the packed multi backup format. When using
  ///REST, this field must be encoded as base64.
  var multiChanBackup: Data {
    get {
      if case .multiChanBackup(let v)? = backup {return v}
      return Data()
    }
    set {backup = .multiChanBackup(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Backup: Equatable {
    ///
    ///The channels to restore as a list of channel/backup pairs.
    case chanBackups(Lnrpc_ChannelBackups)
    ///
    ///The channels to restore in the packed multi backup format. When using
    ///REST, this field must be encoded as base64.
    case multiChanBackup(Data)

  #if !swift(>=4.1)
    static func ==(lhs: Lnrpc_RestoreChanBackupRequest.OneOf_Backup, rhs: Lnrpc_RestoreChanBackupRequest.OneOf_Backup) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.chanBackups, .chanBackups): return {
        guard case .chanBackups(let l) = lhs, case .chanBackups(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.multiChanBackup, .multiChanBackup): return {
        guard case .multiChanBackup(let l) = lhs, case .multiChanBackup(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Lnrpc_RestoreBackupResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChannelBackupSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_VerifyChanBackupResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_MacaroonPermission {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The entity a permission grants access to.
  var entity: String = String()

  /// The action that is granted.
  var action: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_BakeMacaroonRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of permissions the new macaroon should grant.
  var permissions: [Lnrpc_MacaroonPermission] = []

  /// The root key ID used to create the macaroon, must be a positive integer.
  var rootKeyID: UInt64 = 0

  ///
  ///Informs the RPC on whether to allow external permissions that LND is not
  ///aware of.
  var allowExternalPermissions: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_BakeMacaroonResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The hex encoded macaroon, serialized in binary format.
  var macaroon: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListMacaroonIDsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListMacaroonIDsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of root key IDs that are in use.
  var rootKeyIds: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_DeleteMacaroonIDRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The root key ID to be removed.
  var rootKeyID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_DeleteMacaroonIDResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A boolean indicates that the deletion is successful.
  var deleted: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_MacaroonPermissionList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of macaroon permissions.
  var permissions: [Lnrpc_MacaroonPermission] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListPermissionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListPermissionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///A map between all RPC method URIs and their required macaroon permissions to
  ///access them.
  var methodPermissions: Dictionary<String,Lnrpc_MacaroonPermissionList> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_Failure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Failure code as defined in the Lightning spec
  var code: Lnrpc_Failure.FailureCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  /// An optional channel update message.
  var channelUpdate: Lnrpc_ChannelUpdate {
    get {return _storage._channelUpdate ?? Lnrpc_ChannelUpdate()}
    set {_uniqueStorage()._channelUpdate = newValue}
  }
  /// Returns true if `channelUpdate` has been explicitly set.
  var hasChannelUpdate: Bool {return _storage._channelUpdate != nil}
  /// Clears the value of `channelUpdate`. Subsequent reads from it will return its default value.
  mutating func clearChannelUpdate() {_uniqueStorage()._channelUpdate = nil}

  /// A failure type-dependent htlc value.
  var htlcMsat: UInt64 {
    get {return _storage._htlcMsat}
    set {_uniqueStorage()._htlcMsat = newValue}
  }

  /// The sha256 sum of the onion payload.
  var onionSha256: Data {
    get {return _storage._onionSha256}
    set {_uniqueStorage()._onionSha256 = newValue}
  }

  /// A failure type-dependent cltv expiry value.
  var cltvExpiry: UInt32 {
    get {return _storage._cltvExpiry}
    set {_uniqueStorage()._cltvExpiry = newValue}
  }

  /// A failure type-dependent flags value.
  var flags: UInt32 {
    get {return _storage._flags}
    set {_uniqueStorage()._flags = newValue}
  }

  ///
  ///The position in the path of the intermediate or final node that generated
  ///the failure message. Position zero is the sender node.
  var failureSourceIndex: UInt32 {
    get {return _storage._failureSourceIndex}
    set {_uniqueStorage()._failureSourceIndex = newValue}
  }

  /// A failure type-dependent block height.
  var height: UInt32 {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum FailureCode: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///
    ///The numbers assigned in this enumeration match the failure codes as
    ///defined in BOLT #4. Because protobuf 3 requires enums to start with 0,
    ///a RESERVED value is added.
    case reserved // = 0
    case incorrectOrUnknownPaymentDetails // = 1
    case incorrectPaymentAmount // = 2
    case finalIncorrectCltvExpiry // = 3
    case finalIncorrectHtlcAmount // = 4
    case finalExpiryTooSoon // = 5
    case invalidRealm // = 6
    case expiryTooSoon // = 7
    case invalidOnionVersion // = 8
    case invalidOnionHmac // = 9
    case invalidOnionKey // = 10
    case amountBelowMinimum // = 11
    case feeInsufficient // = 12
    case incorrectCltvExpiry // = 13
    case channelDisabled // = 14
    case temporaryChannelFailure // = 15
    case requiredNodeFeatureMissing // = 16
    case requiredChannelFeatureMissing // = 17
    case unknownNextPeer // = 18
    case temporaryNodeFailure // = 19
    case permanentNodeFailure // = 20
    case permanentChannelFailure // = 21
    case expiryTooFar // = 22
    case mppTimeout // = 23
    case invalidOnionPayload // = 24

    ///
    ///An internal error occurred.
    case internalFailure // = 997

    ///
    ///The error source is known, but the failure itself couldn't be decoded.
    case unknownFailure // = 998

    ///
    ///An unreadable failure result is returned if the received failure message
    ///cannot be decrypted. In that case the error source is unknown.
    case unreadableFailure // = 999
    case UNRECOGNIZED(Int)

    init() {
      self = .reserved
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .reserved
      case 1: self = .incorrectOrUnknownPaymentDetails
      case 2: self = .incorrectPaymentAmount
      case 3: self = .finalIncorrectCltvExpiry
      case 4: self = .finalIncorrectHtlcAmount
      case 5: self = .finalExpiryTooSoon
      case 6: self = .invalidRealm
      case 7: self = .expiryTooSoon
      case 8: self = .invalidOnionVersion
      case 9: self = .invalidOnionHmac
      case 10: self = .invalidOnionKey
      case 11: self = .amountBelowMinimum
      case 12: self = .feeInsufficient
      case 13: self = .incorrectCltvExpiry
      case 14: self = .channelDisabled
      case 15: self = .temporaryChannelFailure
      case 16: self = .requiredNodeFeatureMissing
      case 17: self = .requiredChannelFeatureMissing
      case 18: self = .unknownNextPeer
      case 19: self = .temporaryNodeFailure
      case 20: self = .permanentNodeFailure
      case 21: self = .permanentChannelFailure
      case 22: self = .expiryTooFar
      case 23: self = .mppTimeout
      case 24: self = .invalidOnionPayload
      case 997: self = .internalFailure
      case 998: self = .unknownFailure
      case 999: self = .unreadableFailure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .reserved: return 0
      case .incorrectOrUnknownPaymentDetails: return 1
      case .incorrectPaymentAmount: return 2
      case .finalIncorrectCltvExpiry: return 3
      case .finalIncorrectHtlcAmount: return 4
      case .finalExpiryTooSoon: return 5
      case .invalidRealm: return 6
      case .expiryTooSoon: return 7
      case .invalidOnionVersion: return 8
      case .invalidOnionHmac: return 9
      case .invalidOnionKey: return 10
      case .amountBelowMinimum: return 11
      case .feeInsufficient: return 12
      case .incorrectCltvExpiry: return 13
      case .channelDisabled: return 14
      case .temporaryChannelFailure: return 15
      case .requiredNodeFeatureMissing: return 16
      case .requiredChannelFeatureMissing: return 17
      case .unknownNextPeer: return 18
      case .temporaryNodeFailure: return 19
      case .permanentNodeFailure: return 20
      case .permanentChannelFailure: return 21
      case .expiryTooFar: return 22
      case .mppTimeout: return 23
      case .invalidOnionPayload: return 24
      case .internalFailure: return 997
      case .unknownFailure: return 998
      case .unreadableFailure: return 999
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Lnrpc_Failure.FailureCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Lnrpc_Failure.FailureCode] = [
    .reserved,
    .incorrectOrUnknownPaymentDetails,
    .incorrectPaymentAmount,
    .finalIncorrectCltvExpiry,
    .finalIncorrectHtlcAmount,
    .finalExpiryTooSoon,
    .invalidRealm,
    .expiryTooSoon,
    .invalidOnionVersion,
    .invalidOnionHmac,
    .invalidOnionKey,
    .amountBelowMinimum,
    .feeInsufficient,
    .incorrectCltvExpiry,
    .channelDisabled,
    .temporaryChannelFailure,
    .requiredNodeFeatureMissing,
    .requiredChannelFeatureMissing,
    .unknownNextPeer,
    .temporaryNodeFailure,
    .permanentNodeFailure,
    .permanentChannelFailure,
    .expiryTooFar,
    .mppTimeout,
    .invalidOnionPayload,
    .internalFailure,
    .unknownFailure,
    .unreadableFailure,
  ]
}

#endif  // swift(>=4.2)

struct Lnrpc_ChannelUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The signature that validates the announced data and proves the ownership
  ///of node id.
  var signature: Data = Data()

  ///
  ///The target chain that this channel was opened within. This value
  ///should be the genesis hash of the target chain. Along with the short
  ///channel ID, this uniquely identifies the channel globally in a
  ///blockchain.
  var chainHash: Data = Data()

  ///
  ///The unique description of the funding transaction.
  var chanID: UInt64 = 0

  ///
  ///A timestamp that allows ordering in the case of multiple announcements.
  ///We should ignore the message if timestamp is not greater than the
  ///last-received.
  var timestamp: UInt32 = 0

  ///
  ///The bitfield that describes whether optional fields are present in this
  ///update. Currently, the least-significant bit must be set to 1 if the
  ///optional field MaxHtlc is present.
  var messageFlags: UInt32 = 0

  ///
  ///The bitfield that describes additional meta-data concerning how the
  ///update is to be interpreted. Currently, the least-significant bit must be
  ///set to 0 if the creating node corresponds to the first node in the
  ///previously sent channel announcement and 1 otherwise. If the second bit
  ///is set, then the channel is set to be disabled.
  var channelFlags: UInt32 = 0

  ///
  ///The minimum number of blocks this node requires to be added to the expiry
  ///of HTLCs. This is a security parameter determined by the node operator.
  ///This value represents the required gap between the time locks of the
  ///incoming and outgoing HTLC's set to this node.
  var timeLockDelta: UInt32 = 0

  ///
  ///The minimum HTLC value which will be accepted.
  var htlcMinimumMsat: UInt64 = 0

  ///
  ///The base fee that must be used for incoming HTLC's to this particular
  ///channel. This value will be tacked onto the required for a payment
  ///independent of the size of the payment.
  var baseFee: UInt32 = 0

  ///
  ///The fee rate that will be charged per millionth of a satoshi.
  var feeRate: UInt32 = 0

  ///
  ///The maximum HTLC value which will be accepted.
  var htlcMaximumMsat: UInt64 = 0

  ///
  ///The set of data that was appended to this message, some of which we may
  ///not actually know how to iterate or parse. By holding onto this data, we
  ///ensure that we're able to properly validate the set of signatures that
  ///cover these new fields, and ensure we're able to make upgrades to the
  ///network in a forwards compatible manner.
  var extraOpaqueData: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_MacaroonId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nonce: Data = Data()

  var storageID: Data = Data()

  var ops: [Lnrpc_Op] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_Op {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entity: String = String()

  var actions: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_CheckMacPermRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var macaroon: Data = Data()

  var permissions: [Lnrpc_MacaroonPermission] = []

  var fullMethod: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_CheckMacPermResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var valid: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_RPCMiddlewareRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The unique ID of the intercepted request. Useful for mapping request to
  ///response when implementing full duplex message interception.
  var requestID: UInt64 = 0

  ///
  ///The raw bytes of the complete macaroon as sent by the gRPC client in the
  ///original request. This might be empty for a request that doesn't require
  ///macaroons such as the wallet unlocker RPCs.
  var rawMacaroon: Data = Data()

  ///
  ///The parsed condition of the macaroon's custom caveat for convenient access.
  ///This field only contains the value of the custom caveat that the handling
  ///middleware has registered itself for. The condition _must_ be validated for
  ///messages of intercept_type stream_auth and request!
  var customCaveatCondition: String = String()

  ///
  ///There are three types of messages that will be sent to the middleware for
  ///inspection and approval: Stream authentication, request and response
  ///interception. The first two can only be accepted (=forward to main RPC
  ///server) or denied (=return error to client). Intercepted responses can also
  ///be replaced/overwritten.
  var interceptType: Lnrpc_RPCMiddlewareRequest.OneOf_InterceptType? = nil

  ///
  ///Intercept stream authentication: each new streaming RPC call that is
  ///initiated against lnd and contains the middleware's custom macaroon
  ///caveat can be approved or denied based upon the macaroon in the stream
  ///header. This message will only be sent for streaming RPCs, unary RPCs
  ///must handle the macaroon authentication in the request interception to
  ///avoid an additional message round trip between lnd and the middleware.
  var streamAuth: Lnrpc_StreamAuth {
    get {
      if case .streamAuth(let v)? = interceptType {return v}
      return Lnrpc_StreamAuth()
    }
    set {interceptType = .streamAuth(newValue)}
  }

  ///
  ///Intercept incoming gRPC client request message: all incoming messages,
  ///both on streaming and unary RPCs, are forwarded to the middleware for
  ///inspection. For unary RPC messages the middleware is also expected to
  ///validate the custom macaroon caveat of the request.
  var request: Lnrpc_RPCMessage {
    get {
      if case .request(let v)? = interceptType {return v}
      return Lnrpc_RPCMessage()
    }
    set {interceptType = .request(newValue)}
  }

  ///
  ///Intercept outgoing gRPC response message: all outgoing messages, both on
  ///streaming and unary RPCs, are forwarded to the middleware for inspection
  ///and amendment. The response in this message is the original response as
  ///it was generated by the main RPC server. It can either be accepted
  ///(=forwarded to the client), replaced/overwritten with a new message of
  ///the same type, or replaced by an error message.
  var response: Lnrpc_RPCMessage {
    get {
      if case .response(let v)? = interceptType {return v}
      return Lnrpc_RPCMessage()
    }
    set {interceptType = .response(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  ///There are three types of messages that will be sent to the middleware for
  ///inspection and approval: Stream authentication, request and response
  ///interception. The first two can only be accepted (=forward to main RPC
  ///server) or denied (=return error to client). Intercepted responses can also
  ///be replaced/overwritten.
  enum OneOf_InterceptType: Equatable {
    ///
    ///Intercept stream authentication: each new streaming RPC call that is
    ///initiated against lnd and contains the middleware's custom macaroon
    ///caveat can be approved or denied based upon the macaroon in the stream
    ///header. This message will only be sent for streaming RPCs, unary RPCs
    ///must handle the macaroon authentication in the request interception to
    ///avoid an additional message round trip between lnd and the middleware.
    case streamAuth(Lnrpc_StreamAuth)
    ///
    ///Intercept incoming gRPC client request message: all incoming messages,
    ///both on streaming and unary RPCs, are forwarded to the middleware for
    ///inspection. For unary RPC messages the middleware is also expected to
    ///validate the custom macaroon caveat of the request.
    case request(Lnrpc_RPCMessage)
    ///
    ///Intercept outgoing gRPC response message: all outgoing messages, both on
    ///streaming and unary RPCs, are forwarded to the middleware for inspection
    ///and amendment. The response in this message is the original response as
    ///it was generated by the main RPC server. It can either be accepted
    ///(=forwarded to the client), replaced/overwritten with a new message of
    ///the same type, or replaced by an error message.
    case response(Lnrpc_RPCMessage)

  #if !swift(>=4.1)
    static func ==(lhs: Lnrpc_RPCMiddlewareRequest.OneOf_InterceptType, rhs: Lnrpc_RPCMiddlewareRequest.OneOf_InterceptType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.streamAuth, .streamAuth): return {
        guard case .streamAuth(let l) = lhs, case .streamAuth(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.request, .request): return {
        guard case .request(let l) = lhs, case .request(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.response, .response): return {
        guard case .response(let l) = lhs, case .response(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Lnrpc_StreamAuth {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The full URI (in the format /<rpcpackage>.<ServiceName>/MethodName, for
  ///example /lnrpc.Lightning/GetInfo) of the streaming RPC method that was just
  ///established.
  var methodFullUri: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_RPCMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The full URI (in the format /<rpcpackage>.<ServiceName>/MethodName, for
  ///example /lnrpc.Lightning/GetInfo) of the RPC method the message was sent
  ///to/from.
  var methodFullUri: String = String()

  ///
  ///Indicates whether the message was sent over a streaming RPC method or not.
  var streamRpc: Bool = false

  ///
  ///The full canonical gRPC name of the message type (in the format
  ///<rpcpackage>.TypeName, for example lnrpc.GetInfoRequest).
  var typeName: String = String()

  ///
  ///The full content of the gRPC message, serialized in the binary protobuf
  ///format.
  var serialized: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_RPCMiddlewareResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The unique ID of the intercepted request that this response refers to. Must
  ///always be set when giving feedback to an intercept but is ignored for the
  ///initial registration message.
  var requestID: UInt64 = 0

  ///
  ///The middleware can only send two types of messages to lnd: The initial
  ///registration message that identifies the middleware and after that only
  ///feedback messages to requests sent to the middleware.
  var middlewareMessage: Lnrpc_RPCMiddlewareResponse.OneOf_MiddlewareMessage? = nil

  ///
  ///The registration message identifies the middleware that's being
  ///registered in lnd. The registration message must be sent immediately
  ///after initiating the RegisterRpcMiddleware stream, otherwise lnd will
  ///time out the attempt and terminate the request. NOTE: The middleware
  ///will only receive interception messages for requests that contain a
  ///macaroon with the custom caveat that the middleware declares it is
  ///responsible for handling in the registration message! As a security
  ///measure, _no_ middleware can intercept requests made with _unencumbered_
  ///macaroons!
  var register: Lnrpc_MiddlewareRegistration {
    get {
      if case .register(let v)? = middlewareMessage {return v}
      return Lnrpc_MiddlewareRegistration()
    }
    set {middlewareMessage = .register(newValue)}
  }

  ///
  ///The middleware received an interception request and gives feedback to
  ///it. The request_id indicates what message the feedback refers to.
  var feedback: Lnrpc_InterceptFeedback {
    get {
      if case .feedback(let v)? = middlewareMessage {return v}
      return Lnrpc_InterceptFeedback()
    }
    set {middlewareMessage = .feedback(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  ///The middleware can only send two types of messages to lnd: The initial
  ///registration message that identifies the middleware and after that only
  ///feedback messages to requests sent to the middleware.
  enum OneOf_MiddlewareMessage: Equatable {
    ///
    ///The registration message identifies the middleware that's being
    ///registered in lnd. The registration message must be sent immediately
    ///after initiating the RegisterRpcMiddleware stream, otherwise lnd will
    ///time out the attempt and terminate the request. NOTE: The middleware
    ///will only receive interception messages for requests that contain a
    ///macaroon with the custom caveat that the middleware declares it is
    ///responsible for handling in the registration message! As a security
    ///measure, _no_ middleware can intercept requests made with _unencumbered_
    ///macaroons!
    case register(Lnrpc_MiddlewareRegistration)
    ///
    ///The middleware received an interception request and gives feedback to
    ///it. The request_id indicates what message the feedback refers to.
    case feedback(Lnrpc_InterceptFeedback)

  #if !swift(>=4.1)
    static func ==(lhs: Lnrpc_RPCMiddlewareResponse.OneOf_MiddlewareMessage, rhs: Lnrpc_RPCMiddlewareResponse.OneOf_MiddlewareMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.register, .register): return {
        guard case .register(let l) = lhs, case .register(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.feedback, .feedback): return {
        guard case .feedback(let l) = lhs, case .feedback(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Lnrpc_MiddlewareRegistration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The name of the middleware to register. The name should be as informative
  ///as possible and is logged on registration.
  var middlewareName: String = String()

  ///
  ///The name of the custom macaroon caveat that this middleware is responsible
  ///for. Only requests/responses that contain a macaroon with the registered
  ///custom caveat are forwarded for interception to the middleware. The
  ///exception being the read-only mode: All requests/responses are forwarded to
  ///a middleware that requests read-only access but such a middleware won't be
  ///allowed to _alter_ responses. As a security measure, _no_ middleware can
  ///change responses to requests made with _unencumbered_ macaroons!
  ///NOTE: Cannot be used at the same time as read_only_mode.
  var customMacaroonCaveatName: String = String()

  ///
  ///Instead of defining a custom macaroon caveat name a middleware can register
  ///itself for read-only access only. In that mode all requests/responses are
  ///forwarded to the middleware but the middleware isn't allowed to alter any of
  ///the responses.
  ///NOTE: Cannot be used at the same time as custom_macaroon_caveat_name.
  var readOnlyMode: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_InterceptFeedback {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The error to return to the user. If this is non-empty, the incoming gRPC
  ///stream/request is aborted and the error is returned to the gRPC client. If
  ///this value is empty, it means the middleware accepts the stream/request/
  ///response and the processing of it can continue.
  var error: String = String()

  ///
  ///A boolean indicating that the gRPC response should be replaced/overwritten.
  ///As its name suggests, this can only be used as a feedback to an intercepted
  ///response RPC message and is ignored for feedback on any other message. This
  ///boolean is needed because in protobuf an empty message is serialized as a
  ///0-length or nil byte slice and we wouldn't be able to distinguish between
  ///an empty replacement message and the "don't replace anything" case.
  var replaceResponse: Bool = false

  ///
  ///If the replace_response field is set to true, this field must contain the
  ///binary serialized gRPC response message in the protobuf format.
  var replacementSerialized: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "lnrpc"

extension Lnrpc_AddressType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WITNESS_PUBKEY_HASH"),
    1: .same(proto: "NESTED_PUBKEY_HASH"),
    2: .same(proto: "UNUSED_WITNESS_PUBKEY_HASH"),
    3: .same(proto: "UNUSED_NESTED_PUBKEY_HASH"),
  ]
}

extension Lnrpc_CommitmentType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_COMMITMENT_TYPE"),
    1: .same(proto: "LEGACY"),
    2: .same(proto: "STATIC_REMOTE_KEY"),
    3: .same(proto: "ANCHORS"),
    4: .same(proto: "SCRIPT_ENFORCED_LEASE"),
  ]
}

extension Lnrpc_Initiator: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INITIATOR_UNKNOWN"),
    1: .same(proto: "INITIATOR_LOCAL"),
    2: .same(proto: "INITIATOR_REMOTE"),
    3: .same(proto: "INITIATOR_BOTH"),
  ]
}

extension Lnrpc_ResolutionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "ANCHOR"),
    2: .same(proto: "INCOMING_HTLC"),
    3: .same(proto: "OUTGOING_HTLC"),
    4: .same(proto: "COMMIT"),
  ]
}

extension Lnrpc_ResolutionOutcome: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OUTCOME_UNKNOWN"),
    1: .same(proto: "CLAIMED"),
    2: .same(proto: "UNCLAIMED"),
    3: .same(proto: "ABANDONED"),
    4: .same(proto: "FIRST_STAGE"),
    5: .same(proto: "TIMEOUT"),
  ]
}

extension Lnrpc_NodeMetricType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "BETWEENNESS_CENTRALITY"),
  ]
}

extension Lnrpc_InvoiceHTLCState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACCEPTED"),
    1: .same(proto: "SETTLED"),
    2: .same(proto: "CANCELED"),
  ]
}

extension Lnrpc_PaymentFailureReason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FAILURE_REASON_NONE"),
    1: .same(proto: "FAILURE_REASON_TIMEOUT"),
    2: .same(proto: "FAILURE_REASON_NO_ROUTE"),
    3: .same(proto: "FAILURE_REASON_ERROR"),
    4: .same(proto: "FAILURE_REASON_INCORRECT_PAYMENT_DETAILS"),
    5: .same(proto: "FAILURE_REASON_INSUFFICIENT_BALANCE"),
  ]
}

extension Lnrpc_FeatureBit: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DATALOSS_PROTECT_REQ"),
    1: .same(proto: "DATALOSS_PROTECT_OPT"),
    3: .same(proto: "INITIAL_ROUING_SYNC"),
    4: .same(proto: "UPFRONT_SHUTDOWN_SCRIPT_REQ"),
    5: .same(proto: "UPFRONT_SHUTDOWN_SCRIPT_OPT"),
    6: .same(proto: "GOSSIP_QUERIES_REQ"),
    7: .same(proto: "GOSSIP_QUERIES_OPT"),
    8: .same(proto: "TLV_ONION_REQ"),
    9: .same(proto: "TLV_ONION_OPT"),
    10: .same(proto: "EXT_GOSSIP_QUERIES_REQ"),
    11: .same(proto: "EXT_GOSSIP_QUERIES_OPT"),
    12: .same(proto: "STATIC_REMOTE_KEY_REQ"),
    13: .same(proto: "STATIC_REMOTE_KEY_OPT"),
    14: .same(proto: "PAYMENT_ADDR_REQ"),
    15: .same(proto: "PAYMENT_ADDR_OPT"),
    16: .same(proto: "MPP_REQ"),
    17: .same(proto: "MPP_OPT"),
    18: .same(proto: "WUMBO_CHANNELS_REQ"),
    19: .same(proto: "WUMBO_CHANNELS_OPT"),
    20: .same(proto: "ANCHORS_REQ"),
    21: .same(proto: "ANCHORS_OPT"),
    22: .same(proto: "ANCHORS_ZERO_FEE_HTLC_REQ"),
    23: .same(proto: "ANCHORS_ZERO_FEE_HTLC_OPT"),
    30: .same(proto: "AMP_REQ"),
    31: .same(proto: "AMP_OPT"),
  ]
}

extension Lnrpc_UpdateFailure: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UPDATE_FAILURE_UNKNOWN"),
    1: .same(proto: "UPDATE_FAILURE_PENDING"),
    2: .same(proto: "UPDATE_FAILURE_NOT_FOUND"),
    3: .same(proto: "UPDATE_FAILURE_INTERNAL_ERR"),
    4: .same(proto: "UPDATE_FAILURE_INVALID_PARAMETER"),
  ]
}

extension Lnrpc_SubscribeCustomMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeCustomMessagesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_SubscribeCustomMessagesRequest, rhs: Lnrpc_SubscribeCustomMessagesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_CustomMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CustomMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "peer"),
    2: .same(proto: "type"),
    3: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.peer) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.type) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.peer.isEmpty {
      try visitor.visitSingularBytesField(value: self.peer, fieldNumber: 1)
    }
    if self.type != 0 {
      try visitor.visitSingularUInt32Field(value: self.type, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_CustomMessage, rhs: Lnrpc_CustomMessage) -> Bool {
    if lhs.peer != rhs.peer {return false}
    if lhs.type != rhs.type {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_SendCustomMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendCustomMessageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "peer"),
    2: .same(proto: "type"),
    3: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.peer) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.type) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.peer.isEmpty {
      try visitor.visitSingularBytesField(value: self.peer, fieldNumber: 1)
    }
    if self.type != 0 {
      try visitor.visitSingularUInt32Field(value: self.type, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_SendCustomMessageRequest, rhs: Lnrpc_SendCustomMessageRequest) -> Bool {
    if lhs.peer != rhs.peer {return false}
    if lhs.type != rhs.type {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_SendCustomMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendCustomMessageResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_SendCustomMessageResponse, rhs: Lnrpc_SendCustomMessageResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_Utxo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Utxo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "address_type"),
    2: .same(proto: "address"),
    3: .standard(proto: "amount_sat"),
    4: .standard(proto: "pk_script"),
    5: .same(proto: "outpoint"),
    6: .same(proto: "confirmations"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.addressType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.amountSat) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pkScript) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._outpoint) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.confirmations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.addressType != .witnessPubkeyHash {
      try visitor.visitSingularEnumField(value: self.addressType, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    if self.amountSat != 0 {
      try visitor.visitSingularInt64Field(value: self.amountSat, fieldNumber: 3)
    }
    if !self.pkScript.isEmpty {
      try visitor.visitSingularStringField(value: self.pkScript, fieldNumber: 4)
    }
    if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.confirmations != 0 {
      try visitor.visitSingularInt64Field(value: self.confirmations, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_Utxo, rhs: Lnrpc_Utxo) -> Bool {
    if lhs.addressType != rhs.addressType {return false}
    if lhs.address != rhs.address {return false}
    if lhs.amountSat != rhs.amountSat {return false}
    if lhs.pkScript != rhs.pkScript {return false}
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs.confirmations != rhs.confirmations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Transaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_hash"),
    2: .same(proto: "amount"),
    3: .standard(proto: "num_confirmations"),
    4: .standard(proto: "block_hash"),
    5: .standard(proto: "block_height"),
    6: .standard(proto: "time_stamp"),
    7: .standard(proto: "total_fees"),
    8: .standard(proto: "dest_addresses"),
    9: .standard(proto: "raw_tx_hex"),
    10: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.txHash) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.numConfirmations) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.blockHash) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.blockHeight) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.timeStamp) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.totalFees) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.destAddresses) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.rawTxHex) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txHash.isEmpty {
      try visitor.visitSingularStringField(value: self.txHash, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    if self.numConfirmations != 0 {
      try visitor.visitSingularInt32Field(value: self.numConfirmations, fieldNumber: 3)
    }
    if !self.blockHash.isEmpty {
      try visitor.visitSingularStringField(value: self.blockHash, fieldNumber: 4)
    }
    if self.blockHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.blockHeight, fieldNumber: 5)
    }
    if self.timeStamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timeStamp, fieldNumber: 6)
    }
    if self.totalFees != 0 {
      try visitor.visitSingularInt64Field(value: self.totalFees, fieldNumber: 7)
    }
    if !self.destAddresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.destAddresses, fieldNumber: 8)
    }
    if !self.rawTxHex.isEmpty {
      try visitor.visitSingularStringField(value: self.rawTxHex, fieldNumber: 9)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_Transaction, rhs: Lnrpc_Transaction) -> Bool {
    if lhs.txHash != rhs.txHash {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.numConfirmations != rhs.numConfirmations {return false}
    if lhs.blockHash != rhs.blockHash {return false}
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs.timeStamp != rhs.timeStamp {return false}
    if lhs.totalFees != rhs.totalFees {return false}
    if lhs.destAddresses != rhs.destAddresses {return false}
    if lhs.rawTxHex != rhs.rawTxHex {return false}
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_GetTransactionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTransactionsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_height"),
    2: .standard(proto: "end_height"),
    3: .same(proto: "account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.startHeight) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.endHeight) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.account) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.startHeight, fieldNumber: 1)
    }
    if self.endHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.endHeight, fieldNumber: 2)
    }
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_GetTransactionsRequest, rhs: Lnrpc_GetTransactionsRequest) -> Bool {
    if lhs.startHeight != rhs.startHeight {return false}
    if lhs.endHeight != rhs.endHeight {return false}
    if lhs.account != rhs.account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_TransactionDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.transactions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_TransactionDetails, rhs: Lnrpc_TransactionDetails) -> Bool {
    if lhs.transactions != rhs.transactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_FeeLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeLimit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fixed"),
    3: .standard(proto: "fixed_msat"),
    2: .same(proto: "percent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.limit != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.limit = .fixed(v)}
      }()
      case 2: try {
        if self.limit != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.limit = .percent(v)}
      }()
      case 3: try {
        if self.limit != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.limit = .fixedMsat(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.limit {
    case .fixed?: try {
      guard case .fixed(let v)? = self.limit else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }()
    case .percent?: try {
      guard case .percent(let v)? = self.limit else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }()
    case .fixedMsat?: try {
      guard case .fixedMsat(let v)? = self.limit else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_FeeLimit, rhs: Lnrpc_FeeLimit) -> Bool {
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_SendRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dest"),
    2: .standard(proto: "dest_string"),
    3: .same(proto: "amt"),
    12: .standard(proto: "amt_msat"),
    4: .standard(proto: "payment_hash"),
    5: .standard(proto: "payment_hash_string"),
    6: .standard(proto: "payment_request"),
    7: .standard(proto: "final_cltv_delta"),
    8: .standard(proto: "fee_limit"),
    9: .standard(proto: "outgoing_chan_id"),
    13: .standard(proto: "last_hop_pubkey"),
    10: .standard(proto: "cltv_limit"),
    11: .standard(proto: "dest_custom_records"),
    14: .standard(proto: "allow_self_payment"),
    15: .standard(proto: "dest_features"),
    16: .standard(proto: "payment_addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.dest) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.destString) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.amt) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.paymentHashString) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.paymentRequest) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.finalCltvDelta) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._feeLimit) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.outgoingChanID) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.cltvLimit) }()
      case 11: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt64,SwiftProtobuf.ProtobufBytes>.self, value: &self.destCustomRecords) }()
      case 12: try { try decoder.decodeSingularInt64Field(value: &self.amtMsat) }()
      case 13: try { try decoder.decodeSingularBytesField(value: &self.lastHopPubkey) }()
      case 14: try { try decoder.decodeSingularBoolField(value: &self.allowSelfPayment) }()
      case 15: try { try decoder.decodeRepeatedEnumField(value: &self.destFeatures) }()
      case 16: try { try decoder.decodeSingularBytesField(value: &self.paymentAddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dest.isEmpty {
      try visitor.visitSingularBytesField(value: self.dest, fieldNumber: 1)
    }
    if !self.destString.isEmpty {
      try visitor.visitSingularStringField(value: self.destString, fieldNumber: 2)
    }
    if self.amt != 0 {
      try visitor.visitSingularInt64Field(value: self.amt, fieldNumber: 3)
    }
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 4)
    }
    if !self.paymentHashString.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentHashString, fieldNumber: 5)
    }
    if !self.paymentRequest.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentRequest, fieldNumber: 6)
    }
    if self.finalCltvDelta != 0 {
      try visitor.visitSingularInt32Field(value: self.finalCltvDelta, fieldNumber: 7)
    }
    if let v = self._feeLimit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if self.outgoingChanID != 0 {
      try visitor.visitSingularUInt64Field(value: self.outgoingChanID, fieldNumber: 9)
    }
    if self.cltvLimit != 0 {
      try visitor.visitSingularUInt32Field(value: self.cltvLimit, fieldNumber: 10)
    }
    if !self.destCustomRecords.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt64,SwiftProtobuf.ProtobufBytes>.self, value: self.destCustomRecords, fieldNumber: 11)
    }
    if self.amtMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.amtMsat, fieldNumber: 12)
    }
    if !self.lastHopPubkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.lastHopPubkey, fieldNumber: 13)
    }
    if self.allowSelfPayment != false {
      try visitor.visitSingularBoolField(value: self.allowSelfPayment, fieldNumber: 14)
    }
    if !self.destFeatures.isEmpty {
      try visitor.visitPackedEnumField(value: self.destFeatures, fieldNumber: 15)
    }
    if !self.paymentAddr.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentAddr, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_SendRequest, rhs: Lnrpc_SendRequest) -> Bool {
    if lhs.dest != rhs.dest {return false}
    if lhs.destString != rhs.destString {return false}
    if lhs.amt != rhs.amt {return false}
    if lhs.amtMsat != rhs.amtMsat {return false}
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.paymentHashString != rhs.paymentHashString {return false}
    if lhs.paymentRequest != rhs.paymentRequest {return false}
    if lhs.finalCltvDelta != rhs.finalCltvDelta {return false}
    if lhs._feeLimit != rhs._feeLimit {return false}
    if lhs.outgoingChanID != rhs.outgoingChanID {return false}
    if lhs.lastHopPubkey != rhs.lastHopPubkey {return false}
    if lhs.cltvLimit != rhs.cltvLimit {return false}
    if lhs.destCustomRecords != rhs.destCustomRecords {return false}
    if lhs.allowSelfPayment != rhs.allowSelfPayment {return false}
    if lhs.destFeatures != rhs.destFeatures {return false}
    if lhs.paymentAddr != rhs.paymentAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_SendResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "payment_error"),
    2: .standard(proto: "payment_preimage"),
    3: .standard(proto: "payment_route"),
    4: .standard(proto: "payment_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.paymentError) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.paymentPreimage) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._paymentRoute) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.paymentError.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentError, fieldNumber: 1)
    }
    if !self.paymentPreimage.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentPreimage, fieldNumber: 2)
    }
    if let v = self._paymentRoute {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_SendResponse, rhs: Lnrpc_SendResponse) -> Bool {
    if lhs.paymentError != rhs.paymentError {return false}
    if lhs.paymentPreimage != rhs.paymentPreimage {return false}
    if lhs._paymentRoute != rhs._paymentRoute {return false}
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_SendToRouteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendToRouteRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "payment_hash"),
    2: .standard(proto: "payment_hash_string"),
    4: .same(proto: "route"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.paymentHashString) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._route) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 1)
    }
    if !self.paymentHashString.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentHashString, fieldNumber: 2)
    }
    if let v = self._route {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_SendToRouteRequest, rhs: Lnrpc_SendToRouteRequest) -> Bool {
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.paymentHashString != rhs.paymentHashString {return false}
    if lhs._route != rhs._route {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelAcceptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelAcceptRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_pubkey"),
    2: .standard(proto: "chain_hash"),
    3: .standard(proto: "pending_chan_id"),
    4: .standard(proto: "funding_amt"),
    5: .standard(proto: "push_amt"),
    6: .standard(proto: "dust_limit"),
    7: .standard(proto: "max_value_in_flight"),
    8: .standard(proto: "channel_reserve"),
    9: .standard(proto: "min_htlc"),
    10: .standard(proto: "fee_per_kw"),
    11: .standard(proto: "csv_delay"),
    12: .standard(proto: "max_accepted_htlcs"),
    13: .standard(proto: "channel_flags"),
    14: .standard(proto: "commitment_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.nodePubkey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.chainHash) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.pendingChanID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.fundingAmt) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.pushAmt) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.dustLimit) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.maxValueInFlight) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.channelReserve) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.minHtlc) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self.feePerKw) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self.csvDelay) }()
      case 12: try { try decoder.decodeSingularUInt32Field(value: &self.maxAcceptedHtlcs) }()
      case 13: try { try decoder.decodeSingularUInt32Field(value: &self.channelFlags) }()
      case 14: try { try decoder.decodeSingularEnumField(value: &self.commitmentType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodePubkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.nodePubkey, fieldNumber: 1)
    }
    if !self.chainHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.chainHash, fieldNumber: 2)
    }
    if !self.pendingChanID.isEmpty {
      try visitor.visitSingularBytesField(value: self.pendingChanID, fieldNumber: 3)
    }
    if self.fundingAmt != 0 {
      try visitor.visitSingularUInt64Field(value: self.fundingAmt, fieldNumber: 4)
    }
    if self.pushAmt != 0 {
      try visitor.visitSingularUInt64Field(value: self.pushAmt, fieldNumber: 5)
    }
    if self.dustLimit != 0 {
      try visitor.visitSingularUInt64Field(value: self.dustLimit, fieldNumber: 6)
    }
    if self.maxValueInFlight != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxValueInFlight, fieldNumber: 7)
    }
    if self.channelReserve != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelReserve, fieldNumber: 8)
    }
    if self.minHtlc != 0 {
      try visitor.visitSingularUInt64Field(value: self.minHtlc, fieldNumber: 9)
    }
    if self.feePerKw != 0 {
      try visitor.visitSingularUInt64Field(value: self.feePerKw, fieldNumber: 10)
    }
    if self.csvDelay != 0 {
      try visitor.visitSingularUInt32Field(value: self.csvDelay, fieldNumber: 11)
    }
    if self.maxAcceptedHtlcs != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxAcceptedHtlcs, fieldNumber: 12)
    }
    if self.channelFlags != 0 {
      try visitor.visitSingularUInt32Field(value: self.channelFlags, fieldNumber: 13)
    }
    if self.commitmentType != .unknownCommitmentType {
      try visitor.visitSingularEnumField(value: self.commitmentType, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelAcceptRequest, rhs: Lnrpc_ChannelAcceptRequest) -> Bool {
    if lhs.nodePubkey != rhs.nodePubkey {return false}
    if lhs.chainHash != rhs.chainHash {return false}
    if lhs.pendingChanID != rhs.pendingChanID {return false}
    if lhs.fundingAmt != rhs.fundingAmt {return false}
    if lhs.pushAmt != rhs.pushAmt {return false}
    if lhs.dustLimit != rhs.dustLimit {return false}
    if lhs.maxValueInFlight != rhs.maxValueInFlight {return false}
    if lhs.channelReserve != rhs.channelReserve {return false}
    if lhs.minHtlc != rhs.minHtlc {return false}
    if lhs.feePerKw != rhs.feePerKw {return false}
    if lhs.csvDelay != rhs.csvDelay {return false}
    if lhs.maxAcceptedHtlcs != rhs.maxAcceptedHtlcs {return false}
    if lhs.channelFlags != rhs.channelFlags {return false}
    if lhs.commitmentType != rhs.commitmentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelAcceptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelAcceptResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accept"),
    2: .standard(proto: "pending_chan_id"),
    3: .same(proto: "error"),
    4: .standard(proto: "upfront_shutdown"),
    5: .standard(proto: "csv_delay"),
    6: .standard(proto: "reserve_sat"),
    7: .standard(proto: "in_flight_max_msat"),
    8: .standard(proto: "max_htlc_count"),
    9: .standard(proto: "min_htlc_in"),
    10: .standard(proto: "min_accept_depth"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.accept) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.pendingChanID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.upfrontShutdown) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.csvDelay) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.reserveSat) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.inFlightMaxMsat) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.maxHtlcCount) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.minHtlcIn) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.minAcceptDepth) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.accept != false {
      try visitor.visitSingularBoolField(value: self.accept, fieldNumber: 1)
    }
    if !self.pendingChanID.isEmpty {
      try visitor.visitSingularBytesField(value: self.pendingChanID, fieldNumber: 2)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 3)
    }
    if !self.upfrontShutdown.isEmpty {
      try visitor.visitSingularStringField(value: self.upfrontShutdown, fieldNumber: 4)
    }
    if self.csvDelay != 0 {
      try visitor.visitSingularUInt32Field(value: self.csvDelay, fieldNumber: 5)
    }
    if self.reserveSat != 0 {
      try visitor.visitSingularUInt64Field(value: self.reserveSat, fieldNumber: 6)
    }
    if self.inFlightMaxMsat != 0 {
      try visitor.visitSingularUInt64Field(value: self.inFlightMaxMsat, fieldNumber: 7)
    }
    if self.maxHtlcCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxHtlcCount, fieldNumber: 8)
    }
    if self.minHtlcIn != 0 {
      try visitor.visitSingularUInt64Field(value: self.minHtlcIn, fieldNumber: 9)
    }
    if self.minAcceptDepth != 0 {
      try visitor.visitSingularUInt32Field(value: self.minAcceptDepth, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelAcceptResponse, rhs: Lnrpc_ChannelAcceptResponse) -> Bool {
    if lhs.accept != rhs.accept {return false}
    if lhs.pendingChanID != rhs.pendingChanID {return false}
    if lhs.error != rhs.error {return false}
    if lhs.upfrontShutdown != rhs.upfrontShutdown {return false}
    if lhs.csvDelay != rhs.csvDelay {return false}
    if lhs.reserveSat != rhs.reserveSat {return false}
    if lhs.inFlightMaxMsat != rhs.inFlightMaxMsat {return false}
    if lhs.maxHtlcCount != rhs.maxHtlcCount {return false}
    if lhs.minHtlcIn != rhs.minHtlcIn {return false}
    if lhs.minAcceptDepth != rhs.minAcceptDepth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelPoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "funding_txid_bytes"),
    2: .standard(proto: "funding_txid_str"),
    3: .standard(proto: "output_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.fundingTxid != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.fundingTxid = .fundingTxidBytes(v)}
      }()
      case 2: try {
        if self.fundingTxid != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.fundingTxid = .fundingTxidStr(v)}
      }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.outputIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.fundingTxid {
    case .fundingTxidBytes?: try {
      guard case .fundingTxidBytes(let v)? = self.fundingTxid else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .fundingTxidStr?: try {
      guard case .fundingTxidStr(let v)? = self.fundingTxid else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if self.outputIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.outputIndex, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelPoint, rhs: Lnrpc_ChannelPoint) -> Bool {
    if lhs.fundingTxid != rhs.fundingTxid {return false}
    if lhs.outputIndex != rhs.outputIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_OutPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OutPoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "txid_bytes"),
    2: .standard(proto: "txid_str"),
    3: .standard(proto: "output_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txidBytes) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.txidStr) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.outputIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txidBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.txidBytes, fieldNumber: 1)
    }
    if !self.txidStr.isEmpty {
      try visitor.visitSingularStringField(value: self.txidStr, fieldNumber: 2)
    }
    if self.outputIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.outputIndex, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_OutPoint, rhs: Lnrpc_OutPoint) -> Bool {
    if lhs.txidBytes != rhs.txidBytes {return false}
    if lhs.txidStr != rhs.txidStr {return false}
    if lhs.outputIndex != rhs.outputIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_LightningAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LightningAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pubkey"),
    2: .same(proto: "host"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pubkey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.host) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubkey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubkey, fieldNumber: 1)
    }
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_LightningAddress, rhs: Lnrpc_LightningAddress) -> Bool {
    if lhs.pubkey != rhs.pubkey {return false}
    if lhs.host != rhs.host {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_EstimateFeeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EstimateFeeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AddrToAmount"),
    2: .standard(proto: "target_conf"),
    3: .standard(proto: "min_confs"),
    4: .standard(proto: "spend_unconfirmed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: &self.addrToAmount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.targetConf) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.minConfs) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.spendUnconfirmed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addrToAmount.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: self.addrToAmount, fieldNumber: 1)
    }
    if self.targetConf != 0 {
      try visitor.visitSingularInt32Field(value: self.targetConf, fieldNumber: 2)
    }
    if self.minConfs != 0 {
      try visitor.visitSingularInt32Field(value: self.minConfs, fieldNumber: 3)
    }
    if self.spendUnconfirmed != false {
      try visitor.visitSingularBoolField(value: self.spendUnconfirmed, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_EstimateFeeRequest, rhs: Lnrpc_EstimateFeeRequest) -> Bool {
    if lhs.addrToAmount != rhs.addrToAmount {return false}
    if lhs.targetConf != rhs.targetConf {return false}
    if lhs.minConfs != rhs.minConfs {return false}
    if lhs.spendUnconfirmed != rhs.spendUnconfirmed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_EstimateFeeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EstimateFeeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fee_sat"),
    2: .standard(proto: "feerate_sat_per_byte"),
    3: .standard(proto: "sat_per_vbyte"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.feeSat) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.feerateSatPerByte) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.satPerVbyte) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.feeSat != 0 {
      try visitor.visitSingularInt64Field(value: self.feeSat, fieldNumber: 1)
    }
    if self.feerateSatPerByte != 0 {
      try visitor.visitSingularInt64Field(value: self.feerateSatPerByte, fieldNumber: 2)
    }
    if self.satPerVbyte != 0 {
      try visitor.visitSingularUInt64Field(value: self.satPerVbyte, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_EstimateFeeResponse, rhs: Lnrpc_EstimateFeeResponse) -> Bool {
    if lhs.feeSat != rhs.feeSat {return false}
    if lhs.feerateSatPerByte != rhs.feerateSatPerByte {return false}
    if lhs.satPerVbyte != rhs.satPerVbyte {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_SendManyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendManyRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AddrToAmount"),
    3: .standard(proto: "target_conf"),
    4: .standard(proto: "sat_per_vbyte"),
    5: .standard(proto: "sat_per_byte"),
    6: .same(proto: "label"),
    7: .standard(proto: "min_confs"),
    8: .standard(proto: "spend_unconfirmed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: &self.addrToAmount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.targetConf) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.satPerVbyte) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.satPerByte) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.minConfs) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.spendUnconfirmed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addrToAmount.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: self.addrToAmount, fieldNumber: 1)
    }
    if self.targetConf != 0 {
      try visitor.visitSingularInt32Field(value: self.targetConf, fieldNumber: 3)
    }
    if self.satPerVbyte != 0 {
      try visitor.visitSingularUInt64Field(value: self.satPerVbyte, fieldNumber: 4)
    }
    if self.satPerByte != 0 {
      try visitor.visitSingularInt64Field(value: self.satPerByte, fieldNumber: 5)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 6)
    }
    if self.minConfs != 0 {
      try visitor.visitSingularInt32Field(value: self.minConfs, fieldNumber: 7)
    }
    if self.spendUnconfirmed != false {
      try visitor.visitSingularBoolField(value: self.spendUnconfirmed, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_SendManyRequest, rhs: Lnrpc_SendManyRequest) -> Bool {
    if lhs.addrToAmount != rhs.addrToAmount {return false}
    if lhs.targetConf != rhs.targetConf {return false}
    if lhs.satPerVbyte != rhs.satPerVbyte {return false}
    if lhs.satPerByte != rhs.satPerByte {return false}
    if lhs.label != rhs.label {return false}
    if lhs.minConfs != rhs.minConfs {return false}
    if lhs.spendUnconfirmed != rhs.spendUnconfirmed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_SendManyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendManyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.txid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txid.isEmpty {
      try visitor.visitSingularStringField(value: self.txid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_SendManyResponse, rhs: Lnrpc_SendManyResponse) -> Bool {
    if lhs.txid != rhs.txid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_SendCoinsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendCoinsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addr"),
    2: .same(proto: "amount"),
    3: .standard(proto: "target_conf"),
    4: .standard(proto: "sat_per_vbyte"),
    5: .standard(proto: "sat_per_byte"),
    6: .standard(proto: "send_all"),
    7: .same(proto: "label"),
    8: .standard(proto: "min_confs"),
    9: .standard(proto: "spend_unconfirmed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.addr) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.targetConf) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.satPerVbyte) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.satPerByte) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.sendAll) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.minConfs) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.spendUnconfirmed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addr.isEmpty {
      try visitor.visitSingularStringField(value: self.addr, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    if self.targetConf != 0 {
      try visitor.visitSingularInt32Field(value: self.targetConf, fieldNumber: 3)
    }
    if self.satPerVbyte != 0 {
      try visitor.visitSingularUInt64Field(value: self.satPerVbyte, fieldNumber: 4)
    }
    if self.satPerByte != 0 {
      try visitor.visitSingularInt64Field(value: self.satPerByte, fieldNumber: 5)
    }
    if self.sendAll != false {
      try visitor.visitSingularBoolField(value: self.sendAll, fieldNumber: 6)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 7)
    }
    if self.minConfs != 0 {
      try visitor.visitSingularInt32Field(value: self.minConfs, fieldNumber: 8)
    }
    if self.spendUnconfirmed != false {
      try visitor.visitSingularBoolField(value: self.spendUnconfirmed, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_SendCoinsRequest, rhs: Lnrpc_SendCoinsRequest) -> Bool {
    if lhs.addr != rhs.addr {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.targetConf != rhs.targetConf {return false}
    if lhs.satPerVbyte != rhs.satPerVbyte {return false}
    if lhs.satPerByte != rhs.satPerByte {return false}
    if lhs.sendAll != rhs.sendAll {return false}
    if lhs.label != rhs.label {return false}
    if lhs.minConfs != rhs.minConfs {return false}
    if lhs.spendUnconfirmed != rhs.spendUnconfirmed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_SendCoinsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendCoinsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.txid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txid.isEmpty {
      try visitor.visitSingularStringField(value: self.txid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_SendCoinsResponse, rhs: Lnrpc_SendCoinsResponse) -> Bool {
    if lhs.txid != rhs.txid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ListUnspentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListUnspentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_confs"),
    2: .standard(proto: "max_confs"),
    3: .same(proto: "account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.minConfs) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxConfs) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.account) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minConfs != 0 {
      try visitor.visitSingularInt32Field(value: self.minConfs, fieldNumber: 1)
    }
    if self.maxConfs != 0 {
      try visitor.visitSingularInt32Field(value: self.maxConfs, fieldNumber: 2)
    }
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ListUnspentRequest, rhs: Lnrpc_ListUnspentRequest) -> Bool {
    if lhs.minConfs != rhs.minConfs {return false}
    if lhs.maxConfs != rhs.maxConfs {return false}
    if lhs.account != rhs.account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ListUnspentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListUnspentResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "utxos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.utxos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.utxos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.utxos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ListUnspentResponse, rhs: Lnrpc_ListUnspentResponse) -> Bool {
    if lhs.utxos != rhs.utxos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_NewAddressRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NewAddressRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.account) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .witnessPubkeyHash {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_NewAddressRequest, rhs: Lnrpc_NewAddressRequest) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.account != rhs.account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_NewAddressResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NewAddressResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_NewAddressResponse, rhs: Lnrpc_NewAddressResponse) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_SignMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignMessageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg"),
    2: .standard(proto: "single_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.msg) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.singleHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msg.isEmpty {
      try visitor.visitSingularBytesField(value: self.msg, fieldNumber: 1)
    }
    if self.singleHash != false {
      try visitor.visitSingularBoolField(value: self.singleHash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_SignMessageRequest, rhs: Lnrpc_SignMessageRequest) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs.singleHash != rhs.singleHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_SignMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignMessageResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.signature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_SignMessageResponse, rhs: Lnrpc_SignMessageResponse) -> Bool {
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_VerifyMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyMessageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg"),
    2: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.msg) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.signature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msg.isEmpty {
      try visitor.visitSingularBytesField(value: self.msg, fieldNumber: 1)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_VerifyMessageRequest, rhs: Lnrpc_VerifyMessageRequest) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_VerifyMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyMessageResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "valid"),
    2: .same(proto: "pubkey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.valid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pubkey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.valid != false {
      try visitor.visitSingularBoolField(value: self.valid, fieldNumber: 1)
    }
    if !self.pubkey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubkey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_VerifyMessageResponse, rhs: Lnrpc_VerifyMessageResponse) -> Bool {
    if lhs.valid != rhs.valid {return false}
    if lhs.pubkey != rhs.pubkey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ConnectPeerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectPeerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addr"),
    2: .same(proto: "perm"),
    3: .same(proto: "timeout"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._addr) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.perm) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.timeout) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._addr {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.perm != false {
      try visitor.visitSingularBoolField(value: self.perm, fieldNumber: 2)
    }
    if self.timeout != 0 {
      try visitor.visitSingularUInt64Field(value: self.timeout, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ConnectPeerRequest, rhs: Lnrpc_ConnectPeerRequest) -> Bool {
    if lhs._addr != rhs._addr {return false}
    if lhs.perm != rhs.perm {return false}
    if lhs.timeout != rhs.timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ConnectPeerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectPeerResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ConnectPeerResponse, rhs: Lnrpc_ConnectPeerResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_DisconnectPeerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisconnectPeerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pubKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_DisconnectPeerRequest, rhs: Lnrpc_DisconnectPeerRequest) -> Bool {
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_DisconnectPeerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisconnectPeerResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_DisconnectPeerResponse, rhs: Lnrpc_DisconnectPeerResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_HTLC: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HTLC"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "incoming"),
    2: .same(proto: "amount"),
    3: .standard(proto: "hash_lock"),
    4: .standard(proto: "expiration_height"),
    5: .standard(proto: "htlc_index"),
    6: .standard(proto: "forwarding_channel"),
    7: .standard(proto: "forwarding_htlc_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.incoming) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.hashLock) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.expirationHeight) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.htlcIndex) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.forwardingChannel) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.forwardingHtlcIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.incoming != false {
      try visitor.visitSingularBoolField(value: self.incoming, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    if !self.hashLock.isEmpty {
      try visitor.visitSingularBytesField(value: self.hashLock, fieldNumber: 3)
    }
    if self.expirationHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.expirationHeight, fieldNumber: 4)
    }
    if self.htlcIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.htlcIndex, fieldNumber: 5)
    }
    if self.forwardingChannel != 0 {
      try visitor.visitSingularUInt64Field(value: self.forwardingChannel, fieldNumber: 6)
    }
    if self.forwardingHtlcIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.forwardingHtlcIndex, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_HTLC, rhs: Lnrpc_HTLC) -> Bool {
    if lhs.incoming != rhs.incoming {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.hashLock != rhs.hashLock {return false}
    if lhs.expirationHeight != rhs.expirationHeight {return false}
    if lhs.htlcIndex != rhs.htlcIndex {return false}
    if lhs.forwardingChannel != rhs.forwardingChannel {return false}
    if lhs.forwardingHtlcIndex != rhs.forwardingHtlcIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelConstraints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelConstraints"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "csv_delay"),
    2: .standard(proto: "chan_reserve_sat"),
    3: .standard(proto: "dust_limit_sat"),
    4: .standard(proto: "max_pending_amt_msat"),
    5: .standard(proto: "min_htlc_msat"),
    6: .standard(proto: "max_accepted_htlcs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.csvDelay) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.chanReserveSat) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.dustLimitSat) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.maxPendingAmtMsat) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.minHtlcMsat) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.maxAcceptedHtlcs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.csvDelay != 0 {
      try visitor.visitSingularUInt32Field(value: self.csvDelay, fieldNumber: 1)
    }
    if self.chanReserveSat != 0 {
      try visitor.visitSingularUInt64Field(value: self.chanReserveSat, fieldNumber: 2)
    }
    if self.dustLimitSat != 0 {
      try visitor.visitSingularUInt64Field(value: self.dustLimitSat, fieldNumber: 3)
    }
    if self.maxPendingAmtMsat != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxPendingAmtMsat, fieldNumber: 4)
    }
    if self.minHtlcMsat != 0 {
      try visitor.visitSingularUInt64Field(value: self.minHtlcMsat, fieldNumber: 5)
    }
    if self.maxAcceptedHtlcs != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxAcceptedHtlcs, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelConstraints, rhs: Lnrpc_ChannelConstraints) -> Bool {
    if lhs.csvDelay != rhs.csvDelay {return false}
    if lhs.chanReserveSat != rhs.chanReserveSat {return false}
    if lhs.dustLimitSat != rhs.dustLimitSat {return false}
    if lhs.maxPendingAmtMsat != rhs.maxPendingAmtMsat {return false}
    if lhs.minHtlcMsat != rhs.minHtlcMsat {return false}
    if lhs.maxAcceptedHtlcs != rhs.maxAcceptedHtlcs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_Channel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Channel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "active"),
    2: .standard(proto: "remote_pubkey"),
    3: .standard(proto: "channel_point"),
    4: .standard(proto: "chan_id"),
    5: .same(proto: "capacity"),
    6: .standard(proto: "local_balance"),
    7: .standard(proto: "remote_balance"),
    8: .standard(proto: "commit_fee"),
    9: .standard(proto: "commit_weight"),
    10: .standard(proto: "fee_per_kw"),
    11: .standard(proto: "unsettled_balance"),
    12: .standard(proto: "total_satoshis_sent"),
    13: .standard(proto: "total_satoshis_received"),
    14: .standard(proto: "num_updates"),
    15: .standard(proto: "pending_htlcs"),
    16: .standard(proto: "csv_delay"),
    17: .same(proto: "private"),
    18: .same(proto: "initiator"),
    19: .standard(proto: "chan_status_flags"),
    20: .standard(proto: "local_chan_reserve_sat"),
    21: .standard(proto: "remote_chan_reserve_sat"),
    22: .standard(proto: "static_remote_key"),
    26: .standard(proto: "commitment_type"),
    23: .same(proto: "lifetime"),
    24: .same(proto: "uptime"),
    25: .standard(proto: "close_address"),
    27: .standard(proto: "push_amount_sat"),
    28: .standard(proto: "thaw_height"),
    29: .standard(proto: "local_constraints"),
    30: .standard(proto: "remote_constraints"),
  ]

  fileprivate class _StorageClass {
    var _active: Bool = false
    var _remotePubkey: String = String()
    var _channelPoint: String = String()
    var _chanID: UInt64 = 0
    var _capacity: Int64 = 0
    var _localBalance: Int64 = 0
    var _remoteBalance: Int64 = 0
    var _commitFee: Int64 = 0
    var _commitWeight: Int64 = 0
    var _feePerKw: Int64 = 0
    var _unsettledBalance: Int64 = 0
    var _totalSatoshisSent: Int64 = 0
    var _totalSatoshisReceived: Int64 = 0
    var _numUpdates: UInt64 = 0
    var _pendingHtlcs: [Lnrpc_HTLC] = []
    var _csvDelay: UInt32 = 0
    var _private: Bool = false
    var _initiator: Bool = false
    var _chanStatusFlags: String = String()
    var _localChanReserveSat: Int64 = 0
    var _remoteChanReserveSat: Int64 = 0
    var _staticRemoteKey: Bool = false
    var _commitmentType: Lnrpc_CommitmentType = .unknownCommitmentType
    var _lifetime: Int64 = 0
    var _uptime: Int64 = 0
    var _closeAddress: String = String()
    var _pushAmountSat: UInt64 = 0
    var _thawHeight: UInt32 = 0
    var _localConstraints: Lnrpc_ChannelConstraints? = nil
    var _remoteConstraints: Lnrpc_ChannelConstraints? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _active = source._active
      _remotePubkey = source._remotePubkey
      _channelPoint = source._channelPoint
      _chanID = source._chanID
      _capacity = source._capacity
      _localBalance = source._localBalance
      _remoteBalance = source._remoteBalance
      _commitFee = source._commitFee
      _commitWeight = source._commitWeight
      _feePerKw = source._feePerKw
      _unsettledBalance = source._unsettledBalance
      _totalSatoshisSent = source._totalSatoshisSent
      _totalSatoshisReceived = source._totalSatoshisReceived
      _numUpdates = source._numUpdates
      _pendingHtlcs = source._pendingHtlcs
      _csvDelay = source._csvDelay
      _private = source._private
      _initiator = source._initiator
      _chanStatusFlags = source._chanStatusFlags
      _localChanReserveSat = source._localChanReserveSat
      _remoteChanReserveSat = source._remoteChanReserveSat
      _staticRemoteKey = source._staticRemoteKey
      _commitmentType = source._commitmentType
      _lifetime = source._lifetime
      _uptime = source._uptime
      _closeAddress = source._closeAddress
      _pushAmountSat = source._pushAmountSat
      _thawHeight = source._thawHeight
      _localConstraints = source._localConstraints
      _remoteConstraints = source._remoteConstraints
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._active) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._remotePubkey) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._channelPoint) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._chanID) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._capacity) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._localBalance) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._remoteBalance) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._commitFee) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._commitWeight) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._feePerKw) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._unsettledBalance) }()
        case 12: try { try decoder.decodeSingularInt64Field(value: &_storage._totalSatoshisSent) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._totalSatoshisReceived) }()
        case 14: try { try decoder.decodeSingularUInt64Field(value: &_storage._numUpdates) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._pendingHtlcs) }()
        case 16: try { try decoder.decodeSingularUInt32Field(value: &_storage._csvDelay) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._private) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._initiator) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._chanStatusFlags) }()
        case 20: try { try decoder.decodeSingularInt64Field(value: &_storage._localChanReserveSat) }()
        case 21: try { try decoder.decodeSingularInt64Field(value: &_storage._remoteChanReserveSat) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._staticRemoteKey) }()
        case 23: try { try decoder.decodeSingularInt64Field(value: &_storage._lifetime) }()
        case 24: try { try decoder.decodeSingularInt64Field(value: &_storage._uptime) }()
        case 25: try { try decoder.decodeSingularStringField(value: &_storage._closeAddress) }()
        case 26: try { try decoder.decodeSingularEnumField(value: &_storage._commitmentType) }()
        case 27: try { try decoder.decodeSingularUInt64Field(value: &_storage._pushAmountSat) }()
        case 28: try { try decoder.decodeSingularUInt32Field(value: &_storage._thawHeight) }()
        case 29: try { try decoder.decodeSingularMessageField(value: &_storage._localConstraints) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._remoteConstraints) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._active != false {
        try visitor.visitSingularBoolField(value: _storage._active, fieldNumber: 1)
      }
      if !_storage._remotePubkey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._remotePubkey, fieldNumber: 2)
      }
      if !_storage._channelPoint.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelPoint, fieldNumber: 3)
      }
      if _storage._chanID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._chanID, fieldNumber: 4)
      }
      if _storage._capacity != 0 {
        try visitor.visitSingularInt64Field(value: _storage._capacity, fieldNumber: 5)
      }
      if _storage._localBalance != 0 {
        try visitor.visitSingularInt64Field(value: _storage._localBalance, fieldNumber: 6)
      }
      if _storage._remoteBalance != 0 {
        try visitor.visitSingularInt64Field(value: _storage._remoteBalance, fieldNumber: 7)
      }
      if _storage._commitFee != 0 {
        try visitor.visitSingularInt64Field(value: _storage._commitFee, fieldNumber: 8)
      }
      if _storage._commitWeight != 0 {
        try visitor.visitSingularInt64Field(value: _storage._commitWeight, fieldNumber: 9)
      }
      if _storage._feePerKw != 0 {
        try visitor.visitSingularInt64Field(value: _storage._feePerKw, fieldNumber: 10)
      }
      if _storage._unsettledBalance != 0 {
        try visitor.visitSingularInt64Field(value: _storage._unsettledBalance, fieldNumber: 11)
      }
      if _storage._totalSatoshisSent != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalSatoshisSent, fieldNumber: 12)
      }
      if _storage._totalSatoshisReceived != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalSatoshisReceived, fieldNumber: 13)
      }
      if _storage._numUpdates != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._numUpdates, fieldNumber: 14)
      }
      if !_storage._pendingHtlcs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pendingHtlcs, fieldNumber: 15)
      }
      if _storage._csvDelay != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._csvDelay, fieldNumber: 16)
      }
      if _storage._private != false {
        try visitor.visitSingularBoolField(value: _storage._private, fieldNumber: 17)
      }
      if _storage._initiator != false {
        try visitor.visitSingularBoolField(value: _storage._initiator, fieldNumber: 18)
      }
      if !_storage._chanStatusFlags.isEmpty {
        try visitor.visitSingularStringField(value: _storage._chanStatusFlags, fieldNumber: 19)
      }
      if _storage._localChanReserveSat != 0 {
        try visitor.visitSingularInt64Field(value: _storage._localChanReserveSat, fieldNumber: 20)
      }
      if _storage._remoteChanReserveSat != 0 {
        try visitor.visitSingularInt64Field(value: _storage._remoteChanReserveSat, fieldNumber: 21)
      }
      if _storage._staticRemoteKey != false {
        try visitor.visitSingularBoolField(value: _storage._staticRemoteKey, fieldNumber: 22)
      }
      if _storage._lifetime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._lifetime, fieldNumber: 23)
      }
      if _storage._uptime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._uptime, fieldNumber: 24)
      }
      if !_storage._closeAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._closeAddress, fieldNumber: 25)
      }
      if _storage._commitmentType != .unknownCommitmentType {
        try visitor.visitSingularEnumField(value: _storage._commitmentType, fieldNumber: 26)
      }
      if _storage._pushAmountSat != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._pushAmountSat, fieldNumber: 27)
      }
      if _storage._thawHeight != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._thawHeight, fieldNumber: 28)
      }
      if let v = _storage._localConstraints {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      }
      if let v = _storage._remoteConstraints {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_Channel, rhs: Lnrpc_Channel) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._active != rhs_storage._active {return false}
        if _storage._remotePubkey != rhs_storage._remotePubkey {return false}
        if _storage._channelPoint != rhs_storage._channelPoint {return false}
        if _storage._chanID != rhs_storage._chanID {return false}
        if _storage._capacity != rhs_storage._capacity {return false}
        if _storage._localBalance != rhs_storage._localBalance {return false}
        if _storage._remoteBalance != rhs_storage._remoteBalance {return false}
        if _storage._commitFee != rhs_storage._commitFee {return false}
        if _storage._commitWeight != rhs_storage._commitWeight {return false}
        if _storage._feePerKw != rhs_storage._feePerKw {return false}
        if _storage._unsettledBalance != rhs_storage._unsettledBalance {return false}
        if _storage._totalSatoshisSent != rhs_storage._totalSatoshisSent {return false}
        if _storage._totalSatoshisReceived != rhs_storage._totalSatoshisReceived {return false}
        if _storage._numUpdates != rhs_storage._numUpdates {return false}
        if _storage._pendingHtlcs != rhs_storage._pendingHtlcs {return false}
        if _storage._csvDelay != rhs_storage._csvDelay {return false}
        if _storage._private != rhs_storage._private {return false}
        if _storage._initiator != rhs_storage._initiator {return false}
        if _storage._chanStatusFlags != rhs_storage._chanStatusFlags {return false}
        if _storage._localChanReserveSat != rhs_storage._localChanReserveSat {return false}
        if _storage._remoteChanReserveSat != rhs_storage._remoteChanReserveSat {return false}
        if _storage._staticRemoteKey != rhs_storage._staticRemoteKey {return false}
        if _storage._commitmentType != rhs_storage._commitmentType {return false}
        if _storage._lifetime != rhs_storage._lifetime {return false}
        if _storage._uptime != rhs_storage._uptime {return false}
        if _storage._closeAddress != rhs_storage._closeAddress {return false}
        if _storage._pushAmountSat != rhs_storage._pushAmountSat {return false}
        if _storage._thawHeight != rhs_storage._thawHeight {return false}
        if _storage._localConstraints != rhs_storage._localConstraints {return false}
        if _storage._remoteConstraints != rhs_storage._remoteConstraints {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ListChannelsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListChannelsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "active_only"),
    2: .standard(proto: "inactive_only"),
    3: .standard(proto: "public_only"),
    4: .standard(proto: "private_only"),
    5: .same(proto: "peer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.activeOnly) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.inactiveOnly) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.publicOnly) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.privateOnly) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.peer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.activeOnly != false {
      try visitor.visitSingularBoolField(value: self.activeOnly, fieldNumber: 1)
    }
    if self.inactiveOnly != false {
      try visitor.visitSingularBoolField(value: self.inactiveOnly, fieldNumber: 2)
    }
    if self.publicOnly != false {
      try visitor.visitSingularBoolField(value: self.publicOnly, fieldNumber: 3)
    }
    if self.privateOnly != false {
      try visitor.visitSingularBoolField(value: self.privateOnly, fieldNumber: 4)
    }
    if !self.peer.isEmpty {
      try visitor.visitSingularBytesField(value: self.peer, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ListChannelsRequest, rhs: Lnrpc_ListChannelsRequest) -> Bool {
    if lhs.activeOnly != rhs.activeOnly {return false}
    if lhs.inactiveOnly != rhs.inactiveOnly {return false}
    if lhs.publicOnly != rhs.publicOnly {return false}
    if lhs.privateOnly != rhs.privateOnly {return false}
    if lhs.peer != rhs.peer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ListChannelsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListChannelsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    11: .same(proto: "channels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.channels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channels, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ListChannelsResponse, rhs: Lnrpc_ListChannelsResponse) -> Bool {
    if lhs.channels != rhs.channels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelCloseSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelCloseSummary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_point"),
    2: .standard(proto: "chan_id"),
    3: .standard(proto: "chain_hash"),
    4: .standard(proto: "closing_tx_hash"),
    5: .standard(proto: "remote_pubkey"),
    6: .same(proto: "capacity"),
    7: .standard(proto: "close_height"),
    8: .standard(proto: "settled_balance"),
    9: .standard(proto: "time_locked_balance"),
    10: .standard(proto: "close_type"),
    11: .standard(proto: "open_initiator"),
    12: .standard(proto: "close_initiator"),
    13: .same(proto: "resolutions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelPoint) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.chanID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.chainHash) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.closingTxHash) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.remotePubkey) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.capacity) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.closeHeight) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.settledBalance) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.timeLockedBalance) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.closeType) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.openInitiator) }()
      case 12: try { try decoder.decodeSingularEnumField(value: &self.closeInitiator) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.resolutions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelPoint.isEmpty {
      try visitor.visitSingularStringField(value: self.channelPoint, fieldNumber: 1)
    }
    if self.chanID != 0 {
      try visitor.visitSingularUInt64Field(value: self.chanID, fieldNumber: 2)
    }
    if !self.chainHash.isEmpty {
      try visitor.visitSingularStringField(value: self.chainHash, fieldNumber: 3)
    }
    if !self.closingTxHash.isEmpty {
      try visitor.visitSingularStringField(value: self.closingTxHash, fieldNumber: 4)
    }
    if !self.remotePubkey.isEmpty {
      try visitor.visitSingularStringField(value: self.remotePubkey, fieldNumber: 5)
    }
    if self.capacity != 0 {
      try visitor.visitSingularInt64Field(value: self.capacity, fieldNumber: 6)
    }
    if self.closeHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.closeHeight, fieldNumber: 7)
    }
    if self.settledBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.settledBalance, fieldNumber: 8)
    }
    if self.timeLockedBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.timeLockedBalance, fieldNumber: 9)
    }
    if self.closeType != .cooperativeClose {
      try visitor.visitSingularEnumField(value: self.closeType, fieldNumber: 10)
    }
    if self.openInitiator != .unknown {
      try visitor.visitSingularEnumField(value: self.openInitiator, fieldNumber: 11)
    }
    if self.closeInitiator != .unknown {
      try visitor.visitSingularEnumField(value: self.closeInitiator, fieldNumber: 12)
    }
    if !self.resolutions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resolutions, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelCloseSummary, rhs: Lnrpc_ChannelCloseSummary) -> Bool {
    if lhs.channelPoint != rhs.channelPoint {return false}
    if lhs.chanID != rhs.chanID {return false}
    if lhs.chainHash != rhs.chainHash {return false}
    if lhs.closingTxHash != rhs.closingTxHash {return false}
    if lhs.remotePubkey != rhs.remotePubkey {return false}
    if lhs.capacity != rhs.capacity {return false}
    if lhs.closeHeight != rhs.closeHeight {return false}
    if lhs.settledBalance != rhs.settledBalance {return false}
    if lhs.timeLockedBalance != rhs.timeLockedBalance {return false}
    if lhs.closeType != rhs.closeType {return false}
    if lhs.openInitiator != rhs.openInitiator {return false}
    if lhs.closeInitiator != rhs.closeInitiator {return false}
    if lhs.resolutions != rhs.resolutions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelCloseSummary.ClosureType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COOPERATIVE_CLOSE"),
    1: .same(proto: "LOCAL_FORCE_CLOSE"),
    2: .same(proto: "REMOTE_FORCE_CLOSE"),
    3: .same(proto: "BREACH_CLOSE"),
    4: .same(proto: "FUNDING_CANCELED"),
    5: .same(proto: "ABANDONED"),
  ]
}

extension Lnrpc_Resolution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Resolution"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resolution_type"),
    2: .same(proto: "outcome"),
    3: .same(proto: "outpoint"),
    4: .standard(proto: "amount_sat"),
    5: .standard(proto: "sweep_txid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.resolutionType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.outcome) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._outpoint) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.amountSat) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.sweepTxid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.resolutionType != .typeUnknown {
      try visitor.visitSingularEnumField(value: self.resolutionType, fieldNumber: 1)
    }
    if self.outcome != .outcomeUnknown {
      try visitor.visitSingularEnumField(value: self.outcome, fieldNumber: 2)
    }
    if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.amountSat != 0 {
      try visitor.visitSingularUInt64Field(value: self.amountSat, fieldNumber: 4)
    }
    if !self.sweepTxid.isEmpty {
      try visitor.visitSingularStringField(value: self.sweepTxid, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_Resolution, rhs: Lnrpc_Resolution) -> Bool {
    if lhs.resolutionType != rhs.resolutionType {return false}
    if lhs.outcome != rhs.outcome {return false}
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs.amountSat != rhs.amountSat {return false}
    if lhs.sweepTxid != rhs.sweepTxid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ClosedChannelsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClosedChannelsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cooperative"),
    2: .standard(proto: "local_force"),
    3: .standard(proto: "remote_force"),
    4: .same(proto: "breach"),
    5: .standard(proto: "funding_canceled"),
    6: .same(proto: "abandoned"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.cooperative) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.localForce) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.remoteForce) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.breach) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.fundingCanceled) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.abandoned) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cooperative != false {
      try visitor.visitSingularBoolField(value: self.cooperative, fieldNumber: 1)
    }
    if self.localForce != false {
      try visitor.visitSingularBoolField(value: self.localForce, fieldNumber: 2)
    }
    if self.remoteForce != false {
      try visitor.visitSingularBoolField(value: self.remoteForce, fieldNumber: 3)
    }
    if self.breach != false {
      try visitor.visitSingularBoolField(value: self.breach, fieldNumber: 4)
    }
    if self.fundingCanceled != false {
      try visitor.visitSingularBoolField(value: self.fundingCanceled, fieldNumber: 5)
    }
    if self.abandoned != false {
      try visitor.visitSingularBoolField(value: self.abandoned, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ClosedChannelsRequest, rhs: Lnrpc_ClosedChannelsRequest) -> Bool {
    if lhs.cooperative != rhs.cooperative {return false}
    if lhs.localForce != rhs.localForce {return false}
    if lhs.remoteForce != rhs.remoteForce {return false}
    if lhs.breach != rhs.breach {return false}
    if lhs.fundingCanceled != rhs.fundingCanceled {return false}
    if lhs.abandoned != rhs.abandoned {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ClosedChannelsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClosedChannelsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.channels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channels, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ClosedChannelsResponse, rhs: Lnrpc_ClosedChannelsResponse) -> Bool {
    if lhs.channels != rhs.channels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_Peer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Peer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key"),
    3: .same(proto: "address"),
    4: .standard(proto: "bytes_sent"),
    5: .standard(proto: "bytes_recv"),
    6: .standard(proto: "sat_sent"),
    7: .standard(proto: "sat_recv"),
    8: .same(proto: "inbound"),
    9: .standard(proto: "ping_time"),
    10: .standard(proto: "sync_type"),
    11: .same(proto: "features"),
    12: .same(proto: "errors"),
    13: .standard(proto: "flap_count"),
    14: .standard(proto: "last_flap_ns"),
    15: .standard(proto: "last_ping_payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pubKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.bytesSent) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.bytesRecv) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.satSent) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.satRecv) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.inbound) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.pingTime) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.syncType) }()
      case 11: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Lnrpc_Feature>.self, value: &self.features) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &self.flapCount) }()
      case 14: try { try decoder.decodeSingularInt64Field(value: &self.lastFlapNs) }()
      case 15: try { try decoder.decodeSingularBytesField(value: &self.lastPingPayload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 3)
    }
    if self.bytesSent != 0 {
      try visitor.visitSingularUInt64Field(value: self.bytesSent, fieldNumber: 4)
    }
    if self.bytesRecv != 0 {
      try visitor.visitSingularUInt64Field(value: self.bytesRecv, fieldNumber: 5)
    }
    if self.satSent != 0 {
      try visitor.visitSingularInt64Field(value: self.satSent, fieldNumber: 6)
    }
    if self.satRecv != 0 {
      try visitor.visitSingularInt64Field(value: self.satRecv, fieldNumber: 7)
    }
    if self.inbound != false {
      try visitor.visitSingularBoolField(value: self.inbound, fieldNumber: 8)
    }
    if self.pingTime != 0 {
      try visitor.visitSingularInt64Field(value: self.pingTime, fieldNumber: 9)
    }
    if self.syncType != .unknownSync {
      try visitor.visitSingularEnumField(value: self.syncType, fieldNumber: 10)
    }
    if !self.features.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Lnrpc_Feature>.self, value: self.features, fieldNumber: 11)
    }
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 12)
    }
    if self.flapCount != 0 {
      try visitor.visitSingularInt32Field(value: self.flapCount, fieldNumber: 13)
    }
    if self.lastFlapNs != 0 {
      try visitor.visitSingularInt64Field(value: self.lastFlapNs, fieldNumber: 14)
    }
    if !self.lastPingPayload.isEmpty {
      try visitor.visitSingularBytesField(value: self.lastPingPayload, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_Peer, rhs: Lnrpc_Peer) -> Bool {
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.address != rhs.address {return false}
    if lhs.bytesSent != rhs.bytesSent {return false}
    if lhs.bytesRecv != rhs.bytesRecv {return false}
    if lhs.satSent != rhs.satSent {return false}
    if lhs.satRecv != rhs.satRecv {return false}
    if lhs.inbound != rhs.inbound {return false}
    if lhs.pingTime != rhs.pingTime {return false}
    if lhs.syncType != rhs.syncType {return false}
    if lhs.features != rhs.features {return false}
    if lhs.errors != rhs.errors {return false}
    if lhs.flapCount != rhs.flapCount {return false}
    if lhs.lastFlapNs != rhs.lastFlapNs {return false}
    if lhs.lastPingPayload != rhs.lastPingPayload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_Peer.SyncType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_SYNC"),
    1: .same(proto: "ACTIVE_SYNC"),
    2: .same(proto: "PASSIVE_SYNC"),
    3: .same(proto: "PINNED_SYNC"),
  ]
}

extension Lnrpc_TimestampedError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TimestampedError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_TimestampedError, rhs: Lnrpc_TimestampedError) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ListPeersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPeersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "latest_error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.latestError) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.latestError != false {
      try visitor.visitSingularBoolField(value: self.latestError, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ListPeersRequest, rhs: Lnrpc_ListPeersRequest) -> Bool {
    if lhs.latestError != rhs.latestError {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ListPeersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPeersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "peers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.peers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.peers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.peers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ListPeersResponse, rhs: Lnrpc_ListPeersResponse) -> Bool {
    if lhs.peers != rhs.peers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PeerEventSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PeerEventSubscription"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PeerEventSubscription, rhs: Lnrpc_PeerEventSubscription) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PeerEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PeerEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key"),
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pubKey) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 1)
    }
    if self.type != .peerOnline {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PeerEvent, rhs: Lnrpc_PeerEvent) -> Bool {
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PeerEvent.EventType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PEER_ONLINE"),
    1: .same(proto: "PEER_OFFLINE"),
  ]
}

extension Lnrpc_GetInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_GetInfoRequest, rhs: Lnrpc_GetInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_GetInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    14: .same(proto: "version"),
    20: .standard(proto: "commit_hash"),
    1: .standard(proto: "identity_pubkey"),
    2: .same(proto: "alias"),
    17: .same(proto: "color"),
    3: .standard(proto: "num_pending_channels"),
    4: .standard(proto: "num_active_channels"),
    15: .standard(proto: "num_inactive_channels"),
    5: .standard(proto: "num_peers"),
    6: .standard(proto: "block_height"),
    8: .standard(proto: "block_hash"),
    13: .standard(proto: "best_header_timestamp"),
    9: .standard(proto: "synced_to_chain"),
    18: .standard(proto: "synced_to_graph"),
    10: .same(proto: "testnet"),
    16: .same(proto: "chains"),
    12: .same(proto: "uris"),
    19: .same(proto: "features"),
  ]

  fileprivate class _StorageClass {
    var _version: String = String()
    var _commitHash: String = String()
    var _identityPubkey: String = String()
    var _alias: String = String()
    var _color: String = String()
    var _numPendingChannels: UInt32 = 0
    var _numActiveChannels: UInt32 = 0
    var _numInactiveChannels: UInt32 = 0
    var _numPeers: UInt32 = 0
    var _blockHeight: UInt32 = 0
    var _blockHash: String = String()
    var _bestHeaderTimestamp: Int64 = 0
    var _syncedToChain: Bool = false
    var _syncedToGraph: Bool = false
    var _testnet: Bool = false
    var _chains: [Lnrpc_Chain] = []
    var _uris: [String] = []
    var _features: Dictionary<UInt32,Lnrpc_Feature> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _version = source._version
      _commitHash = source._commitHash
      _identityPubkey = source._identityPubkey
      _alias = source._alias
      _color = source._color
      _numPendingChannels = source._numPendingChannels
      _numActiveChannels = source._numActiveChannels
      _numInactiveChannels = source._numInactiveChannels
      _numPeers = source._numPeers
      _blockHeight = source._blockHeight
      _blockHash = source._blockHash
      _bestHeaderTimestamp = source._bestHeaderTimestamp
      _syncedToChain = source._syncedToChain
      _syncedToGraph = source._syncedToGraph
      _testnet = source._testnet
      _chains = source._chains
      _uris = source._uris
      _features = source._features
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._identityPubkey) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._alias) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._numPendingChannels) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._numActiveChannels) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._numPeers) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._blockHeight) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._blockHash) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._syncedToChain) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._testnet) }()
        case 12: try { try decoder.decodeRepeatedStringField(value: &_storage._uris) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._bestHeaderTimestamp) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 15: try { try decoder.decodeSingularUInt32Field(value: &_storage._numInactiveChannels) }()
        case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._chains) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._color) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._syncedToGraph) }()
        case 19: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Lnrpc_Feature>.self, value: &_storage._features) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._commitHash) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._identityPubkey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._identityPubkey, fieldNumber: 1)
      }
      if !_storage._alias.isEmpty {
        try visitor.visitSingularStringField(value: _storage._alias, fieldNumber: 2)
      }
      if _storage._numPendingChannels != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numPendingChannels, fieldNumber: 3)
      }
      if _storage._numActiveChannels != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numActiveChannels, fieldNumber: 4)
      }
      if _storage._numPeers != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numPeers, fieldNumber: 5)
      }
      if _storage._blockHeight != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._blockHeight, fieldNumber: 6)
      }
      if !_storage._blockHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._blockHash, fieldNumber: 8)
      }
      if _storage._syncedToChain != false {
        try visitor.visitSingularBoolField(value: _storage._syncedToChain, fieldNumber: 9)
      }
      if _storage._testnet != false {
        try visitor.visitSingularBoolField(value: _storage._testnet, fieldNumber: 10)
      }
      if !_storage._uris.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._uris, fieldNumber: 12)
      }
      if _storage._bestHeaderTimestamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._bestHeaderTimestamp, fieldNumber: 13)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 14)
      }
      if _storage._numInactiveChannels != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numInactiveChannels, fieldNumber: 15)
      }
      if !_storage._chains.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._chains, fieldNumber: 16)
      }
      if !_storage._color.isEmpty {
        try visitor.visitSingularStringField(value: _storage._color, fieldNumber: 17)
      }
      if _storage._syncedToGraph != false {
        try visitor.visitSingularBoolField(value: _storage._syncedToGraph, fieldNumber: 18)
      }
      if !_storage._features.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Lnrpc_Feature>.self, value: _storage._features, fieldNumber: 19)
      }
      if !_storage._commitHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._commitHash, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_GetInfoResponse, rhs: Lnrpc_GetInfoResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._version != rhs_storage._version {return false}
        if _storage._commitHash != rhs_storage._commitHash {return false}
        if _storage._identityPubkey != rhs_storage._identityPubkey {return false}
        if _storage._alias != rhs_storage._alias {return false}
        if _storage._color != rhs_storage._color {return false}
        if _storage._numPendingChannels != rhs_storage._numPendingChannels {return false}
        if _storage._numActiveChannels != rhs_storage._numActiveChannels {return false}
        if _storage._numInactiveChannels != rhs_storage._numInactiveChannels {return false}
        if _storage._numPeers != rhs_storage._numPeers {return false}
        if _storage._blockHeight != rhs_storage._blockHeight {return false}
        if _storage._blockHash != rhs_storage._blockHash {return false}
        if _storage._bestHeaderTimestamp != rhs_storage._bestHeaderTimestamp {return false}
        if _storage._syncedToChain != rhs_storage._syncedToChain {return false}
        if _storage._syncedToGraph != rhs_storage._syncedToGraph {return false}
        if _storage._testnet != rhs_storage._testnet {return false}
        if _storage._chains != rhs_storage._chains {return false}
        if _storage._uris != rhs_storage._uris {return false}
        if _storage._features != rhs_storage._features {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_GetRecoveryInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetRecoveryInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_GetRecoveryInfoRequest, rhs: Lnrpc_GetRecoveryInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_GetRecoveryInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetRecoveryInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "recovery_mode"),
    2: .standard(proto: "recovery_finished"),
    3: .same(proto: "progress"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.recoveryMode) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.recoveryFinished) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.progress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.recoveryMode != false {
      try visitor.visitSingularBoolField(value: self.recoveryMode, fieldNumber: 1)
    }
    if self.recoveryFinished != false {
      try visitor.visitSingularBoolField(value: self.recoveryFinished, fieldNumber: 2)
    }
    if self.progress != 0 {
      try visitor.visitSingularDoubleField(value: self.progress, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_GetRecoveryInfoResponse, rhs: Lnrpc_GetRecoveryInfoResponse) -> Bool {
    if lhs.recoveryMode != rhs.recoveryMode {return false}
    if lhs.recoveryFinished != rhs.recoveryFinished {return false}
    if lhs.progress != rhs.progress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_Chain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Chain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chain"),
    2: .same(proto: "network"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.network) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 1)
    }
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_Chain, rhs: Lnrpc_Chain) -> Bool {
    if lhs.chain != rhs.chain {return false}
    if lhs.network != rhs.network {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ConfirmationUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfirmationUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_sha"),
    2: .standard(proto: "block_height"),
    3: .standard(proto: "num_confs_left"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.blockSha) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.blockHeight) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.numConfsLeft) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blockSha.isEmpty {
      try visitor.visitSingularBytesField(value: self.blockSha, fieldNumber: 1)
    }
    if self.blockHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.blockHeight, fieldNumber: 2)
    }
    if self.numConfsLeft != 0 {
      try visitor.visitSingularUInt32Field(value: self.numConfsLeft, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ConfirmationUpdate, rhs: Lnrpc_ConfirmationUpdate) -> Bool {
    if lhs.blockSha != rhs.blockSha {return false}
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs.numConfsLeft != rhs.numConfsLeft {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelOpenUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelOpenUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_point"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._channelPoint) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._channelPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelOpenUpdate, rhs: Lnrpc_ChannelOpenUpdate) -> Bool {
    if lhs._channelPoint != rhs._channelPoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelCloseUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelCloseUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "closing_txid"),
    2: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.closingTxid) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.closingTxid.isEmpty {
      try visitor.visitSingularBytesField(value: self.closingTxid, fieldNumber: 1)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelCloseUpdate, rhs: Lnrpc_ChannelCloseUpdate) -> Bool {
    if lhs.closingTxid != rhs.closingTxid {return false}
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_CloseChannelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CloseChannelRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_point"),
    2: .same(proto: "force"),
    3: .standard(proto: "target_conf"),
    4: .standard(proto: "sat_per_byte"),
    5: .standard(proto: "delivery_address"),
    6: .standard(proto: "sat_per_vbyte"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._channelPoint) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.targetConf) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.satPerByte) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.deliveryAddress) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.satPerVbyte) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._channelPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 2)
    }
    if self.targetConf != 0 {
      try visitor.visitSingularInt32Field(value: self.targetConf, fieldNumber: 3)
    }
    if self.satPerByte != 0 {
      try visitor.visitSingularInt64Field(value: self.satPerByte, fieldNumber: 4)
    }
    if !self.deliveryAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.deliveryAddress, fieldNumber: 5)
    }
    if self.satPerVbyte != 0 {
      try visitor.visitSingularUInt64Field(value: self.satPerVbyte, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_CloseChannelRequest, rhs: Lnrpc_CloseChannelRequest) -> Bool {
    if lhs._channelPoint != rhs._channelPoint {return false}
    if lhs.force != rhs.force {return false}
    if lhs.targetConf != rhs.targetConf {return false}
    if lhs.satPerByte != rhs.satPerByte {return false}
    if lhs.deliveryAddress != rhs.deliveryAddress {return false}
    if lhs.satPerVbyte != rhs.satPerVbyte {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_CloseStatusUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CloseStatusUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "close_pending"),
    3: .standard(proto: "chan_close"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Lnrpc_PendingUpdate?
        if let current = self.update {
          try decoder.handleConflictingOneOf()
          if case .closePending(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.update = .closePending(v)}
      }()
      case 3: try {
        var v: Lnrpc_ChannelCloseUpdate?
        if let current = self.update {
          try decoder.handleConflictingOneOf()
          if case .chanClose(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.update = .chanClose(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.update {
    case .closePending?: try {
      guard case .closePending(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .chanClose?: try {
      guard case .chanClose(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_CloseStatusUpdate, rhs: Lnrpc_CloseStatusUpdate) -> Bool {
    if lhs.update != rhs.update {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PendingUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txid"),
    2: .standard(proto: "output_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.outputIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 1)
    }
    if self.outputIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.outputIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PendingUpdate, rhs: Lnrpc_PendingUpdate) -> Bool {
    if lhs.txid != rhs.txid {return false}
    if lhs.outputIndex != rhs.outputIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ReadyForPsbtFunding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadyForPsbtFunding"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "funding_address"),
    2: .standard(proto: "funding_amount"),
    3: .same(proto: "psbt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fundingAddress) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.fundingAmount) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.psbt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fundingAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.fundingAddress, fieldNumber: 1)
    }
    if self.fundingAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.fundingAmount, fieldNumber: 2)
    }
    if !self.psbt.isEmpty {
      try visitor.visitSingularBytesField(value: self.psbt, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ReadyForPsbtFunding, rhs: Lnrpc_ReadyForPsbtFunding) -> Bool {
    if lhs.fundingAddress != rhs.fundingAddress {return false}
    if lhs.fundingAmount != rhs.fundingAmount {return false}
    if lhs.psbt != rhs.psbt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_BatchOpenChannelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchOpenChannelRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channels"),
    2: .standard(proto: "target_conf"),
    3: .standard(proto: "sat_per_vbyte"),
    4: .standard(proto: "min_confs"),
    5: .standard(proto: "spend_unconfirmed"),
    6: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.channels) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.targetConf) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.satPerVbyte) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.minConfs) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.spendUnconfirmed) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channels, fieldNumber: 1)
    }
    if self.targetConf != 0 {
      try visitor.visitSingularInt32Field(value: self.targetConf, fieldNumber: 2)
    }
    if self.satPerVbyte != 0 {
      try visitor.visitSingularInt64Field(value: self.satPerVbyte, fieldNumber: 3)
    }
    if self.minConfs != 0 {
      try visitor.visitSingularInt32Field(value: self.minConfs, fieldNumber: 4)
    }
    if self.spendUnconfirmed != false {
      try visitor.visitSingularBoolField(value: self.spendUnconfirmed, fieldNumber: 5)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_BatchOpenChannelRequest, rhs: Lnrpc_BatchOpenChannelRequest) -> Bool {
    if lhs.channels != rhs.channels {return false}
    if lhs.targetConf != rhs.targetConf {return false}
    if lhs.satPerVbyte != rhs.satPerVbyte {return false}
    if lhs.minConfs != rhs.minConfs {return false}
    if lhs.spendUnconfirmed != rhs.spendUnconfirmed {return false}
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_BatchOpenChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchOpenChannel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_pubkey"),
    2: .standard(proto: "local_funding_amount"),
    3: .standard(proto: "push_sat"),
    4: .same(proto: "private"),
    5: .standard(proto: "min_htlc_msat"),
    6: .standard(proto: "remote_csv_delay"),
    7: .standard(proto: "close_address"),
    8: .standard(proto: "pending_chan_id"),
    9: .standard(proto: "commitment_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.nodePubkey) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.localFundingAmount) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pushSat) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.`private`) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.minHtlcMsat) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.remoteCsvDelay) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.closeAddress) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.pendingChanID) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.commitmentType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodePubkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.nodePubkey, fieldNumber: 1)
    }
    if self.localFundingAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.localFundingAmount, fieldNumber: 2)
    }
    if self.pushSat != 0 {
      try visitor.visitSingularInt64Field(value: self.pushSat, fieldNumber: 3)
    }
    if self.`private` != false {
      try visitor.visitSingularBoolField(value: self.`private`, fieldNumber: 4)
    }
    if self.minHtlcMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.minHtlcMsat, fieldNumber: 5)
    }
    if self.remoteCsvDelay != 0 {
      try visitor.visitSingularUInt32Field(value: self.remoteCsvDelay, fieldNumber: 6)
    }
    if !self.closeAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.closeAddress, fieldNumber: 7)
    }
    if !self.pendingChanID.isEmpty {
      try visitor.visitSingularBytesField(value: self.pendingChanID, fieldNumber: 8)
    }
    if self.commitmentType != .unknownCommitmentType {
      try visitor.visitSingularEnumField(value: self.commitmentType, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_BatchOpenChannel, rhs: Lnrpc_BatchOpenChannel) -> Bool {
    if lhs.nodePubkey != rhs.nodePubkey {return false}
    if lhs.localFundingAmount != rhs.localFundingAmount {return false}
    if lhs.pushSat != rhs.pushSat {return false}
    if lhs.`private` != rhs.`private` {return false}
    if lhs.minHtlcMsat != rhs.minHtlcMsat {return false}
    if lhs.remoteCsvDelay != rhs.remoteCsvDelay {return false}
    if lhs.closeAddress != rhs.closeAddress {return false}
    if lhs.pendingChanID != rhs.pendingChanID {return false}
    if lhs.commitmentType != rhs.commitmentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_BatchOpenChannelResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchOpenChannelResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pending_channels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pendingChannels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pendingChannels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pendingChannels, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_BatchOpenChannelResponse, rhs: Lnrpc_BatchOpenChannelResponse) -> Bool {
    if lhs.pendingChannels != rhs.pendingChannels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_OpenChannelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpenChannelRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sat_per_vbyte"),
    2: .standard(proto: "node_pubkey"),
    3: .standard(proto: "node_pubkey_string"),
    4: .standard(proto: "local_funding_amount"),
    5: .standard(proto: "push_sat"),
    6: .standard(proto: "target_conf"),
    7: .standard(proto: "sat_per_byte"),
    8: .same(proto: "private"),
    9: .standard(proto: "min_htlc_msat"),
    10: .standard(proto: "remote_csv_delay"),
    11: .standard(proto: "min_confs"),
    12: .standard(proto: "spend_unconfirmed"),
    13: .standard(proto: "close_address"),
    14: .standard(proto: "funding_shim"),
    15: .standard(proto: "remote_max_value_in_flight_msat"),
    16: .standard(proto: "remote_max_htlcs"),
    17: .standard(proto: "max_local_csv"),
    18: .standard(proto: "commitment_type"),
  ]

  fileprivate class _StorageClass {
    var _satPerVbyte: UInt64 = 0
    var _nodePubkey: Data = Data()
    var _nodePubkeyString: String = String()
    var _localFundingAmount: Int64 = 0
    var _pushSat: Int64 = 0
    var _targetConf: Int32 = 0
    var _satPerByte: Int64 = 0
    var _private: Bool = false
    var _minHtlcMsat: Int64 = 0
    var _remoteCsvDelay: UInt32 = 0
    var _minConfs: Int32 = 0
    var _spendUnconfirmed: Bool = false
    var _closeAddress: String = String()
    var _fundingShim: Lnrpc_FundingShim? = nil
    var _remoteMaxValueInFlightMsat: UInt64 = 0
    var _remoteMaxHtlcs: UInt32 = 0
    var _maxLocalCsv: UInt32 = 0
    var _commitmentType: Lnrpc_CommitmentType = .unknownCommitmentType

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _satPerVbyte = source._satPerVbyte
      _nodePubkey = source._nodePubkey
      _nodePubkeyString = source._nodePubkeyString
      _localFundingAmount = source._localFundingAmount
      _pushSat = source._pushSat
      _targetConf = source._targetConf
      _satPerByte = source._satPerByte
      _private = source._private
      _minHtlcMsat = source._minHtlcMsat
      _remoteCsvDelay = source._remoteCsvDelay
      _minConfs = source._minConfs
      _spendUnconfirmed = source._spendUnconfirmed
      _closeAddress = source._closeAddress
      _fundingShim = source._fundingShim
      _remoteMaxValueInFlightMsat = source._remoteMaxValueInFlightMsat
      _remoteMaxHtlcs = source._remoteMaxHtlcs
      _maxLocalCsv = source._maxLocalCsv
      _commitmentType = source._commitmentType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._satPerVbyte) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._nodePubkey) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._nodePubkeyString) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._localFundingAmount) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._pushSat) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._targetConf) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._satPerByte) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._private) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._minHtlcMsat) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._remoteCsvDelay) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._minConfs) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._spendUnconfirmed) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._closeAddress) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._fundingShim) }()
        case 15: try { try decoder.decodeSingularUInt64Field(value: &_storage._remoteMaxValueInFlightMsat) }()
        case 16: try { try decoder.decodeSingularUInt32Field(value: &_storage._remoteMaxHtlcs) }()
        case 17: try { try decoder.decodeSingularUInt32Field(value: &_storage._maxLocalCsv) }()
        case 18: try { try decoder.decodeSingularEnumField(value: &_storage._commitmentType) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._satPerVbyte != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._satPerVbyte, fieldNumber: 1)
      }
      if !_storage._nodePubkey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._nodePubkey, fieldNumber: 2)
      }
      if !_storage._nodePubkeyString.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nodePubkeyString, fieldNumber: 3)
      }
      if _storage._localFundingAmount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._localFundingAmount, fieldNumber: 4)
      }
      if _storage._pushSat != 0 {
        try visitor.visitSingularInt64Field(value: _storage._pushSat, fieldNumber: 5)
      }
      if _storage._targetConf != 0 {
        try visitor.visitSingularInt32Field(value: _storage._targetConf, fieldNumber: 6)
      }
      if _storage._satPerByte != 0 {
        try visitor.visitSingularInt64Field(value: _storage._satPerByte, fieldNumber: 7)
      }
      if _storage._private != false {
        try visitor.visitSingularBoolField(value: _storage._private, fieldNumber: 8)
      }
      if _storage._minHtlcMsat != 0 {
        try visitor.visitSingularInt64Field(value: _storage._minHtlcMsat, fieldNumber: 9)
      }
      if _storage._remoteCsvDelay != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._remoteCsvDelay, fieldNumber: 10)
      }
      if _storage._minConfs != 0 {
        try visitor.visitSingularInt32Field(value: _storage._minConfs, fieldNumber: 11)
      }
      if _storage._spendUnconfirmed != false {
        try visitor.visitSingularBoolField(value: _storage._spendUnconfirmed, fieldNumber: 12)
      }
      if !_storage._closeAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._closeAddress, fieldNumber: 13)
      }
      if let v = _storage._fundingShim {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if _storage._remoteMaxValueInFlightMsat != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._remoteMaxValueInFlightMsat, fieldNumber: 15)
      }
      if _storage._remoteMaxHtlcs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._remoteMaxHtlcs, fieldNumber: 16)
      }
      if _storage._maxLocalCsv != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._maxLocalCsv, fieldNumber: 17)
      }
      if _storage._commitmentType != .unknownCommitmentType {
        try visitor.visitSingularEnumField(value: _storage._commitmentType, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_OpenChannelRequest, rhs: Lnrpc_OpenChannelRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._satPerVbyte != rhs_storage._satPerVbyte {return false}
        if _storage._nodePubkey != rhs_storage._nodePubkey {return false}
        if _storage._nodePubkeyString != rhs_storage._nodePubkeyString {return false}
        if _storage._localFundingAmount != rhs_storage._localFundingAmount {return false}
        if _storage._pushSat != rhs_storage._pushSat {return false}
        if _storage._targetConf != rhs_storage._targetConf {return false}
        if _storage._satPerByte != rhs_storage._satPerByte {return false}
        if _storage._private != rhs_storage._private {return false}
        if _storage._minHtlcMsat != rhs_storage._minHtlcMsat {return false}
        if _storage._remoteCsvDelay != rhs_storage._remoteCsvDelay {return false}
        if _storage._minConfs != rhs_storage._minConfs {return false}
        if _storage._spendUnconfirmed != rhs_storage._spendUnconfirmed {return false}
        if _storage._closeAddress != rhs_storage._closeAddress {return false}
        if _storage._fundingShim != rhs_storage._fundingShim {return false}
        if _storage._remoteMaxValueInFlightMsat != rhs_storage._remoteMaxValueInFlightMsat {return false}
        if _storage._remoteMaxHtlcs != rhs_storage._remoteMaxHtlcs {return false}
        if _storage._maxLocalCsv != rhs_storage._maxLocalCsv {return false}
        if _storage._commitmentType != rhs_storage._commitmentType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_OpenStatusUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpenStatusUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chan_pending"),
    3: .standard(proto: "chan_open"),
    5: .standard(proto: "psbt_fund"),
    4: .standard(proto: "pending_chan_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Lnrpc_PendingUpdate?
        if let current = self.update {
          try decoder.handleConflictingOneOf()
          if case .chanPending(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.update = .chanPending(v)}
      }()
      case 3: try {
        var v: Lnrpc_ChannelOpenUpdate?
        if let current = self.update {
          try decoder.handleConflictingOneOf()
          if case .chanOpen(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.update = .chanOpen(v)}
      }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.pendingChanID) }()
      case 5: try {
        var v: Lnrpc_ReadyForPsbtFunding?
        if let current = self.update {
          try decoder.handleConflictingOneOf()
          if case .psbtFund(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.update = .psbtFund(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.update {
    case .chanPending?: try {
      guard case .chanPending(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .chanOpen?: try {
      guard case .chanOpen(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    default: break
    }
    if !self.pendingChanID.isEmpty {
      try visitor.visitSingularBytesField(value: self.pendingChanID, fieldNumber: 4)
    }
    if case .psbtFund(let v)? = self.update {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_OpenStatusUpdate, rhs: Lnrpc_OpenStatusUpdate) -> Bool {
    if lhs.update != rhs.update {return false}
    if lhs.pendingChanID != rhs.pendingChanID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_KeyLocator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyLocator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_family"),
    2: .standard(proto: "key_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.keyFamily) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.keyIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.keyFamily != 0 {
      try visitor.visitSingularInt32Field(value: self.keyFamily, fieldNumber: 1)
    }
    if self.keyIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.keyIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_KeyLocator, rhs: Lnrpc_KeyLocator) -> Bool {
    if lhs.keyFamily != rhs.keyFamily {return false}
    if lhs.keyIndex != rhs.keyIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_KeyDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_key_bytes"),
    2: .standard(proto: "key_loc"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.rawKeyBytes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._keyLoc) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rawKeyBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawKeyBytes, fieldNumber: 1)
    }
    if let v = self._keyLoc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_KeyDescriptor, rhs: Lnrpc_KeyDescriptor) -> Bool {
    if lhs.rawKeyBytes != rhs.rawKeyBytes {return false}
    if lhs._keyLoc != rhs._keyLoc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChanPointShim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChanPointShim"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amt"),
    2: .standard(proto: "chan_point"),
    3: .standard(proto: "local_key"),
    4: .standard(proto: "remote_key"),
    5: .standard(proto: "pending_chan_id"),
    6: .standard(proto: "thaw_height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.amt) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._chanPoint) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._localKey) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.remoteKey) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.pendingChanID) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.thawHeight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.amt != 0 {
      try visitor.visitSingularInt64Field(value: self.amt, fieldNumber: 1)
    }
    if let v = self._chanPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._localKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.remoteKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.remoteKey, fieldNumber: 4)
    }
    if !self.pendingChanID.isEmpty {
      try visitor.visitSingularBytesField(value: self.pendingChanID, fieldNumber: 5)
    }
    if self.thawHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.thawHeight, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChanPointShim, rhs: Lnrpc_ChanPointShim) -> Bool {
    if lhs.amt != rhs.amt {return false}
    if lhs._chanPoint != rhs._chanPoint {return false}
    if lhs._localKey != rhs._localKey {return false}
    if lhs.remoteKey != rhs.remoteKey {return false}
    if lhs.pendingChanID != rhs.pendingChanID {return false}
    if lhs.thawHeight != rhs.thawHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PsbtShim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PsbtShim"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pending_chan_id"),
    2: .standard(proto: "base_psbt"),
    3: .standard(proto: "no_publish"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.pendingChanID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.basePsbt) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.noPublish) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pendingChanID.isEmpty {
      try visitor.visitSingularBytesField(value: self.pendingChanID, fieldNumber: 1)
    }
    if !self.basePsbt.isEmpty {
      try visitor.visitSingularBytesField(value: self.basePsbt, fieldNumber: 2)
    }
    if self.noPublish != false {
      try visitor.visitSingularBoolField(value: self.noPublish, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PsbtShim, rhs: Lnrpc_PsbtShim) -> Bool {
    if lhs.pendingChanID != rhs.pendingChanID {return false}
    if lhs.basePsbt != rhs.basePsbt {return false}
    if lhs.noPublish != rhs.noPublish {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_FundingShim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FundingShim"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chan_point_shim"),
    2: .standard(proto: "psbt_shim"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Lnrpc_ChanPointShim?
        if let current = self.shim {
          try decoder.handleConflictingOneOf()
          if case .chanPointShim(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.shim = .chanPointShim(v)}
      }()
      case 2: try {
        var v: Lnrpc_PsbtShim?
        if let current = self.shim {
          try decoder.handleConflictingOneOf()
          if case .psbtShim(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.shim = .psbtShim(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.shim {
    case .chanPointShim?: try {
      guard case .chanPointShim(let v)? = self.shim else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .psbtShim?: try {
      guard case .psbtShim(let v)? = self.shim else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_FundingShim, rhs: Lnrpc_FundingShim) -> Bool {
    if lhs.shim != rhs.shim {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_FundingShimCancel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FundingShimCancel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pending_chan_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.pendingChanID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pendingChanID.isEmpty {
      try visitor.visitSingularBytesField(value: self.pendingChanID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_FundingShimCancel, rhs: Lnrpc_FundingShimCancel) -> Bool {
    if lhs.pendingChanID != rhs.pendingChanID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_FundingPsbtVerify: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FundingPsbtVerify"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "funded_psbt"),
    2: .standard(proto: "pending_chan_id"),
    3: .standard(proto: "skip_finalize"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.fundedPsbt) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.pendingChanID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.skipFinalize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fundedPsbt.isEmpty {
      try visitor.visitSingularBytesField(value: self.fundedPsbt, fieldNumber: 1)
    }
    if !self.pendingChanID.isEmpty {
      try visitor.visitSingularBytesField(value: self.pendingChanID, fieldNumber: 2)
    }
    if self.skipFinalize != false {
      try visitor.visitSingularBoolField(value: self.skipFinalize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_FundingPsbtVerify, rhs: Lnrpc_FundingPsbtVerify) -> Bool {
    if lhs.fundedPsbt != rhs.fundedPsbt {return false}
    if lhs.pendingChanID != rhs.pendingChanID {return false}
    if lhs.skipFinalize != rhs.skipFinalize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_FundingPsbtFinalize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FundingPsbtFinalize"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signed_psbt"),
    2: .standard(proto: "pending_chan_id"),
    3: .standard(proto: "final_raw_tx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.signedPsbt) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.pendingChanID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.finalRawTx) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signedPsbt.isEmpty {
      try visitor.visitSingularBytesField(value: self.signedPsbt, fieldNumber: 1)
    }
    if !self.pendingChanID.isEmpty {
      try visitor.visitSingularBytesField(value: self.pendingChanID, fieldNumber: 2)
    }
    if !self.finalRawTx.isEmpty {
      try visitor.visitSingularBytesField(value: self.finalRawTx, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_FundingPsbtFinalize, rhs: Lnrpc_FundingPsbtFinalize) -> Bool {
    if lhs.signedPsbt != rhs.signedPsbt {return false}
    if lhs.pendingChanID != rhs.pendingChanID {return false}
    if lhs.finalRawTx != rhs.finalRawTx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_FundingTransitionMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FundingTransitionMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "shim_register"),
    2: .standard(proto: "shim_cancel"),
    3: .standard(proto: "psbt_verify"),
    4: .standard(proto: "psbt_finalize"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Lnrpc_FundingShim?
        if let current = self.trigger {
          try decoder.handleConflictingOneOf()
          if case .shimRegister(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.trigger = .shimRegister(v)}
      }()
      case 2: try {
        var v: Lnrpc_FundingShimCancel?
        if let current = self.trigger {
          try decoder.handleConflictingOneOf()
          if case .shimCancel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.trigger = .shimCancel(v)}
      }()
      case 3: try {
        var v: Lnrpc_FundingPsbtVerify?
        if let current = self.trigger {
          try decoder.handleConflictingOneOf()
          if case .psbtVerify(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.trigger = .psbtVerify(v)}
      }()
      case 4: try {
        var v: Lnrpc_FundingPsbtFinalize?
        if let current = self.trigger {
          try decoder.handleConflictingOneOf()
          if case .psbtFinalize(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.trigger = .psbtFinalize(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.trigger {
    case .shimRegister?: try {
      guard case .shimRegister(let v)? = self.trigger else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .shimCancel?: try {
      guard case .shimCancel(let v)? = self.trigger else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .psbtVerify?: try {
      guard case .psbtVerify(let v)? = self.trigger else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .psbtFinalize?: try {
      guard case .psbtFinalize(let v)? = self.trigger else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_FundingTransitionMsg, rhs: Lnrpc_FundingTransitionMsg) -> Bool {
    if lhs.trigger != rhs.trigger {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_FundingStateStepResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FundingStateStepResp"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_FundingStateStepResp, rhs: Lnrpc_FundingStateStepResp) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PendingHTLC: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingHTLC"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "incoming"),
    2: .same(proto: "amount"),
    3: .same(proto: "outpoint"),
    4: .standard(proto: "maturity_height"),
    5: .standard(proto: "blocks_til_maturity"),
    6: .same(proto: "stage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.incoming) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.outpoint) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.maturityHeight) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.blocksTilMaturity) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.stage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.incoming != false {
      try visitor.visitSingularBoolField(value: self.incoming, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    if !self.outpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.outpoint, fieldNumber: 3)
    }
    if self.maturityHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.maturityHeight, fieldNumber: 4)
    }
    if self.blocksTilMaturity != 0 {
      try visitor.visitSingularInt32Field(value: self.blocksTilMaturity, fieldNumber: 5)
    }
    if self.stage != 0 {
      try visitor.visitSingularUInt32Field(value: self.stage, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PendingHTLC, rhs: Lnrpc_PendingHTLC) -> Bool {
    if lhs.incoming != rhs.incoming {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.outpoint != rhs.outpoint {return false}
    if lhs.maturityHeight != rhs.maturityHeight {return false}
    if lhs.blocksTilMaturity != rhs.blocksTilMaturity {return false}
    if lhs.stage != rhs.stage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PendingChannelsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingChannelsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PendingChannelsRequest, rhs: Lnrpc_PendingChannelsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PendingChannelsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingChannelsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_limbo_balance"),
    2: .standard(proto: "pending_open_channels"),
    3: .standard(proto: "pending_closing_channels"),
    4: .standard(proto: "pending_force_closing_channels"),
    5: .standard(proto: "waiting_close_channels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.totalLimboBalance) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.pendingOpenChannels) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.pendingClosingChannels) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.pendingForceClosingChannels) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.waitingCloseChannels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalLimboBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.totalLimboBalance, fieldNumber: 1)
    }
    if !self.pendingOpenChannels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pendingOpenChannels, fieldNumber: 2)
    }
    if !self.pendingClosingChannels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pendingClosingChannels, fieldNumber: 3)
    }
    if !self.pendingForceClosingChannels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pendingForceClosingChannels, fieldNumber: 4)
    }
    if !self.waitingCloseChannels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.waitingCloseChannels, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PendingChannelsResponse, rhs: Lnrpc_PendingChannelsResponse) -> Bool {
    if lhs.totalLimboBalance != rhs.totalLimboBalance {return false}
    if lhs.pendingOpenChannels != rhs.pendingOpenChannels {return false}
    if lhs.pendingClosingChannels != rhs.pendingClosingChannels {return false}
    if lhs.pendingForceClosingChannels != rhs.pendingForceClosingChannels {return false}
    if lhs.waitingCloseChannels != rhs.waitingCloseChannels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PendingChannelsResponse.PendingChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Lnrpc_PendingChannelsResponse.protoMessageName + ".PendingChannel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "remote_node_pub"),
    2: .standard(proto: "channel_point"),
    3: .same(proto: "capacity"),
    4: .standard(proto: "local_balance"),
    5: .standard(proto: "remote_balance"),
    6: .standard(proto: "local_chan_reserve_sat"),
    7: .standard(proto: "remote_chan_reserve_sat"),
    8: .same(proto: "initiator"),
    9: .standard(proto: "commitment_type"),
    10: .standard(proto: "num_forwarding_packages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.remoteNodePub) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.channelPoint) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.capacity) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.localBalance) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.remoteBalance) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.localChanReserveSat) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.remoteChanReserveSat) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.initiator) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.commitmentType) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.numForwardingPackages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.remoteNodePub.isEmpty {
      try visitor.visitSingularStringField(value: self.remoteNodePub, fieldNumber: 1)
    }
    if !self.channelPoint.isEmpty {
      try visitor.visitSingularStringField(value: self.channelPoint, fieldNumber: 2)
    }
    if self.capacity != 0 {
      try visitor.visitSingularInt64Field(value: self.capacity, fieldNumber: 3)
    }
    if self.localBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.localBalance, fieldNumber: 4)
    }
    if self.remoteBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.remoteBalance, fieldNumber: 5)
    }
    if self.localChanReserveSat != 0 {
      try visitor.visitSingularInt64Field(value: self.localChanReserveSat, fieldNumber: 6)
    }
    if self.remoteChanReserveSat != 0 {
      try visitor.visitSingularInt64Field(value: self.remoteChanReserveSat, fieldNumber: 7)
    }
    if self.initiator != .unknown {
      try visitor.visitSingularEnumField(value: self.initiator, fieldNumber: 8)
    }
    if self.commitmentType != .unknownCommitmentType {
      try visitor.visitSingularEnumField(value: self.commitmentType, fieldNumber: 9)
    }
    if self.numForwardingPackages != 0 {
      try visitor.visitSingularInt64Field(value: self.numForwardingPackages, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PendingChannelsResponse.PendingChannel, rhs: Lnrpc_PendingChannelsResponse.PendingChannel) -> Bool {
    if lhs.remoteNodePub != rhs.remoteNodePub {return false}
    if lhs.channelPoint != rhs.channelPoint {return false}
    if lhs.capacity != rhs.capacity {return false}
    if lhs.localBalance != rhs.localBalance {return false}
    if lhs.remoteBalance != rhs.remoteBalance {return false}
    if lhs.localChanReserveSat != rhs.localChanReserveSat {return false}
    if lhs.remoteChanReserveSat != rhs.remoteChanReserveSat {return false}
    if lhs.initiator != rhs.initiator {return false}
    if lhs.commitmentType != rhs.commitmentType {return false}
    if lhs.numForwardingPackages != rhs.numForwardingPackages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PendingChannelsResponse.PendingOpenChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Lnrpc_PendingChannelsResponse.protoMessageName + ".PendingOpenChannel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
    2: .standard(proto: "confirmation_height"),
    4: .standard(proto: "commit_fee"),
    5: .standard(proto: "commit_weight"),
    6: .standard(proto: "fee_per_kw"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._channel) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.confirmationHeight) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.commitFee) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.commitWeight) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.feePerKw) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._channel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.confirmationHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.confirmationHeight, fieldNumber: 2)
    }
    if self.commitFee != 0 {
      try visitor.visitSingularInt64Field(value: self.commitFee, fieldNumber: 4)
    }
    if self.commitWeight != 0 {
      try visitor.visitSingularInt64Field(value: self.commitWeight, fieldNumber: 5)
    }
    if self.feePerKw != 0 {
      try visitor.visitSingularInt64Field(value: self.feePerKw, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PendingChannelsResponse.PendingOpenChannel, rhs: Lnrpc_PendingChannelsResponse.PendingOpenChannel) -> Bool {
    if lhs._channel != rhs._channel {return false}
    if lhs.confirmationHeight != rhs.confirmationHeight {return false}
    if lhs.commitFee != rhs.commitFee {return false}
    if lhs.commitWeight != rhs.commitWeight {return false}
    if lhs.feePerKw != rhs.feePerKw {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PendingChannelsResponse.WaitingCloseChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Lnrpc_PendingChannelsResponse.protoMessageName + ".WaitingCloseChannel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
    2: .standard(proto: "limbo_balance"),
    3: .same(proto: "commitments"),
  ]

  fileprivate class _StorageClass {
    var _channel: Lnrpc_PendingChannelsResponse.PendingChannel? = nil
    var _limboBalance: Int64 = 0
    var _commitments: Lnrpc_PendingChannelsResponse.Commitments? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channel = source._channel
      _limboBalance = source._limboBalance
      _commitments = source._commitments
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._channel) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._limboBalance) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._commitments) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._channel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._limboBalance != 0 {
        try visitor.visitSingularInt64Field(value: _storage._limboBalance, fieldNumber: 2)
      }
      if let v = _storage._commitments {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PendingChannelsResponse.WaitingCloseChannel, rhs: Lnrpc_PendingChannelsResponse.WaitingCloseChannel) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._channel != rhs_storage._channel {return false}
        if _storage._limboBalance != rhs_storage._limboBalance {return false}
        if _storage._commitments != rhs_storage._commitments {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PendingChannelsResponse.Commitments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Lnrpc_PendingChannelsResponse.protoMessageName + ".Commitments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "local_txid"),
    2: .standard(proto: "remote_txid"),
    3: .standard(proto: "remote_pending_txid"),
    4: .standard(proto: "local_commit_fee_sat"),
    5: .standard(proto: "remote_commit_fee_sat"),
    6: .standard(proto: "remote_pending_commit_fee_sat"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.localTxid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.remoteTxid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.remotePendingTxid) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.localCommitFeeSat) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.remoteCommitFeeSat) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.remotePendingCommitFeeSat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.localTxid.isEmpty {
      try visitor.visitSingularStringField(value: self.localTxid, fieldNumber: 1)
    }
    if !self.remoteTxid.isEmpty {
      try visitor.visitSingularStringField(value: self.remoteTxid, fieldNumber: 2)
    }
    if !self.remotePendingTxid.isEmpty {
      try visitor.visitSingularStringField(value: self.remotePendingTxid, fieldNumber: 3)
    }
    if self.localCommitFeeSat != 0 {
      try visitor.visitSingularUInt64Field(value: self.localCommitFeeSat, fieldNumber: 4)
    }
    if self.remoteCommitFeeSat != 0 {
      try visitor.visitSingularUInt64Field(value: self.remoteCommitFeeSat, fieldNumber: 5)
    }
    if self.remotePendingCommitFeeSat != 0 {
      try visitor.visitSingularUInt64Field(value: self.remotePendingCommitFeeSat, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PendingChannelsResponse.Commitments, rhs: Lnrpc_PendingChannelsResponse.Commitments) -> Bool {
    if lhs.localTxid != rhs.localTxid {return false}
    if lhs.remoteTxid != rhs.remoteTxid {return false}
    if lhs.remotePendingTxid != rhs.remotePendingTxid {return false}
    if lhs.localCommitFeeSat != rhs.localCommitFeeSat {return false}
    if lhs.remoteCommitFeeSat != rhs.remoteCommitFeeSat {return false}
    if lhs.remotePendingCommitFeeSat != rhs.remotePendingCommitFeeSat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PendingChannelsResponse.ClosedChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Lnrpc_PendingChannelsResponse.protoMessageName + ".ClosedChannel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
    2: .standard(proto: "closing_txid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._channel) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.closingTxid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._channel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.closingTxid.isEmpty {
      try visitor.visitSingularStringField(value: self.closingTxid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PendingChannelsResponse.ClosedChannel, rhs: Lnrpc_PendingChannelsResponse.ClosedChannel) -> Bool {
    if lhs._channel != rhs._channel {return false}
    if lhs.closingTxid != rhs.closingTxid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PendingChannelsResponse.ForceClosedChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Lnrpc_PendingChannelsResponse.protoMessageName + ".ForceClosedChannel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
    2: .standard(proto: "closing_txid"),
    3: .standard(proto: "limbo_balance"),
    4: .standard(proto: "maturity_height"),
    5: .standard(proto: "blocks_til_maturity"),
    6: .standard(proto: "recovered_balance"),
    8: .standard(proto: "pending_htlcs"),
    9: .same(proto: "anchor"),
  ]

  fileprivate class _StorageClass {
    var _channel: Lnrpc_PendingChannelsResponse.PendingChannel? = nil
    var _closingTxid: String = String()
    var _limboBalance: Int64 = 0
    var _maturityHeight: UInt32 = 0
    var _blocksTilMaturity: Int32 = 0
    var _recoveredBalance: Int64 = 0
    var _pendingHtlcs: [Lnrpc_PendingHTLC] = []
    var _anchor: Lnrpc_PendingChannelsResponse.ForceClosedChannel.AnchorState = .limbo

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channel = source._channel
      _closingTxid = source._closingTxid
      _limboBalance = source._limboBalance
      _maturityHeight = source._maturityHeight
      _blocksTilMaturity = source._blocksTilMaturity
      _recoveredBalance = source._recoveredBalance
      _pendingHtlcs = source._pendingHtlcs
      _anchor = source._anchor
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._channel) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._closingTxid) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._limboBalance) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._maturityHeight) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._blocksTilMaturity) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._recoveredBalance) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._pendingHtlcs) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._anchor) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._channel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._closingTxid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._closingTxid, fieldNumber: 2)
      }
      if _storage._limboBalance != 0 {
        try visitor.visitSingularInt64Field(value: _storage._limboBalance, fieldNumber: 3)
      }
      if _storage._maturityHeight != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._maturityHeight, fieldNumber: 4)
      }
      if _storage._blocksTilMaturity != 0 {
        try visitor.visitSingularInt32Field(value: _storage._blocksTilMaturity, fieldNumber: 5)
      }
      if _storage._recoveredBalance != 0 {
        try visitor.visitSingularInt64Field(value: _storage._recoveredBalance, fieldNumber: 6)
      }
      if !_storage._pendingHtlcs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pendingHtlcs, fieldNumber: 8)
      }
      if _storage._anchor != .limbo {
        try visitor.visitSingularEnumField(value: _storage._anchor, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PendingChannelsResponse.ForceClosedChannel, rhs: Lnrpc_PendingChannelsResponse.ForceClosedChannel) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._channel != rhs_storage._channel {return false}
        if _storage._closingTxid != rhs_storage._closingTxid {return false}
        if _storage._limboBalance != rhs_storage._limboBalance {return false}
        if _storage._maturityHeight != rhs_storage._maturityHeight {return false}
        if _storage._blocksTilMaturity != rhs_storage._blocksTilMaturity {return false}
        if _storage._recoveredBalance != rhs_storage._recoveredBalance {return false}
        if _storage._pendingHtlcs != rhs_storage._pendingHtlcs {return false}
        if _storage._anchor != rhs_storage._anchor {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PendingChannelsResponse.ForceClosedChannel.AnchorState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LIMBO"),
    1: .same(proto: "RECOVERED"),
    2: .same(proto: "LOST"),
  ]
}

extension Lnrpc_ChannelEventSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelEventSubscription"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelEventSubscription, rhs: Lnrpc_ChannelEventSubscription) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelEventUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelEventUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "open_channel"),
    2: .standard(proto: "closed_channel"),
    3: .standard(proto: "active_channel"),
    4: .standard(proto: "inactive_channel"),
    6: .standard(proto: "pending_open_channel"),
    7: .standard(proto: "fully_resolved_channel"),
    5: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Lnrpc_Channel?
        if let current = self.channel {
          try decoder.handleConflictingOneOf()
          if case .openChannel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.channel = .openChannel(v)}
      }()
      case 2: try {
        var v: Lnrpc_ChannelCloseSummary?
        if let current = self.channel {
          try decoder.handleConflictingOneOf()
          if case .closedChannel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.channel = .closedChannel(v)}
      }()
      case 3: try {
        var v: Lnrpc_ChannelPoint?
        if let current = self.channel {
          try decoder.handleConflictingOneOf()
          if case .activeChannel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.channel = .activeChannel(v)}
      }()
      case 4: try {
        var v: Lnrpc_ChannelPoint?
        if let current = self.channel {
          try decoder.handleConflictingOneOf()
          if case .inactiveChannel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.channel = .inactiveChannel(v)}
      }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 6: try {
        var v: Lnrpc_PendingUpdate?
        if let current = self.channel {
          try decoder.handleConflictingOneOf()
          if case .pendingOpenChannel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.channel = .pendingOpenChannel(v)}
      }()
      case 7: try {
        var v: Lnrpc_ChannelPoint?
        if let current = self.channel {
          try decoder.handleConflictingOneOf()
          if case .fullyResolvedChannel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.channel = .fullyResolvedChannel(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.channel {
    case .openChannel?: try {
      guard case .openChannel(let v)? = self.channel else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .closedChannel?: try {
      guard case .closedChannel(let v)? = self.channel else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .activeChannel?: try {
      guard case .activeChannel(let v)? = self.channel else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .inactiveChannel?: try {
      guard case .inactiveChannel(let v)? = self.channel else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    default: break
    }
    if self.type != .openChannel {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 5)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.channel {
    case .pendingOpenChannel?: try {
      guard case .pendingOpenChannel(let v)? = self.channel else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .fullyResolvedChannel?: try {
      guard case .fullyResolvedChannel(let v)? = self.channel else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelEventUpdate, rhs: Lnrpc_ChannelEventUpdate) -> Bool {
    if lhs.channel != rhs.channel {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelEventUpdate.UpdateType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPEN_CHANNEL"),
    1: .same(proto: "CLOSED_CHANNEL"),
    2: .same(proto: "ACTIVE_CHANNEL"),
    3: .same(proto: "INACTIVE_CHANNEL"),
    4: .same(proto: "PENDING_OPEN_CHANNEL"),
    5: .same(proto: "FULLY_RESOLVED_CHANNEL"),
  ]
}

extension Lnrpc_WalletAccountBalance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WalletAccountBalance"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "confirmed_balance"),
    2: .standard(proto: "unconfirmed_balance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.confirmedBalance) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.unconfirmedBalance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.confirmedBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.confirmedBalance, fieldNumber: 1)
    }
    if self.unconfirmedBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.unconfirmedBalance, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_WalletAccountBalance, rhs: Lnrpc_WalletAccountBalance) -> Bool {
    if lhs.confirmedBalance != rhs.confirmedBalance {return false}
    if lhs.unconfirmedBalance != rhs.unconfirmedBalance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_WalletBalanceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WalletBalanceRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_WalletBalanceRequest, rhs: Lnrpc_WalletBalanceRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_WalletBalanceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WalletBalanceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_balance"),
    2: .standard(proto: "confirmed_balance"),
    3: .standard(proto: "unconfirmed_balance"),
    4: .standard(proto: "account_balance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.totalBalance) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.confirmedBalance) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.unconfirmedBalance) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Lnrpc_WalletAccountBalance>.self, value: &self.accountBalance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.totalBalance, fieldNumber: 1)
    }
    if self.confirmedBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.confirmedBalance, fieldNumber: 2)
    }
    if self.unconfirmedBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.unconfirmedBalance, fieldNumber: 3)
    }
    if !self.accountBalance.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Lnrpc_WalletAccountBalance>.self, value: self.accountBalance, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_WalletBalanceResponse, rhs: Lnrpc_WalletBalanceResponse) -> Bool {
    if lhs.totalBalance != rhs.totalBalance {return false}
    if lhs.confirmedBalance != rhs.confirmedBalance {return false}
    if lhs.unconfirmedBalance != rhs.unconfirmedBalance {return false}
    if lhs.accountBalance != rhs.accountBalance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_Amount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Amount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sat"),
    2: .same(proto: "msat"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.sat) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.msat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sat != 0 {
      try visitor.visitSingularUInt64Field(value: self.sat, fieldNumber: 1)
    }
    if self.msat != 0 {
      try visitor.visitSingularUInt64Field(value: self.msat, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_Amount, rhs: Lnrpc_Amount) -> Bool {
    if lhs.sat != rhs.sat {return false}
    if lhs.msat != rhs.msat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelBalanceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelBalanceRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelBalanceRequest, rhs: Lnrpc_ChannelBalanceRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelBalanceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelBalanceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "balance"),
    2: .standard(proto: "pending_open_balance"),
    3: .standard(proto: "local_balance"),
    4: .standard(proto: "remote_balance"),
    5: .standard(proto: "unsettled_local_balance"),
    6: .standard(proto: "unsettled_remote_balance"),
    7: .standard(proto: "pending_open_local_balance"),
    8: .standard(proto: "pending_open_remote_balance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.balance) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.pendingOpenBalance) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._localBalance) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._remoteBalance) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._unsettledLocalBalance) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._unsettledRemoteBalance) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._pendingOpenLocalBalance) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._pendingOpenRemoteBalance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.balance != 0 {
      try visitor.visitSingularInt64Field(value: self.balance, fieldNumber: 1)
    }
    if self.pendingOpenBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.pendingOpenBalance, fieldNumber: 2)
    }
    if let v = self._localBalance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._remoteBalance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._unsettledLocalBalance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._unsettledRemoteBalance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._pendingOpenLocalBalance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._pendingOpenRemoteBalance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelBalanceResponse, rhs: Lnrpc_ChannelBalanceResponse) -> Bool {
    if lhs.balance != rhs.balance {return false}
    if lhs.pendingOpenBalance != rhs.pendingOpenBalance {return false}
    if lhs._localBalance != rhs._localBalance {return false}
    if lhs._remoteBalance != rhs._remoteBalance {return false}
    if lhs._unsettledLocalBalance != rhs._unsettledLocalBalance {return false}
    if lhs._unsettledRemoteBalance != rhs._unsettledRemoteBalance {return false}
    if lhs._pendingOpenLocalBalance != rhs._pendingOpenLocalBalance {return false}
    if lhs._pendingOpenRemoteBalance != rhs._pendingOpenRemoteBalance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_QueryRoutesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryRoutesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key"),
    2: .same(proto: "amt"),
    12: .standard(proto: "amt_msat"),
    4: .standard(proto: "final_cltv_delta"),
    5: .standard(proto: "fee_limit"),
    6: .standard(proto: "ignored_nodes"),
    7: .standard(proto: "ignored_edges"),
    8: .standard(proto: "source_pub_key"),
    9: .standard(proto: "use_mission_control"),
    10: .standard(proto: "ignored_pairs"),
    11: .standard(proto: "cltv_limit"),
    13: .standard(proto: "dest_custom_records"),
    14: .standard(proto: "outgoing_chan_id"),
    15: .standard(proto: "last_hop_pubkey"),
    16: .standard(proto: "route_hints"),
    17: .standard(proto: "dest_features"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pubKey) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.amt) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.finalCltvDelta) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._feeLimit) }()
      case 6: try { try decoder.decodeRepeatedBytesField(value: &self.ignoredNodes) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.ignoredEdges) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.sourcePubKey) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.useMissionControl) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.ignoredPairs) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self.cltvLimit) }()
      case 12: try { try decoder.decodeSingularInt64Field(value: &self.amtMsat) }()
      case 13: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt64,SwiftProtobuf.ProtobufBytes>.self, value: &self.destCustomRecords) }()
      case 14: try { try decoder.decodeSingularUInt64Field(value: &self.outgoingChanID) }()
      case 15: try { try decoder.decodeSingularBytesField(value: &self.lastHopPubkey) }()
      case 16: try { try decoder.decodeRepeatedMessageField(value: &self.routeHints) }()
      case 17: try { try decoder.decodeRepeatedEnumField(value: &self.destFeatures) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 1)
    }
    if self.amt != 0 {
      try visitor.visitSingularInt64Field(value: self.amt, fieldNumber: 2)
    }
    if self.finalCltvDelta != 0 {
      try visitor.visitSingularInt32Field(value: self.finalCltvDelta, fieldNumber: 4)
    }
    if let v = self._feeLimit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.ignoredNodes.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.ignoredNodes, fieldNumber: 6)
    }
    if !self.ignoredEdges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ignoredEdges, fieldNumber: 7)
    }
    if !self.sourcePubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.sourcePubKey, fieldNumber: 8)
    }
    if self.useMissionControl != false {
      try visitor.visitSingularBoolField(value: self.useMissionControl, fieldNumber: 9)
    }
    if !self.ignoredPairs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ignoredPairs, fieldNumber: 10)
    }
    if self.cltvLimit != 0 {
      try visitor.visitSingularUInt32Field(value: self.cltvLimit, fieldNumber: 11)
    }
    if self.amtMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.amtMsat, fieldNumber: 12)
    }
    if !self.destCustomRecords.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt64,SwiftProtobuf.ProtobufBytes>.self, value: self.destCustomRecords, fieldNumber: 13)
    }
    if self.outgoingChanID != 0 {
      try visitor.visitSingularUInt64Field(value: self.outgoingChanID, fieldNumber: 14)
    }
    if !self.lastHopPubkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.lastHopPubkey, fieldNumber: 15)
    }
    if !self.routeHints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.routeHints, fieldNumber: 16)
    }
    if !self.destFeatures.isEmpty {
      try visitor.visitPackedEnumField(value: self.destFeatures, fieldNumber: 17)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_QueryRoutesRequest, rhs: Lnrpc_QueryRoutesRequest) -> Bool {
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.amt != rhs.amt {return false}
    if lhs.amtMsat != rhs.amtMsat {return false}
    if lhs.finalCltvDelta != rhs.finalCltvDelta {return false}
    if lhs._feeLimit != rhs._feeLimit {return false}
    if lhs.ignoredNodes != rhs.ignoredNodes {return false}
    if lhs.ignoredEdges != rhs.ignoredEdges {return false}
    if lhs.sourcePubKey != rhs.sourcePubKey {return false}
    if lhs.useMissionControl != rhs.useMissionControl {return false}
    if lhs.ignoredPairs != rhs.ignoredPairs {return false}
    if lhs.cltvLimit != rhs.cltvLimit {return false}
    if lhs.destCustomRecords != rhs.destCustomRecords {return false}
    if lhs.outgoingChanID != rhs.outgoingChanID {return false}
    if lhs.lastHopPubkey != rhs.lastHopPubkey {return false}
    if lhs.routeHints != rhs.routeHints {return false}
    if lhs.destFeatures != rhs.destFeatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_NodePair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodePair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "to"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.from) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.to) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularBytesField(value: self.from, fieldNumber: 1)
    }
    if !self.to.isEmpty {
      try visitor.visitSingularBytesField(value: self.to, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_NodePair, rhs: Lnrpc_NodePair) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.to != rhs.to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_EdgeLocator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EdgeLocator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    2: .standard(proto: "direction_reverse"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.directionReverse) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 1)
    }
    if self.directionReverse != false {
      try visitor.visitSingularBoolField(value: self.directionReverse, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_EdgeLocator, rhs: Lnrpc_EdgeLocator) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.directionReverse != rhs.directionReverse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_QueryRoutesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryRoutesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "routes"),
    2: .standard(proto: "success_prob"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.routes) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.successProb) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.routes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.routes, fieldNumber: 1)
    }
    if self.successProb != 0 {
      try visitor.visitSingularDoubleField(value: self.successProb, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_QueryRoutesResponse, rhs: Lnrpc_QueryRoutesResponse) -> Bool {
    if lhs.routes != rhs.routes {return false}
    if lhs.successProb != rhs.successProb {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_Hop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Hop"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chan_id"),
    2: .standard(proto: "chan_capacity"),
    3: .standard(proto: "amt_to_forward"),
    4: .same(proto: "fee"),
    5: .same(proto: "expiry"),
    6: .standard(proto: "amt_to_forward_msat"),
    7: .standard(proto: "fee_msat"),
    8: .standard(proto: "pub_key"),
    9: .standard(proto: "tlv_payload"),
    10: .standard(proto: "mpp_record"),
    12: .standard(proto: "amp_record"),
    11: .standard(proto: "custom_records"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.chanID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.chanCapacity) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.amtToForward) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.fee) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.expiry) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.amtToForwardMsat) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.feeMsat) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.pubKey) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.tlvPayload) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._mppRecord) }()
      case 11: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt64,SwiftProtobuf.ProtobufBytes>.self, value: &self.customRecords) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._ampRecord) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chanID != 0 {
      try visitor.visitSingularUInt64Field(value: self.chanID, fieldNumber: 1)
    }
    if self.chanCapacity != 0 {
      try visitor.visitSingularInt64Field(value: self.chanCapacity, fieldNumber: 2)
    }
    if self.amtToForward != 0 {
      try visitor.visitSingularInt64Field(value: self.amtToForward, fieldNumber: 3)
    }
    if self.fee != 0 {
      try visitor.visitSingularInt64Field(value: self.fee, fieldNumber: 4)
    }
    if self.expiry != 0 {
      try visitor.visitSingularUInt32Field(value: self.expiry, fieldNumber: 5)
    }
    if self.amtToForwardMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.amtToForwardMsat, fieldNumber: 6)
    }
    if self.feeMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.feeMsat, fieldNumber: 7)
    }
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 8)
    }
    if self.tlvPayload != false {
      try visitor.visitSingularBoolField(value: self.tlvPayload, fieldNumber: 9)
    }
    if let v = self._mppRecord {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    if !self.customRecords.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt64,SwiftProtobuf.ProtobufBytes>.self, value: self.customRecords, fieldNumber: 11)
    }
    if let v = self._ampRecord {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_Hop, rhs: Lnrpc_Hop) -> Bool {
    if lhs.chanID != rhs.chanID {return false}
    if lhs.chanCapacity != rhs.chanCapacity {return false}
    if lhs.amtToForward != rhs.amtToForward {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.expiry != rhs.expiry {return false}
    if lhs.amtToForwardMsat != rhs.amtToForwardMsat {return false}
    if lhs.feeMsat != rhs.feeMsat {return false}
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.tlvPayload != rhs.tlvPayload {return false}
    if lhs._mppRecord != rhs._mppRecord {return false}
    if lhs._ampRecord != rhs._ampRecord {return false}
    if lhs.customRecords != rhs.customRecords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_MPPRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MPPRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    11: .standard(proto: "payment_addr"),
    10: .standard(proto: "total_amt_msat"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.totalAmtMsat) }()
      case 11: try { try decoder.decodeSingularBytesField(value: &self.paymentAddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalAmtMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.totalAmtMsat, fieldNumber: 10)
    }
    if !self.paymentAddr.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentAddr, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_MPPRecord, rhs: Lnrpc_MPPRecord) -> Bool {
    if lhs.paymentAddr != rhs.paymentAddr {return false}
    if lhs.totalAmtMsat != rhs.totalAmtMsat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_AMPRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AMPRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_share"),
    2: .standard(proto: "set_id"),
    3: .standard(proto: "child_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.rootShare) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.setID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.childIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rootShare.isEmpty {
      try visitor.visitSingularBytesField(value: self.rootShare, fieldNumber: 1)
    }
    if !self.setID.isEmpty {
      try visitor.visitSingularBytesField(value: self.setID, fieldNumber: 2)
    }
    if self.childIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.childIndex, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_AMPRecord, rhs: Lnrpc_AMPRecord) -> Bool {
    if lhs.rootShare != rhs.rootShare {return false}
    if lhs.setID != rhs.setID {return false}
    if lhs.childIndex != rhs.childIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_Route: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Route"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_time_lock"),
    2: .standard(proto: "total_fees"),
    3: .standard(proto: "total_amt"),
    4: .same(proto: "hops"),
    5: .standard(proto: "total_fees_msat"),
    6: .standard(proto: "total_amt_msat"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.totalTimeLock) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.totalFees) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.totalAmt) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.hops) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.totalFeesMsat) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.totalAmtMsat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalTimeLock != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalTimeLock, fieldNumber: 1)
    }
    if self.totalFees != 0 {
      try visitor.visitSingularInt64Field(value: self.totalFees, fieldNumber: 2)
    }
    if self.totalAmt != 0 {
      try visitor.visitSingularInt64Field(value: self.totalAmt, fieldNumber: 3)
    }
    if !self.hops.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hops, fieldNumber: 4)
    }
    if self.totalFeesMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.totalFeesMsat, fieldNumber: 5)
    }
    if self.totalAmtMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.totalAmtMsat, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_Route, rhs: Lnrpc_Route) -> Bool {
    if lhs.totalTimeLock != rhs.totalTimeLock {return false}
    if lhs.totalFees != rhs.totalFees {return false}
    if lhs.totalAmt != rhs.totalAmt {return false}
    if lhs.hops != rhs.hops {return false}
    if lhs.totalFeesMsat != rhs.totalFeesMsat {return false}
    if lhs.totalAmtMsat != rhs.totalAmtMsat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_NodeInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key"),
    2: .standard(proto: "include_channels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pubKey) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.includeChannels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 1)
    }
    if self.includeChannels != false {
      try visitor.visitSingularBoolField(value: self.includeChannels, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_NodeInfoRequest, rhs: Lnrpc_NodeInfoRequest) -> Bool {
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.includeChannels != rhs.includeChannels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_NodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "node"),
    2: .standard(proto: "num_channels"),
    3: .standard(proto: "total_capacity"),
    4: .same(proto: "channels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._node) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.numChannels) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.totalCapacity) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.channels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._node {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.numChannels != 0 {
      try visitor.visitSingularUInt32Field(value: self.numChannels, fieldNumber: 2)
    }
    if self.totalCapacity != 0 {
      try visitor.visitSingularInt64Field(value: self.totalCapacity, fieldNumber: 3)
    }
    if !self.channels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channels, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_NodeInfo, rhs: Lnrpc_NodeInfo) -> Bool {
    if lhs._node != rhs._node {return false}
    if lhs.numChannels != rhs.numChannels {return false}
    if lhs.totalCapacity != rhs.totalCapacity {return false}
    if lhs.channels != rhs.channels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_LightningNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LightningNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_update"),
    2: .standard(proto: "pub_key"),
    3: .same(proto: "alias"),
    4: .same(proto: "addresses"),
    5: .same(proto: "color"),
    6: .same(proto: "features"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.lastUpdate) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pubKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.alias) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.addresses) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.color) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Lnrpc_Feature>.self, value: &self.features) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lastUpdate != 0 {
      try visitor.visitSingularUInt32Field(value: self.lastUpdate, fieldNumber: 1)
    }
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 2)
    }
    if !self.alias.isEmpty {
      try visitor.visitSingularStringField(value: self.alias, fieldNumber: 3)
    }
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.addresses, fieldNumber: 4)
    }
    if !self.color.isEmpty {
      try visitor.visitSingularStringField(value: self.color, fieldNumber: 5)
    }
    if !self.features.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Lnrpc_Feature>.self, value: self.features, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_LightningNode, rhs: Lnrpc_LightningNode) -> Bool {
    if lhs.lastUpdate != rhs.lastUpdate {return false}
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.alias != rhs.alias {return false}
    if lhs.addresses != rhs.addresses {return false}
    if lhs.color != rhs.color {return false}
    if lhs.features != rhs.features {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_NodeAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "network"),
    2: .same(proto: "addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.network) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.addr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 1)
    }
    if !self.addr.isEmpty {
      try visitor.visitSingularStringField(value: self.addr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_NodeAddress, rhs: Lnrpc_NodeAddress) -> Bool {
    if lhs.network != rhs.network {return false}
    if lhs.addr != rhs.addr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_RoutingPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RoutingPolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_lock_delta"),
    2: .standard(proto: "min_htlc"),
    3: .standard(proto: "fee_base_msat"),
    4: .standard(proto: "fee_rate_milli_msat"),
    5: .same(proto: "disabled"),
    6: .standard(proto: "max_htlc_msat"),
    7: .standard(proto: "last_update"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.timeLockDelta) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.minHtlc) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.feeBaseMsat) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.feeRateMilliMsat) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.maxHtlcMsat) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.lastUpdate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timeLockDelta != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeLockDelta, fieldNumber: 1)
    }
    if self.minHtlc != 0 {
      try visitor.visitSingularInt64Field(value: self.minHtlc, fieldNumber: 2)
    }
    if self.feeBaseMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.feeBaseMsat, fieldNumber: 3)
    }
    if self.feeRateMilliMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.feeRateMilliMsat, fieldNumber: 4)
    }
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 5)
    }
    if self.maxHtlcMsat != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxHtlcMsat, fieldNumber: 6)
    }
    if self.lastUpdate != 0 {
      try visitor.visitSingularUInt32Field(value: self.lastUpdate, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_RoutingPolicy, rhs: Lnrpc_RoutingPolicy) -> Bool {
    if lhs.timeLockDelta != rhs.timeLockDelta {return false}
    if lhs.minHtlc != rhs.minHtlc {return false}
    if lhs.feeBaseMsat != rhs.feeBaseMsat {return false}
    if lhs.feeRateMilliMsat != rhs.feeRateMilliMsat {return false}
    if lhs.disabled != rhs.disabled {return false}
    if lhs.maxHtlcMsat != rhs.maxHtlcMsat {return false}
    if lhs.lastUpdate != rhs.lastUpdate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelEdge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelEdge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    2: .standard(proto: "chan_point"),
    3: .standard(proto: "last_update"),
    4: .standard(proto: "node1_pub"),
    5: .standard(proto: "node2_pub"),
    6: .same(proto: "capacity"),
    7: .standard(proto: "node1_policy"),
    8: .standard(proto: "node2_policy"),
  ]

  fileprivate class _StorageClass {
    var _channelID: UInt64 = 0
    var _chanPoint: String = String()
    var _lastUpdate: UInt32 = 0
    var _node1Pub: String = String()
    var _node2Pub: String = String()
    var _capacity: Int64 = 0
    var _node1Policy: Lnrpc_RoutingPolicy? = nil
    var _node2Policy: Lnrpc_RoutingPolicy? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channelID = source._channelID
      _chanPoint = source._chanPoint
      _lastUpdate = source._lastUpdate
      _node1Pub = source._node1Pub
      _node2Pub = source._node2Pub
      _capacity = source._capacity
      _node1Policy = source._node1Policy
      _node2Policy = source._node2Policy
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._channelID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._chanPoint) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._lastUpdate) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._node1Pub) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._node2Pub) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._capacity) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._node1Policy) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._node2Policy) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._channelID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._channelID, fieldNumber: 1)
      }
      if !_storage._chanPoint.isEmpty {
        try visitor.visitSingularStringField(value: _storage._chanPoint, fieldNumber: 2)
      }
      if _storage._lastUpdate != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._lastUpdate, fieldNumber: 3)
      }
      if !_storage._node1Pub.isEmpty {
        try visitor.visitSingularStringField(value: _storage._node1Pub, fieldNumber: 4)
      }
      if !_storage._node2Pub.isEmpty {
        try visitor.visitSingularStringField(value: _storage._node2Pub, fieldNumber: 5)
      }
      if _storage._capacity != 0 {
        try visitor.visitSingularInt64Field(value: _storage._capacity, fieldNumber: 6)
      }
      if let v = _storage._node1Policy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._node2Policy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelEdge, rhs: Lnrpc_ChannelEdge) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._channelID != rhs_storage._channelID {return false}
        if _storage._chanPoint != rhs_storage._chanPoint {return false}
        if _storage._lastUpdate != rhs_storage._lastUpdate {return false}
        if _storage._node1Pub != rhs_storage._node1Pub {return false}
        if _storage._node2Pub != rhs_storage._node2Pub {return false}
        if _storage._capacity != rhs_storage._capacity {return false}
        if _storage._node1Policy != rhs_storage._node1Policy {return false}
        if _storage._node2Policy != rhs_storage._node2Policy {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelGraphRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelGraphRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "include_unannounced"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.includeUnannounced) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.includeUnannounced != false {
      try visitor.visitSingularBoolField(value: self.includeUnannounced, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelGraphRequest, rhs: Lnrpc_ChannelGraphRequest) -> Bool {
    if lhs.includeUnannounced != rhs.includeUnannounced {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelGraph: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelGraph"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
    2: .same(proto: "edges"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.edges) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    if !self.edges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.edges, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelGraph, rhs: Lnrpc_ChannelGraph) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs.edges != rhs.edges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_NodeMetricsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeMetricsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "types"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.types) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.types.isEmpty {
      try visitor.visitPackedEnumField(value: self.types, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_NodeMetricsRequest, rhs: Lnrpc_NodeMetricsRequest) -> Bool {
    if lhs.types != rhs.types {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_NodeMetricsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeMetricsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "betweenness_centrality"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Lnrpc_FloatMetric>.self, value: &self.betweennessCentrality) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.betweennessCentrality.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Lnrpc_FloatMetric>.self, value: self.betweennessCentrality, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_NodeMetricsResponse, rhs: Lnrpc_NodeMetricsResponse) -> Bool {
    if lhs.betweennessCentrality != rhs.betweennessCentrality {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_FloatMetric: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FloatMetric"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "normalized_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.normalizedValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 1)
    }
    if self.normalizedValue != 0 {
      try visitor.visitSingularDoubleField(value: self.normalizedValue, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_FloatMetric, rhs: Lnrpc_FloatMetric) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.normalizedValue != rhs.normalizedValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChanInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChanInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chan_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.chanID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chanID != 0 {
      try visitor.visitSingularUInt64Field(value: self.chanID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChanInfoRequest, rhs: Lnrpc_ChanInfoRequest) -> Bool {
    if lhs.chanID != rhs.chanID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_NetworkInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_NetworkInfoRequest, rhs: Lnrpc_NetworkInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_NetworkInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "graph_diameter"),
    2: .standard(proto: "avg_out_degree"),
    3: .standard(proto: "max_out_degree"),
    4: .standard(proto: "num_nodes"),
    5: .standard(proto: "num_channels"),
    6: .standard(proto: "total_network_capacity"),
    7: .standard(proto: "avg_channel_size"),
    8: .standard(proto: "min_channel_size"),
    9: .standard(proto: "max_channel_size"),
    10: .standard(proto: "median_channel_size_sat"),
    11: .standard(proto: "num_zombie_chans"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.graphDiameter) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.avgOutDegree) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.maxOutDegree) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.numNodes) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.numChannels) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.totalNetworkCapacity) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self.avgChannelSize) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.minChannelSize) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.maxChannelSize) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.medianChannelSizeSat) }()
      case 11: try { try decoder.decodeSingularUInt64Field(value: &self.numZombieChans) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.graphDiameter != 0 {
      try visitor.visitSingularUInt32Field(value: self.graphDiameter, fieldNumber: 1)
    }
    if self.avgOutDegree != 0 {
      try visitor.visitSingularDoubleField(value: self.avgOutDegree, fieldNumber: 2)
    }
    if self.maxOutDegree != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxOutDegree, fieldNumber: 3)
    }
    if self.numNodes != 0 {
      try visitor.visitSingularUInt32Field(value: self.numNodes, fieldNumber: 4)
    }
    if self.numChannels != 0 {
      try visitor.visitSingularUInt32Field(value: self.numChannels, fieldNumber: 5)
    }
    if self.totalNetworkCapacity != 0 {
      try visitor.visitSingularInt64Field(value: self.totalNetworkCapacity, fieldNumber: 6)
    }
    if self.avgChannelSize != 0 {
      try visitor.visitSingularDoubleField(value: self.avgChannelSize, fieldNumber: 7)
    }
    if self.minChannelSize != 0 {
      try visitor.visitSingularInt64Field(value: self.minChannelSize, fieldNumber: 8)
    }
    if self.maxChannelSize != 0 {
      try visitor.visitSingularInt64Field(value: self.maxChannelSize, fieldNumber: 9)
    }
    if self.medianChannelSizeSat != 0 {
      try visitor.visitSingularInt64Field(value: self.medianChannelSizeSat, fieldNumber: 10)
    }
    if self.numZombieChans != 0 {
      try visitor.visitSingularUInt64Field(value: self.numZombieChans, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_NetworkInfo, rhs: Lnrpc_NetworkInfo) -> Bool {
    if lhs.graphDiameter != rhs.graphDiameter {return false}
    if lhs.avgOutDegree != rhs.avgOutDegree {return false}
    if lhs.maxOutDegree != rhs.maxOutDegree {return false}
    if lhs.numNodes != rhs.numNodes {return false}
    if lhs.numChannels != rhs.numChannels {return false}
    if lhs.totalNetworkCapacity != rhs.totalNetworkCapacity {return false}
    if lhs.avgChannelSize != rhs.avgChannelSize {return false}
    if lhs.minChannelSize != rhs.minChannelSize {return false}
    if lhs.maxChannelSize != rhs.maxChannelSize {return false}
    if lhs.medianChannelSizeSat != rhs.medianChannelSizeSat {return false}
    if lhs.numZombieChans != rhs.numZombieChans {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_StopRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_StopRequest, rhs: Lnrpc_StopRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_StopResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_StopResponse, rhs: Lnrpc_StopResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_GraphTopologySubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GraphTopologySubscription"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_GraphTopologySubscription, rhs: Lnrpc_GraphTopologySubscription) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_GraphTopologyUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GraphTopologyUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_updates"),
    2: .standard(proto: "channel_updates"),
    3: .standard(proto: "closed_chans"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodeUpdates) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.channelUpdates) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.closedChans) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeUpdates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeUpdates, fieldNumber: 1)
    }
    if !self.channelUpdates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channelUpdates, fieldNumber: 2)
    }
    if !self.closedChans.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.closedChans, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_GraphTopologyUpdate, rhs: Lnrpc_GraphTopologyUpdate) -> Bool {
    if lhs.nodeUpdates != rhs.nodeUpdates {return false}
    if lhs.channelUpdates != rhs.channelUpdates {return false}
    if lhs.closedChans != rhs.closedChans {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_NodeUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addresses"),
    2: .standard(proto: "identity_key"),
    3: .standard(proto: "global_features"),
    4: .same(proto: "alias"),
    5: .same(proto: "color"),
    7: .standard(proto: "node_addresses"),
    6: .same(proto: "features"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.addresses) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identityKey) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.globalFeatures) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.alias) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.color) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Lnrpc_Feature>.self, value: &self.features) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.nodeAddresses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addresses, fieldNumber: 1)
    }
    if !self.identityKey.isEmpty {
      try visitor.visitSingularStringField(value: self.identityKey, fieldNumber: 2)
    }
    if !self.globalFeatures.isEmpty {
      try visitor.visitSingularBytesField(value: self.globalFeatures, fieldNumber: 3)
    }
    if !self.alias.isEmpty {
      try visitor.visitSingularStringField(value: self.alias, fieldNumber: 4)
    }
    if !self.color.isEmpty {
      try visitor.visitSingularStringField(value: self.color, fieldNumber: 5)
    }
    if !self.features.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Lnrpc_Feature>.self, value: self.features, fieldNumber: 6)
    }
    if !self.nodeAddresses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeAddresses, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_NodeUpdate, rhs: Lnrpc_NodeUpdate) -> Bool {
    if lhs.addresses != rhs.addresses {return false}
    if lhs.identityKey != rhs.identityKey {return false}
    if lhs.globalFeatures != rhs.globalFeatures {return false}
    if lhs.alias != rhs.alias {return false}
    if lhs.color != rhs.color {return false}
    if lhs.nodeAddresses != rhs.nodeAddresses {return false}
    if lhs.features != rhs.features {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelEdgeUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelEdgeUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chan_id"),
    2: .standard(proto: "chan_point"),
    3: .same(proto: "capacity"),
    4: .standard(proto: "routing_policy"),
    5: .standard(proto: "advertising_node"),
    6: .standard(proto: "connecting_node"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.chanID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._chanPoint) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.capacity) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._routingPolicy) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.advertisingNode) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.connectingNode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chanID != 0 {
      try visitor.visitSingularUInt64Field(value: self.chanID, fieldNumber: 1)
    }
    if let v = self._chanPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.capacity != 0 {
      try visitor.visitSingularInt64Field(value: self.capacity, fieldNumber: 3)
    }
    if let v = self._routingPolicy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.advertisingNode.isEmpty {
      try visitor.visitSingularStringField(value: self.advertisingNode, fieldNumber: 5)
    }
    if !self.connectingNode.isEmpty {
      try visitor.visitSingularStringField(value: self.connectingNode, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelEdgeUpdate, rhs: Lnrpc_ChannelEdgeUpdate) -> Bool {
    if lhs.chanID != rhs.chanID {return false}
    if lhs._chanPoint != rhs._chanPoint {return false}
    if lhs.capacity != rhs.capacity {return false}
    if lhs._routingPolicy != rhs._routingPolicy {return false}
    if lhs.advertisingNode != rhs.advertisingNode {return false}
    if lhs.connectingNode != rhs.connectingNode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ClosedChannelUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClosedChannelUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chan_id"),
    2: .same(proto: "capacity"),
    3: .standard(proto: "closed_height"),
    4: .standard(proto: "chan_point"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.chanID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.capacity) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.closedHeight) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._chanPoint) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chanID != 0 {
      try visitor.visitSingularUInt64Field(value: self.chanID, fieldNumber: 1)
    }
    if self.capacity != 0 {
      try visitor.visitSingularInt64Field(value: self.capacity, fieldNumber: 2)
    }
    if self.closedHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.closedHeight, fieldNumber: 3)
    }
    if let v = self._chanPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ClosedChannelUpdate, rhs: Lnrpc_ClosedChannelUpdate) -> Bool {
    if lhs.chanID != rhs.chanID {return false}
    if lhs.capacity != rhs.capacity {return false}
    if lhs.closedHeight != rhs.closedHeight {return false}
    if lhs._chanPoint != rhs._chanPoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_HopHint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HopHint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .standard(proto: "chan_id"),
    3: .standard(proto: "fee_base_msat"),
    4: .standard(proto: "fee_proportional_millionths"),
    5: .standard(proto: "cltv_expiry_delta"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.nodeID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.chanID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.feeBaseMsat) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.feeProportionalMillionths) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.cltvExpiryDelta) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodeID, fieldNumber: 1)
    }
    if self.chanID != 0 {
      try visitor.visitSingularUInt64Field(value: self.chanID, fieldNumber: 2)
    }
    if self.feeBaseMsat != 0 {
      try visitor.visitSingularUInt32Field(value: self.feeBaseMsat, fieldNumber: 3)
    }
    if self.feeProportionalMillionths != 0 {
      try visitor.visitSingularUInt32Field(value: self.feeProportionalMillionths, fieldNumber: 4)
    }
    if self.cltvExpiryDelta != 0 {
      try visitor.visitSingularUInt32Field(value: self.cltvExpiryDelta, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_HopHint, rhs: Lnrpc_HopHint) -> Bool {
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.chanID != rhs.chanID {return false}
    if lhs.feeBaseMsat != rhs.feeBaseMsat {return false}
    if lhs.feeProportionalMillionths != rhs.feeProportionalMillionths {return false}
    if lhs.cltvExpiryDelta != rhs.cltvExpiryDelta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_SetID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "set_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.setID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.setID.isEmpty {
      try visitor.visitSingularBytesField(value: self.setID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_SetID, rhs: Lnrpc_SetID) -> Bool {
    if lhs.setID != rhs.setID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_RouteHint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RouteHint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hop_hints"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.hopHints) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hopHints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hopHints, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_RouteHint, rhs: Lnrpc_RouteHint) -> Bool {
    if lhs.hopHints != rhs.hopHints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_AMPInvoiceState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AMPInvoiceState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .standard(proto: "settle_index"),
    3: .standard(proto: "settle_time"),
    5: .standard(proto: "amt_paid_msat"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.settleIndex) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.settleTime) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.amtPaidMsat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .accepted {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    if self.settleIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.settleIndex, fieldNumber: 2)
    }
    if self.settleTime != 0 {
      try visitor.visitSingularInt64Field(value: self.settleTime, fieldNumber: 3)
    }
    if self.amtPaidMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.amtPaidMsat, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_AMPInvoiceState, rhs: Lnrpc_AMPInvoiceState) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.settleIndex != rhs.settleIndex {return false}
    if lhs.settleTime != rhs.settleTime {return false}
    if lhs.amtPaidMsat != rhs.amtPaidMsat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_Invoice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Invoice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "memo"),
    3: .standard(proto: "r_preimage"),
    4: .standard(proto: "r_hash"),
    5: .same(proto: "value"),
    23: .standard(proto: "value_msat"),
    6: .same(proto: "settled"),
    7: .standard(proto: "creation_date"),
    8: .standard(proto: "settle_date"),
    9: .standard(proto: "payment_request"),
    10: .standard(proto: "description_hash"),
    11: .same(proto: "expiry"),
    12: .standard(proto: "fallback_addr"),
    13: .standard(proto: "cltv_expiry"),
    14: .standard(proto: "route_hints"),
    15: .same(proto: "private"),
    16: .standard(proto: "add_index"),
    17: .standard(proto: "settle_index"),
    18: .standard(proto: "amt_paid"),
    19: .standard(proto: "amt_paid_sat"),
    20: .standard(proto: "amt_paid_msat"),
    21: .same(proto: "state"),
    22: .same(proto: "htlcs"),
    24: .same(proto: "features"),
    25: .standard(proto: "is_keysend"),
    26: .standard(proto: "payment_addr"),
    27: .standard(proto: "is_amp"),
    28: .standard(proto: "amp_invoice_state"),
  ]

  fileprivate class _StorageClass {
    var _memo: String = String()
    var _rPreimage: Data = Data()
    var _rHash: Data = Data()
    var _value: Int64 = 0
    var _valueMsat: Int64 = 0
    var _settled: Bool = false
    var _creationDate: Int64 = 0
    var _settleDate: Int64 = 0
    var _paymentRequest: String = String()
    var _descriptionHash: Data = Data()
    var _expiry: Int64 = 0
    var _fallbackAddr: String = String()
    var _cltvExpiry: UInt64 = 0
    var _routeHints: [Lnrpc_RouteHint] = []
    var _private: Bool = false
    var _addIndex: UInt64 = 0
    var _settleIndex: UInt64 = 0
    var _amtPaid: Int64 = 0
    var _amtPaidSat: Int64 = 0
    var _amtPaidMsat: Int64 = 0
    var _state: Lnrpc_Invoice.InvoiceState = .open
    var _htlcs: [Lnrpc_InvoiceHTLC] = []
    var _features: Dictionary<UInt32,Lnrpc_Feature> = [:]
    var _isKeysend: Bool = false
    var _paymentAddr: Data = Data()
    var _isAmp: Bool = false
    var _ampInvoiceState: Dictionary<String,Lnrpc_AMPInvoiceState> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _memo = source._memo
      _rPreimage = source._rPreimage
      _rHash = source._rHash
      _value = source._value
      _valueMsat = source._valueMsat
      _settled = source._settled
      _creationDate = source._creationDate
      _settleDate = source._settleDate
      _paymentRequest = source._paymentRequest
      _descriptionHash = source._descriptionHash
      _expiry = source._expiry
      _fallbackAddr = source._fallbackAddr
      _cltvExpiry = source._cltvExpiry
      _routeHints = source._routeHints
      _private = source._private
      _addIndex = source._addIndex
      _settleIndex = source._settleIndex
      _amtPaid = source._amtPaid
      _amtPaidSat = source._amtPaidSat
      _amtPaidMsat = source._amtPaidMsat
      _state = source._state
      _htlcs = source._htlcs
      _features = source._features
      _isKeysend = source._isKeysend
      _paymentAddr = source._paymentAddr
      _isAmp = source._isAmp
      _ampInvoiceState = source._ampInvoiceState
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._memo) }()
        case 3: try { try decoder.decodeSingularBytesField(value: &_storage._rPreimage) }()
        case 4: try { try decoder.decodeSingularBytesField(value: &_storage._rHash) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._value) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._settled) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._creationDate) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._settleDate) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._paymentRequest) }()
        case 10: try { try decoder.decodeSingularBytesField(value: &_storage._descriptionHash) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._expiry) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._fallbackAddr) }()
        case 13: try { try decoder.decodeSingularUInt64Field(value: &_storage._cltvExpiry) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._routeHints) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._private) }()
        case 16: try { try decoder.decodeSingularUInt64Field(value: &_storage._addIndex) }()
        case 17: try { try decoder.decodeSingularUInt64Field(value: &_storage._settleIndex) }()
        case 18: try { try decoder.decodeSingularInt64Field(value: &_storage._amtPaid) }()
        case 19: try { try decoder.decodeSingularInt64Field(value: &_storage._amtPaidSat) }()
        case 20: try { try decoder.decodeSingularInt64Field(value: &_storage._amtPaidMsat) }()
        case 21: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 22: try { try decoder.decodeRepeatedMessageField(value: &_storage._htlcs) }()
        case 23: try { try decoder.decodeSingularInt64Field(value: &_storage._valueMsat) }()
        case 24: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Lnrpc_Feature>.self, value: &_storage._features) }()
        case 25: try { try decoder.decodeSingularBoolField(value: &_storage._isKeysend) }()
        case 26: try { try decoder.decodeSingularBytesField(value: &_storage._paymentAddr) }()
        case 27: try { try decoder.decodeSingularBoolField(value: &_storage._isAmp) }()
        case 28: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Lnrpc_AMPInvoiceState>.self, value: &_storage._ampInvoiceState) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._memo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._memo, fieldNumber: 1)
      }
      if !_storage._rPreimage.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._rPreimage, fieldNumber: 3)
      }
      if !_storage._rHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._rHash, fieldNumber: 4)
      }
      if _storage._value != 0 {
        try visitor.visitSingularInt64Field(value: _storage._value, fieldNumber: 5)
      }
      if _storage._settled != false {
        try visitor.visitSingularBoolField(value: _storage._settled, fieldNumber: 6)
      }
      if _storage._creationDate != 0 {
        try visitor.visitSingularInt64Field(value: _storage._creationDate, fieldNumber: 7)
      }
      if _storage._settleDate != 0 {
        try visitor.visitSingularInt64Field(value: _storage._settleDate, fieldNumber: 8)
      }
      if !_storage._paymentRequest.isEmpty {
        try visitor.visitSingularStringField(value: _storage._paymentRequest, fieldNumber: 9)
      }
      if !_storage._descriptionHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._descriptionHash, fieldNumber: 10)
      }
      if _storage._expiry != 0 {
        try visitor.visitSingularInt64Field(value: _storage._expiry, fieldNumber: 11)
      }
      if !_storage._fallbackAddr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fallbackAddr, fieldNumber: 12)
      }
      if _storage._cltvExpiry != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._cltvExpiry, fieldNumber: 13)
      }
      if !_storage._routeHints.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._routeHints, fieldNumber: 14)
      }
      if _storage._private != false {
        try visitor.visitSingularBoolField(value: _storage._private, fieldNumber: 15)
      }
      if _storage._addIndex != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._addIndex, fieldNumber: 16)
      }
      if _storage._settleIndex != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._settleIndex, fieldNumber: 17)
      }
      if _storage._amtPaid != 0 {
        try visitor.visitSingularInt64Field(value: _storage._amtPaid, fieldNumber: 18)
      }
      if _storage._amtPaidSat != 0 {
        try visitor.visitSingularInt64Field(value: _storage._amtPaidSat, fieldNumber: 19)
      }
      if _storage._amtPaidMsat != 0 {
        try visitor.visitSingularInt64Field(value: _storage._amtPaidMsat, fieldNumber: 20)
      }
      if _storage._state != .open {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 21)
      }
      if !_storage._htlcs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._htlcs, fieldNumber: 22)
      }
      if _storage._valueMsat != 0 {
        try visitor.visitSingularInt64Field(value: _storage._valueMsat, fieldNumber: 23)
      }
      if !_storage._features.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Lnrpc_Feature>.self, value: _storage._features, fieldNumber: 24)
      }
      if _storage._isKeysend != false {
        try visitor.visitSingularBoolField(value: _storage._isKeysend, fieldNumber: 25)
      }
      if !_storage._paymentAddr.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._paymentAddr, fieldNumber: 26)
      }
      if _storage._isAmp != false {
        try visitor.visitSingularBoolField(value: _storage._isAmp, fieldNumber: 27)
      }
      if !_storage._ampInvoiceState.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Lnrpc_AMPInvoiceState>.self, value: _storage._ampInvoiceState, fieldNumber: 28)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_Invoice, rhs: Lnrpc_Invoice) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._rPreimage != rhs_storage._rPreimage {return false}
        if _storage._rHash != rhs_storage._rHash {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._valueMsat != rhs_storage._valueMsat {return false}
        if _storage._settled != rhs_storage._settled {return false}
        if _storage._creationDate != rhs_storage._creationDate {return false}
        if _storage._settleDate != rhs_storage._settleDate {return false}
        if _storage._paymentRequest != rhs_storage._paymentRequest {return false}
        if _storage._descriptionHash != rhs_storage._descriptionHash {return false}
        if _storage._expiry != rhs_storage._expiry {return false}
        if _storage._fallbackAddr != rhs_storage._fallbackAddr {return false}
        if _storage._cltvExpiry != rhs_storage._cltvExpiry {return false}
        if _storage._routeHints != rhs_storage._routeHints {return false}
        if _storage._private != rhs_storage._private {return false}
        if _storage._addIndex != rhs_storage._addIndex {return false}
        if _storage._settleIndex != rhs_storage._settleIndex {return false}
        if _storage._amtPaid != rhs_storage._amtPaid {return false}
        if _storage._amtPaidSat != rhs_storage._amtPaidSat {return false}
        if _storage._amtPaidMsat != rhs_storage._amtPaidMsat {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._htlcs != rhs_storage._htlcs {return false}
        if _storage._features != rhs_storage._features {return false}
        if _storage._isKeysend != rhs_storage._isKeysend {return false}
        if _storage._paymentAddr != rhs_storage._paymentAddr {return false}
        if _storage._isAmp != rhs_storage._isAmp {return false}
        if _storage._ampInvoiceState != rhs_storage._ampInvoiceState {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_Invoice.InvoiceState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPEN"),
    1: .same(proto: "SETTLED"),
    2: .same(proto: "CANCELED"),
    3: .same(proto: "ACCEPTED"),
  ]
}

extension Lnrpc_InvoiceHTLC: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InvoiceHTLC"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chan_id"),
    2: .standard(proto: "htlc_index"),
    3: .standard(proto: "amt_msat"),
    4: .standard(proto: "accept_height"),
    5: .standard(proto: "accept_time"),
    6: .standard(proto: "resolve_time"),
    7: .standard(proto: "expiry_height"),
    8: .same(proto: "state"),
    9: .standard(proto: "custom_records"),
    10: .standard(proto: "mpp_total_amt_msat"),
    11: .same(proto: "amp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.chanID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.htlcIndex) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.amtMsat) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.acceptHeight) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.acceptTime) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.resolveTime) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.expiryHeight) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 9: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt64,SwiftProtobuf.ProtobufBytes>.self, value: &self.customRecords) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self.mppTotalAmtMsat) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._amp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chanID != 0 {
      try visitor.visitSingularUInt64Field(value: self.chanID, fieldNumber: 1)
    }
    if self.htlcIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.htlcIndex, fieldNumber: 2)
    }
    if self.amtMsat != 0 {
      try visitor.visitSingularUInt64Field(value: self.amtMsat, fieldNumber: 3)
    }
    if self.acceptHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.acceptHeight, fieldNumber: 4)
    }
    if self.acceptTime != 0 {
      try visitor.visitSingularInt64Field(value: self.acceptTime, fieldNumber: 5)
    }
    if self.resolveTime != 0 {
      try visitor.visitSingularInt64Field(value: self.resolveTime, fieldNumber: 6)
    }
    if self.expiryHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.expiryHeight, fieldNumber: 7)
    }
    if self.state != .accepted {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 8)
    }
    if !self.customRecords.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt64,SwiftProtobuf.ProtobufBytes>.self, value: self.customRecords, fieldNumber: 9)
    }
    if self.mppTotalAmtMsat != 0 {
      try visitor.visitSingularUInt64Field(value: self.mppTotalAmtMsat, fieldNumber: 10)
    }
    if let v = self._amp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_InvoiceHTLC, rhs: Lnrpc_InvoiceHTLC) -> Bool {
    if lhs.chanID != rhs.chanID {return false}
    if lhs.htlcIndex != rhs.htlcIndex {return false}
    if lhs.amtMsat != rhs.amtMsat {return false}
    if lhs.acceptHeight != rhs.acceptHeight {return false}
    if lhs.acceptTime != rhs.acceptTime {return false}
    if lhs.resolveTime != rhs.resolveTime {return false}
    if lhs.expiryHeight != rhs.expiryHeight {return false}
    if lhs.state != rhs.state {return false}
    if lhs.customRecords != rhs.customRecords {return false}
    if lhs.mppTotalAmtMsat != rhs.mppTotalAmtMsat {return false}
    if lhs._amp != rhs._amp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_AMP: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AMP"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_share"),
    2: .standard(proto: "set_id"),
    3: .standard(proto: "child_index"),
    4: .same(proto: "hash"),
    5: .same(proto: "preimage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.rootShare) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.setID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.childIndex) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.preimage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rootShare.isEmpty {
      try visitor.visitSingularBytesField(value: self.rootShare, fieldNumber: 1)
    }
    if !self.setID.isEmpty {
      try visitor.visitSingularBytesField(value: self.setID, fieldNumber: 2)
    }
    if self.childIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.childIndex, fieldNumber: 3)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 4)
    }
    if !self.preimage.isEmpty {
      try visitor.visitSingularBytesField(value: self.preimage, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_AMP, rhs: Lnrpc_AMP) -> Bool {
    if lhs.rootShare != rhs.rootShare {return false}
    if lhs.setID != rhs.setID {return false}
    if lhs.childIndex != rhs.childIndex {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.preimage != rhs.preimage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_AddInvoiceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddInvoiceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "r_hash"),
    2: .standard(proto: "payment_request"),
    16: .standard(proto: "add_index"),
    17: .standard(proto: "payment_addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.rHash) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.paymentRequest) }()
      case 16: try { try decoder.decodeSingularUInt64Field(value: &self.addIndex) }()
      case 17: try { try decoder.decodeSingularBytesField(value: &self.paymentAddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.rHash, fieldNumber: 1)
    }
    if !self.paymentRequest.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentRequest, fieldNumber: 2)
    }
    if self.addIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.addIndex, fieldNumber: 16)
    }
    if !self.paymentAddr.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentAddr, fieldNumber: 17)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_AddInvoiceResponse, rhs: Lnrpc_AddInvoiceResponse) -> Bool {
    if lhs.rHash != rhs.rHash {return false}
    if lhs.paymentRequest != rhs.paymentRequest {return false}
    if lhs.addIndex != rhs.addIndex {return false}
    if lhs.paymentAddr != rhs.paymentAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PaymentHash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PaymentHash"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "r_hash_str"),
    2: .standard(proto: "r_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rHashStr) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.rHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rHashStr.isEmpty {
      try visitor.visitSingularStringField(value: self.rHashStr, fieldNumber: 1)
    }
    if !self.rHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.rHash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PaymentHash, rhs: Lnrpc_PaymentHash) -> Bool {
    if lhs.rHashStr != rhs.rHashStr {return false}
    if lhs.rHash != rhs.rHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ListInvoiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListInvoiceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pending_only"),
    4: .standard(proto: "index_offset"),
    5: .standard(proto: "num_max_invoices"),
    6: .same(proto: "reversed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.pendingOnly) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.indexOffset) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.numMaxInvoices) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.reversed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pendingOnly != false {
      try visitor.visitSingularBoolField(value: self.pendingOnly, fieldNumber: 1)
    }
    if self.indexOffset != 0 {
      try visitor.visitSingularUInt64Field(value: self.indexOffset, fieldNumber: 4)
    }
    if self.numMaxInvoices != 0 {
      try visitor.visitSingularUInt64Field(value: self.numMaxInvoices, fieldNumber: 5)
    }
    if self.reversed != false {
      try visitor.visitSingularBoolField(value: self.reversed, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ListInvoiceRequest, rhs: Lnrpc_ListInvoiceRequest) -> Bool {
    if lhs.pendingOnly != rhs.pendingOnly {return false}
    if lhs.indexOffset != rhs.indexOffset {return false}
    if lhs.numMaxInvoices != rhs.numMaxInvoices {return false}
    if lhs.reversed != rhs.reversed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ListInvoiceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListInvoiceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invoices"),
    2: .standard(proto: "last_index_offset"),
    3: .standard(proto: "first_index_offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.invoices) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.lastIndexOffset) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.firstIndexOffset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.invoices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.invoices, fieldNumber: 1)
    }
    if self.lastIndexOffset != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastIndexOffset, fieldNumber: 2)
    }
    if self.firstIndexOffset != 0 {
      try visitor.visitSingularUInt64Field(value: self.firstIndexOffset, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ListInvoiceResponse, rhs: Lnrpc_ListInvoiceResponse) -> Bool {
    if lhs.invoices != rhs.invoices {return false}
    if lhs.lastIndexOffset != rhs.lastIndexOffset {return false}
    if lhs.firstIndexOffset != rhs.firstIndexOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_InvoiceSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InvoiceSubscription"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "add_index"),
    2: .standard(proto: "settle_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.addIndex) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.settleIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.addIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.addIndex, fieldNumber: 1)
    }
    if self.settleIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.settleIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_InvoiceSubscription, rhs: Lnrpc_InvoiceSubscription) -> Bool {
    if lhs.addIndex != rhs.addIndex {return false}
    if lhs.settleIndex != rhs.settleIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_Payment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Payment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "payment_hash"),
    2: .same(proto: "value"),
    3: .standard(proto: "creation_date"),
    5: .same(proto: "fee"),
    6: .standard(proto: "payment_preimage"),
    7: .standard(proto: "value_sat"),
    8: .standard(proto: "value_msat"),
    9: .standard(proto: "payment_request"),
    10: .same(proto: "status"),
    11: .standard(proto: "fee_sat"),
    12: .standard(proto: "fee_msat"),
    13: .standard(proto: "creation_time_ns"),
    14: .same(proto: "htlcs"),
    15: .standard(proto: "payment_index"),
    16: .standard(proto: "failure_reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.paymentHash) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.creationDate) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.fee) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.paymentPreimage) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.valueSat) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.valueMsat) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.paymentRequest) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.feeSat) }()
      case 12: try { try decoder.decodeSingularInt64Field(value: &self.feeMsat) }()
      case 13: try { try decoder.decodeSingularInt64Field(value: &self.creationTimeNs) }()
      case 14: try { try decoder.decodeRepeatedMessageField(value: &self.htlcs) }()
      case 15: try { try decoder.decodeSingularUInt64Field(value: &self.paymentIndex) }()
      case 16: try { try decoder.decodeSingularEnumField(value: &self.failureReason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentHash, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 2)
    }
    if self.creationDate != 0 {
      try visitor.visitSingularInt64Field(value: self.creationDate, fieldNumber: 3)
    }
    if self.fee != 0 {
      try visitor.visitSingularInt64Field(value: self.fee, fieldNumber: 5)
    }
    if !self.paymentPreimage.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentPreimage, fieldNumber: 6)
    }
    if self.valueSat != 0 {
      try visitor.visitSingularInt64Field(value: self.valueSat, fieldNumber: 7)
    }
    if self.valueMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.valueMsat, fieldNumber: 8)
    }
    if !self.paymentRequest.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentRequest, fieldNumber: 9)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 10)
    }
    if self.feeSat != 0 {
      try visitor.visitSingularInt64Field(value: self.feeSat, fieldNumber: 11)
    }
    if self.feeMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.feeMsat, fieldNumber: 12)
    }
    if self.creationTimeNs != 0 {
      try visitor.visitSingularInt64Field(value: self.creationTimeNs, fieldNumber: 13)
    }
    if !self.htlcs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.htlcs, fieldNumber: 14)
    }
    if self.paymentIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.paymentIndex, fieldNumber: 15)
    }
    if self.failureReason != .failureReasonNone {
      try visitor.visitSingularEnumField(value: self.failureReason, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_Payment, rhs: Lnrpc_Payment) -> Bool {
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.value != rhs.value {return false}
    if lhs.creationDate != rhs.creationDate {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.paymentPreimage != rhs.paymentPreimage {return false}
    if lhs.valueSat != rhs.valueSat {return false}
    if lhs.valueMsat != rhs.valueMsat {return false}
    if lhs.paymentRequest != rhs.paymentRequest {return false}
    if lhs.status != rhs.status {return false}
    if lhs.feeSat != rhs.feeSat {return false}
    if lhs.feeMsat != rhs.feeMsat {return false}
    if lhs.creationTimeNs != rhs.creationTimeNs {return false}
    if lhs.htlcs != rhs.htlcs {return false}
    if lhs.paymentIndex != rhs.paymentIndex {return false}
    if lhs.failureReason != rhs.failureReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_Payment.PaymentStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "IN_FLIGHT"),
    2: .same(proto: "SUCCEEDED"),
    3: .same(proto: "FAILED"),
  ]
}

extension Lnrpc_HTLCAttempt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HTLCAttempt"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    7: .standard(proto: "attempt_id"),
    1: .same(proto: "status"),
    2: .same(proto: "route"),
    3: .standard(proto: "attempt_time_ns"),
    4: .standard(proto: "resolve_time_ns"),
    5: .same(proto: "failure"),
    6: .same(proto: "preimage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._route) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.attemptTimeNs) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.resolveTimeNs) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.preimage) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.attemptID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .inFlight {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if let v = self._route {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.attemptTimeNs != 0 {
      try visitor.visitSingularInt64Field(value: self.attemptTimeNs, fieldNumber: 3)
    }
    if self.resolveTimeNs != 0 {
      try visitor.visitSingularInt64Field(value: self.resolveTimeNs, fieldNumber: 4)
    }
    if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.preimage.isEmpty {
      try visitor.visitSingularBytesField(value: self.preimage, fieldNumber: 6)
    }
    if self.attemptID != 0 {
      try visitor.visitSingularUInt64Field(value: self.attemptID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_HTLCAttempt, rhs: Lnrpc_HTLCAttempt) -> Bool {
    if lhs.attemptID != rhs.attemptID {return false}
    if lhs.status != rhs.status {return false}
    if lhs._route != rhs._route {return false}
    if lhs.attemptTimeNs != rhs.attemptTimeNs {return false}
    if lhs.resolveTimeNs != rhs.resolveTimeNs {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.preimage != rhs.preimage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_HTLCAttempt.HTLCStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IN_FLIGHT"),
    1: .same(proto: "SUCCEEDED"),
    2: .same(proto: "FAILED"),
  ]
}

extension Lnrpc_ListPaymentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPaymentsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "include_incomplete"),
    2: .standard(proto: "index_offset"),
    3: .standard(proto: "max_payments"),
    4: .same(proto: "reversed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.includeIncomplete) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.indexOffset) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.maxPayments) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.reversed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.includeIncomplete != false {
      try visitor.visitSingularBoolField(value: self.includeIncomplete, fieldNumber: 1)
    }
    if self.indexOffset != 0 {
      try visitor.visitSingularUInt64Field(value: self.indexOffset, fieldNumber: 2)
    }
    if self.maxPayments != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxPayments, fieldNumber: 3)
    }
    if self.reversed != false {
      try visitor.visitSingularBoolField(value: self.reversed, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ListPaymentsRequest, rhs: Lnrpc_ListPaymentsRequest) -> Bool {
    if lhs.includeIncomplete != rhs.includeIncomplete {return false}
    if lhs.indexOffset != rhs.indexOffset {return false}
    if lhs.maxPayments != rhs.maxPayments {return false}
    if lhs.reversed != rhs.reversed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ListPaymentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPaymentsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payments"),
    2: .standard(proto: "first_index_offset"),
    3: .standard(proto: "last_index_offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.payments) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.firstIndexOffset) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.lastIndexOffset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.payments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payments, fieldNumber: 1)
    }
    if self.firstIndexOffset != 0 {
      try visitor.visitSingularUInt64Field(value: self.firstIndexOffset, fieldNumber: 2)
    }
    if self.lastIndexOffset != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastIndexOffset, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ListPaymentsResponse, rhs: Lnrpc_ListPaymentsResponse) -> Bool {
    if lhs.payments != rhs.payments {return false}
    if lhs.firstIndexOffset != rhs.firstIndexOffset {return false}
    if lhs.lastIndexOffset != rhs.lastIndexOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_DeletePaymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeletePaymentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "payment_hash"),
    2: .standard(proto: "failed_htlcs_only"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.failedHtlcsOnly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 1)
    }
    if self.failedHtlcsOnly != false {
      try visitor.visitSingularBoolField(value: self.failedHtlcsOnly, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_DeletePaymentRequest, rhs: Lnrpc_DeletePaymentRequest) -> Bool {
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.failedHtlcsOnly != rhs.failedHtlcsOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_DeleteAllPaymentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAllPaymentsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "failed_payments_only"),
    2: .standard(proto: "failed_htlcs_only"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.failedPaymentsOnly) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.failedHtlcsOnly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.failedPaymentsOnly != false {
      try visitor.visitSingularBoolField(value: self.failedPaymentsOnly, fieldNumber: 1)
    }
    if self.failedHtlcsOnly != false {
      try visitor.visitSingularBoolField(value: self.failedHtlcsOnly, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_DeleteAllPaymentsRequest, rhs: Lnrpc_DeleteAllPaymentsRequest) -> Bool {
    if lhs.failedPaymentsOnly != rhs.failedPaymentsOnly {return false}
    if lhs.failedHtlcsOnly != rhs.failedHtlcsOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_DeletePaymentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeletePaymentResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_DeletePaymentResponse, rhs: Lnrpc_DeletePaymentResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_DeleteAllPaymentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAllPaymentsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_DeleteAllPaymentsResponse, rhs: Lnrpc_DeleteAllPaymentsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_AbandonChannelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AbandonChannelRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_point"),
    2: .standard(proto: "pending_funding_shim_only"),
    3: .standard(proto: "i_know_what_i_am_doing"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._channelPoint) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.pendingFundingShimOnly) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.iKnowWhatIAmDoing) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._channelPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.pendingFundingShimOnly != false {
      try visitor.visitSingularBoolField(value: self.pendingFundingShimOnly, fieldNumber: 2)
    }
    if self.iKnowWhatIAmDoing != false {
      try visitor.visitSingularBoolField(value: self.iKnowWhatIAmDoing, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_AbandonChannelRequest, rhs: Lnrpc_AbandonChannelRequest) -> Bool {
    if lhs._channelPoint != rhs._channelPoint {return false}
    if lhs.pendingFundingShimOnly != rhs.pendingFundingShimOnly {return false}
    if lhs.iKnowWhatIAmDoing != rhs.iKnowWhatIAmDoing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_AbandonChannelResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AbandonChannelResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_AbandonChannelResponse, rhs: Lnrpc_AbandonChannelResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_DebugLevelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebugLevelRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "show"),
    2: .standard(proto: "level_spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.show) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.levelSpec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.show != false {
      try visitor.visitSingularBoolField(value: self.show, fieldNumber: 1)
    }
    if !self.levelSpec.isEmpty {
      try visitor.visitSingularStringField(value: self.levelSpec, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_DebugLevelRequest, rhs: Lnrpc_DebugLevelRequest) -> Bool {
    if lhs.show != rhs.show {return false}
    if lhs.levelSpec != rhs.levelSpec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_DebugLevelResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebugLevelResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sub_systems"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subSystems) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subSystems.isEmpty {
      try visitor.visitSingularStringField(value: self.subSystems, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_DebugLevelResponse, rhs: Lnrpc_DebugLevelResponse) -> Bool {
    if lhs.subSystems != rhs.subSystems {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PayReqString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PayReqString"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pay_req"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.payReq) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.payReq.isEmpty {
      try visitor.visitSingularStringField(value: self.payReq, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PayReqString, rhs: Lnrpc_PayReqString) -> Bool {
    if lhs.payReq != rhs.payReq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PayReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PayReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "destination"),
    2: .standard(proto: "payment_hash"),
    3: .standard(proto: "num_satoshis"),
    4: .same(proto: "timestamp"),
    5: .same(proto: "expiry"),
    6: .same(proto: "description"),
    7: .standard(proto: "description_hash"),
    8: .standard(proto: "fallback_addr"),
    9: .standard(proto: "cltv_expiry"),
    10: .standard(proto: "route_hints"),
    11: .standard(proto: "payment_addr"),
    12: .standard(proto: "num_msat"),
    13: .same(proto: "features"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.destination) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.paymentHash) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.numSatoshis) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.expiry) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.descriptionHash) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.fallbackAddr) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.cltvExpiry) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.routeHints) }()
      case 11: try { try decoder.decodeSingularBytesField(value: &self.paymentAddr) }()
      case 12: try { try decoder.decodeSingularInt64Field(value: &self.numMsat) }()
      case 13: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Lnrpc_Feature>.self, value: &self.features) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.destination.isEmpty {
      try visitor.visitSingularStringField(value: self.destination, fieldNumber: 1)
    }
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentHash, fieldNumber: 2)
    }
    if self.numSatoshis != 0 {
      try visitor.visitSingularInt64Field(value: self.numSatoshis, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    if self.expiry != 0 {
      try visitor.visitSingularInt64Field(value: self.expiry, fieldNumber: 5)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 6)
    }
    if !self.descriptionHash.isEmpty {
      try visitor.visitSingularStringField(value: self.descriptionHash, fieldNumber: 7)
    }
    if !self.fallbackAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.fallbackAddr, fieldNumber: 8)
    }
    if self.cltvExpiry != 0 {
      try visitor.visitSingularInt64Field(value: self.cltvExpiry, fieldNumber: 9)
    }
    if !self.routeHints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.routeHints, fieldNumber: 10)
    }
    if !self.paymentAddr.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentAddr, fieldNumber: 11)
    }
    if self.numMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.numMsat, fieldNumber: 12)
    }
    if !self.features.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Lnrpc_Feature>.self, value: self.features, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PayReq, rhs: Lnrpc_PayReq) -> Bool {
    if lhs.destination != rhs.destination {return false}
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.numSatoshis != rhs.numSatoshis {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.expiry != rhs.expiry {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.descriptionHash != rhs.descriptionHash {return false}
    if lhs.fallbackAddr != rhs.fallbackAddr {return false}
    if lhs.cltvExpiry != rhs.cltvExpiry {return false}
    if lhs.routeHints != rhs.routeHints {return false}
    if lhs.paymentAddr != rhs.paymentAddr {return false}
    if lhs.numMsat != rhs.numMsat {return false}
    if lhs.features != rhs.features {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_Feature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Feature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "name"),
    3: .standard(proto: "is_required"),
    4: .standard(proto: "is_known"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isRequired) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isKnown) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.isRequired != false {
      try visitor.visitSingularBoolField(value: self.isRequired, fieldNumber: 3)
    }
    if self.isKnown != false {
      try visitor.visitSingularBoolField(value: self.isKnown, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_Feature, rhs: Lnrpc_Feature) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.isRequired != rhs.isRequired {return false}
    if lhs.isKnown != rhs.isKnown {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_FeeReportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeReportRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_FeeReportRequest, rhs: Lnrpc_FeeReportRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelFeeReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelFeeReport"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .standard(proto: "chan_id"),
    1: .standard(proto: "channel_point"),
    2: .standard(proto: "base_fee_msat"),
    3: .standard(proto: "fee_per_mil"),
    4: .standard(proto: "fee_rate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelPoint) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.baseFeeMsat) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.feePerMil) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.feeRate) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.chanID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelPoint.isEmpty {
      try visitor.visitSingularStringField(value: self.channelPoint, fieldNumber: 1)
    }
    if self.baseFeeMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.baseFeeMsat, fieldNumber: 2)
    }
    if self.feePerMil != 0 {
      try visitor.visitSingularInt64Field(value: self.feePerMil, fieldNumber: 3)
    }
    if self.feeRate != 0 {
      try visitor.visitSingularDoubleField(value: self.feeRate, fieldNumber: 4)
    }
    if self.chanID != 0 {
      try visitor.visitSingularUInt64Field(value: self.chanID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelFeeReport, rhs: Lnrpc_ChannelFeeReport) -> Bool {
    if lhs.chanID != rhs.chanID {return false}
    if lhs.channelPoint != rhs.channelPoint {return false}
    if lhs.baseFeeMsat != rhs.baseFeeMsat {return false}
    if lhs.feePerMil != rhs.feePerMil {return false}
    if lhs.feeRate != rhs.feeRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_FeeReportResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeReportResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_fees"),
    2: .standard(proto: "day_fee_sum"),
    3: .standard(proto: "week_fee_sum"),
    4: .standard(proto: "month_fee_sum"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.channelFees) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.dayFeeSum) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.weekFeeSum) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.monthFeeSum) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelFees.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channelFees, fieldNumber: 1)
    }
    if self.dayFeeSum != 0 {
      try visitor.visitSingularUInt64Field(value: self.dayFeeSum, fieldNumber: 2)
    }
    if self.weekFeeSum != 0 {
      try visitor.visitSingularUInt64Field(value: self.weekFeeSum, fieldNumber: 3)
    }
    if self.monthFeeSum != 0 {
      try visitor.visitSingularUInt64Field(value: self.monthFeeSum, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_FeeReportResponse, rhs: Lnrpc_FeeReportResponse) -> Bool {
    if lhs.channelFees != rhs.channelFees {return false}
    if lhs.dayFeeSum != rhs.dayFeeSum {return false}
    if lhs.weekFeeSum != rhs.weekFeeSum {return false}
    if lhs.monthFeeSum != rhs.monthFeeSum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PolicyUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PolicyUpdateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "global"),
    2: .standard(proto: "chan_point"),
    3: .standard(proto: "base_fee_msat"),
    4: .standard(proto: "fee_rate"),
    5: .standard(proto: "time_lock_delta"),
    6: .standard(proto: "max_htlc_msat"),
    7: .standard(proto: "min_htlc_msat"),
    8: .standard(proto: "min_htlc_msat_specified"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.scope != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.scope = .global(v)}
      }()
      case 2: try {
        var v: Lnrpc_ChannelPoint?
        if let current = self.scope {
          try decoder.handleConflictingOneOf()
          if case .chanPoint(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.scope = .chanPoint(v)}
      }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.baseFeeMsat) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.feeRate) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.timeLockDelta) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.maxHtlcMsat) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.minHtlcMsat) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.minHtlcMsatSpecified) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.scope {
    case .global?: try {
      guard case .global(let v)? = self.scope else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .chanPoint?: try {
      guard case .chanPoint(let v)? = self.scope else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if self.baseFeeMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.baseFeeMsat, fieldNumber: 3)
    }
    if self.feeRate != 0 {
      try visitor.visitSingularDoubleField(value: self.feeRate, fieldNumber: 4)
    }
    if self.timeLockDelta != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeLockDelta, fieldNumber: 5)
    }
    if self.maxHtlcMsat != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxHtlcMsat, fieldNumber: 6)
    }
    if self.minHtlcMsat != 0 {
      try visitor.visitSingularUInt64Field(value: self.minHtlcMsat, fieldNumber: 7)
    }
    if self.minHtlcMsatSpecified != false {
      try visitor.visitSingularBoolField(value: self.minHtlcMsatSpecified, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PolicyUpdateRequest, rhs: Lnrpc_PolicyUpdateRequest) -> Bool {
    if lhs.scope != rhs.scope {return false}
    if lhs.baseFeeMsat != rhs.baseFeeMsat {return false}
    if lhs.feeRate != rhs.feeRate {return false}
    if lhs.timeLockDelta != rhs.timeLockDelta {return false}
    if lhs.maxHtlcMsat != rhs.maxHtlcMsat {return false}
    if lhs.minHtlcMsat != rhs.minHtlcMsat {return false}
    if lhs.minHtlcMsatSpecified != rhs.minHtlcMsatSpecified {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_FailedUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FailedUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outpoint"),
    2: .same(proto: "reason"),
    3: .standard(proto: "update_error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._outpoint) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.updateError) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.reason != .unknown {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    if !self.updateError.isEmpty {
      try visitor.visitSingularStringField(value: self.updateError, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_FailedUpdate, rhs: Lnrpc_FailedUpdate) -> Bool {
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.updateError != rhs.updateError {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PolicyUpdateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PolicyUpdateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "failed_updates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.failedUpdates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.failedUpdates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.failedUpdates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PolicyUpdateResponse, rhs: Lnrpc_PolicyUpdateResponse) -> Bool {
    if lhs.failedUpdates != rhs.failedUpdates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ForwardingHistoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ForwardingHistoryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .standard(proto: "end_time"),
    3: .standard(proto: "index_offset"),
    4: .standard(proto: "num_max_events"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.startTime) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.endTime) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.indexOffset) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.numMaxEvents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.startTime, fieldNumber: 1)
    }
    if self.endTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.endTime, fieldNumber: 2)
    }
    if self.indexOffset != 0 {
      try visitor.visitSingularUInt32Field(value: self.indexOffset, fieldNumber: 3)
    }
    if self.numMaxEvents != 0 {
      try visitor.visitSingularUInt32Field(value: self.numMaxEvents, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ForwardingHistoryRequest, rhs: Lnrpc_ForwardingHistoryRequest) -> Bool {
    if lhs.startTime != rhs.startTime {return false}
    if lhs.endTime != rhs.endTime {return false}
    if lhs.indexOffset != rhs.indexOffset {return false}
    if lhs.numMaxEvents != rhs.numMaxEvents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ForwardingEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ForwardingEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "chan_id_in"),
    4: .standard(proto: "chan_id_out"),
    5: .standard(proto: "amt_in"),
    6: .standard(proto: "amt_out"),
    7: .same(proto: "fee"),
    8: .standard(proto: "fee_msat"),
    9: .standard(proto: "amt_in_msat"),
    10: .standard(proto: "amt_out_msat"),
    11: .standard(proto: "timestamp_ns"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.chanIDIn) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.chanIDOut) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.amtIn) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.amtOut) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.fee) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.feeMsat) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.amtInMsat) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self.amtOutMsat) }()
      case 11: try { try decoder.decodeSingularUInt64Field(value: &self.timestampNs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if self.chanIDIn != 0 {
      try visitor.visitSingularUInt64Field(value: self.chanIDIn, fieldNumber: 2)
    }
    if self.chanIDOut != 0 {
      try visitor.visitSingularUInt64Field(value: self.chanIDOut, fieldNumber: 4)
    }
    if self.amtIn != 0 {
      try visitor.visitSingularUInt64Field(value: self.amtIn, fieldNumber: 5)
    }
    if self.amtOut != 0 {
      try visitor.visitSingularUInt64Field(value: self.amtOut, fieldNumber: 6)
    }
    if self.fee != 0 {
      try visitor.visitSingularUInt64Field(value: self.fee, fieldNumber: 7)
    }
    if self.feeMsat != 0 {
      try visitor.visitSingularUInt64Field(value: self.feeMsat, fieldNumber: 8)
    }
    if self.amtInMsat != 0 {
      try visitor.visitSingularUInt64Field(value: self.amtInMsat, fieldNumber: 9)
    }
    if self.amtOutMsat != 0 {
      try visitor.visitSingularUInt64Field(value: self.amtOutMsat, fieldNumber: 10)
    }
    if self.timestampNs != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestampNs, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ForwardingEvent, rhs: Lnrpc_ForwardingEvent) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.chanIDIn != rhs.chanIDIn {return false}
    if lhs.chanIDOut != rhs.chanIDOut {return false}
    if lhs.amtIn != rhs.amtIn {return false}
    if lhs.amtOut != rhs.amtOut {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.feeMsat != rhs.feeMsat {return false}
    if lhs.amtInMsat != rhs.amtInMsat {return false}
    if lhs.amtOutMsat != rhs.amtOutMsat {return false}
    if lhs.timestampNs != rhs.timestampNs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ForwardingHistoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ForwardingHistoryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "forwarding_events"),
    2: .standard(proto: "last_offset_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.forwardingEvents) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.lastOffsetIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.forwardingEvents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.forwardingEvents, fieldNumber: 1)
    }
    if self.lastOffsetIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.lastOffsetIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ForwardingHistoryResponse, rhs: Lnrpc_ForwardingHistoryResponse) -> Bool {
    if lhs.forwardingEvents != rhs.forwardingEvents {return false}
    if lhs.lastOffsetIndex != rhs.lastOffsetIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ExportChannelBackupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExportChannelBackupRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chan_point"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chanPoint) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._chanPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ExportChannelBackupRequest, rhs: Lnrpc_ExportChannelBackupRequest) -> Bool {
    if lhs._chanPoint != rhs._chanPoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelBackup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelBackup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chan_point"),
    2: .standard(proto: "chan_backup"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chanPoint) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.chanBackup) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._chanPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.chanBackup.isEmpty {
      try visitor.visitSingularBytesField(value: self.chanBackup, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelBackup, rhs: Lnrpc_ChannelBackup) -> Bool {
    if lhs._chanPoint != rhs._chanPoint {return false}
    if lhs.chanBackup != rhs.chanBackup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_MultiChanBackup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MultiChanBackup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chan_points"),
    2: .standard(proto: "multi_chan_backup"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.chanPoints) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.multiChanBackup) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chanPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chanPoints, fieldNumber: 1)
    }
    if !self.multiChanBackup.isEmpty {
      try visitor.visitSingularBytesField(value: self.multiChanBackup, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_MultiChanBackup, rhs: Lnrpc_MultiChanBackup) -> Bool {
    if lhs.chanPoints != rhs.chanPoints {return false}
    if lhs.multiChanBackup != rhs.multiChanBackup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChanBackupExportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChanBackupExportRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChanBackupExportRequest, rhs: Lnrpc_ChanBackupExportRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChanBackupSnapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChanBackupSnapshot"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "single_chan_backups"),
    2: .standard(proto: "multi_chan_backup"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._singleChanBackups) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._multiChanBackup) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._singleChanBackups {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._multiChanBackup {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChanBackupSnapshot, rhs: Lnrpc_ChanBackupSnapshot) -> Bool {
    if lhs._singleChanBackups != rhs._singleChanBackups {return false}
    if lhs._multiChanBackup != rhs._multiChanBackup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelBackups: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelBackups"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chan_backups"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.chanBackups) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chanBackups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chanBackups, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelBackups, rhs: Lnrpc_ChannelBackups) -> Bool {
    if lhs.chanBackups != rhs.chanBackups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_RestoreChanBackupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RestoreChanBackupRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chan_backups"),
    2: .standard(proto: "multi_chan_backup"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Lnrpc_ChannelBackups?
        if let current = self.backup {
          try decoder.handleConflictingOneOf()
          if case .chanBackups(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.backup = .chanBackups(v)}
      }()
      case 2: try {
        if self.backup != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.backup = .multiChanBackup(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.backup {
    case .chanBackups?: try {
      guard case .chanBackups(let v)? = self.backup else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .multiChanBackup?: try {
      guard case .multiChanBackup(let v)? = self.backup else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_RestoreChanBackupRequest, rhs: Lnrpc_RestoreChanBackupRequest) -> Bool {
    if lhs.backup != rhs.backup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_RestoreBackupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RestoreBackupResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_RestoreBackupResponse, rhs: Lnrpc_RestoreBackupResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelBackupSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelBackupSubscription"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelBackupSubscription, rhs: Lnrpc_ChannelBackupSubscription) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_VerifyChanBackupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyChanBackupResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_VerifyChanBackupResponse, rhs: Lnrpc_VerifyChanBackupResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_MacaroonPermission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MacaroonPermission"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entity"),
    2: .same(proto: "action"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.entity) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entity.isEmpty {
      try visitor.visitSingularStringField(value: self.entity, fieldNumber: 1)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_MacaroonPermission, rhs: Lnrpc_MacaroonPermission) -> Bool {
    if lhs.entity != rhs.entity {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_BakeMacaroonRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BakeMacaroonRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "permissions"),
    2: .standard(proto: "root_key_id"),
    3: .standard(proto: "allow_external_permissions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.permissions) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.rootKeyID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.allowExternalPermissions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.permissions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.permissions, fieldNumber: 1)
    }
    if self.rootKeyID != 0 {
      try visitor.visitSingularUInt64Field(value: self.rootKeyID, fieldNumber: 2)
    }
    if self.allowExternalPermissions != false {
      try visitor.visitSingularBoolField(value: self.allowExternalPermissions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_BakeMacaroonRequest, rhs: Lnrpc_BakeMacaroonRequest) -> Bool {
    if lhs.permissions != rhs.permissions {return false}
    if lhs.rootKeyID != rhs.rootKeyID {return false}
    if lhs.allowExternalPermissions != rhs.allowExternalPermissions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_BakeMacaroonResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BakeMacaroonResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "macaroon"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.macaroon) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.macaroon.isEmpty {
      try visitor.visitSingularStringField(value: self.macaroon, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_BakeMacaroonResponse, rhs: Lnrpc_BakeMacaroonResponse) -> Bool {
    if lhs.macaroon != rhs.macaroon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ListMacaroonIDsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListMacaroonIDsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ListMacaroonIDsRequest, rhs: Lnrpc_ListMacaroonIDsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ListMacaroonIDsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListMacaroonIDsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_key_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.rootKeyIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rootKeyIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.rootKeyIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ListMacaroonIDsResponse, rhs: Lnrpc_ListMacaroonIDsResponse) -> Bool {
    if lhs.rootKeyIds != rhs.rootKeyIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_DeleteMacaroonIDRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteMacaroonIDRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_key_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.rootKeyID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rootKeyID != 0 {
      try visitor.visitSingularUInt64Field(value: self.rootKeyID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_DeleteMacaroonIDRequest, rhs: Lnrpc_DeleteMacaroonIDRequest) -> Bool {
    if lhs.rootKeyID != rhs.rootKeyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_DeleteMacaroonIDResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteMacaroonIDResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deleted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.deleted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.deleted != false {
      try visitor.visitSingularBoolField(value: self.deleted, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_DeleteMacaroonIDResponse, rhs: Lnrpc_DeleteMacaroonIDResponse) -> Bool {
    if lhs.deleted != rhs.deleted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_MacaroonPermissionList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MacaroonPermissionList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "permissions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.permissions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.permissions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.permissions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_MacaroonPermissionList, rhs: Lnrpc_MacaroonPermissionList) -> Bool {
    if lhs.permissions != rhs.permissions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ListPermissionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPermissionsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ListPermissionsRequest, rhs: Lnrpc_ListPermissionsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ListPermissionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPermissionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "method_permissions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Lnrpc_MacaroonPermissionList>.self, value: &self.methodPermissions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.methodPermissions.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Lnrpc_MacaroonPermissionList>.self, value: self.methodPermissions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ListPermissionsResponse, rhs: Lnrpc_ListPermissionsResponse) -> Bool {
    if lhs.methodPermissions != rhs.methodPermissions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_Failure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Failure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    3: .standard(proto: "channel_update"),
    4: .standard(proto: "htlc_msat"),
    5: .standard(proto: "onion_sha_256"),
    6: .standard(proto: "cltv_expiry"),
    7: .same(proto: "flags"),
    8: .standard(proto: "failure_source_index"),
    9: .same(proto: "height"),
  ]

  fileprivate class _StorageClass {
    var _code: Lnrpc_Failure.FailureCode = .reserved
    var _channelUpdate: Lnrpc_ChannelUpdate? = nil
    var _htlcMsat: UInt64 = 0
    var _onionSha256: Data = Data()
    var _cltvExpiry: UInt32 = 0
    var _flags: UInt32 = 0
    var _failureSourceIndex: UInt32 = 0
    var _height: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _channelUpdate = source._channelUpdate
      _htlcMsat = source._htlcMsat
      _onionSha256 = source._onionSha256
      _cltvExpiry = source._cltvExpiry
      _flags = source._flags
      _failureSourceIndex = source._failureSourceIndex
      _height = source._height
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._code) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._channelUpdate) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._htlcMsat) }()
        case 5: try { try decoder.decodeSingularBytesField(value: &_storage._onionSha256) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._cltvExpiry) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._flags) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._failureSourceIndex) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._height) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .reserved {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._channelUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._htlcMsat != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._htlcMsat, fieldNumber: 4)
      }
      if !_storage._onionSha256.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._onionSha256, fieldNumber: 5)
      }
      if _storage._cltvExpiry != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._cltvExpiry, fieldNumber: 6)
      }
      if _storage._flags != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._flags, fieldNumber: 7)
      }
      if _storage._failureSourceIndex != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._failureSourceIndex, fieldNumber: 8)
      }
      if _storage._height != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._height, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_Failure, rhs: Lnrpc_Failure) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._channelUpdate != rhs_storage._channelUpdate {return false}
        if _storage._htlcMsat != rhs_storage._htlcMsat {return false}
        if _storage._onionSha256 != rhs_storage._onionSha256 {return false}
        if _storage._cltvExpiry != rhs_storage._cltvExpiry {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._failureSourceIndex != rhs_storage._failureSourceIndex {return false}
        if _storage._height != rhs_storage._height {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_Failure.FailureCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESERVED"),
    1: .same(proto: "INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS"),
    2: .same(proto: "INCORRECT_PAYMENT_AMOUNT"),
    3: .same(proto: "FINAL_INCORRECT_CLTV_EXPIRY"),
    4: .same(proto: "FINAL_INCORRECT_HTLC_AMOUNT"),
    5: .same(proto: "FINAL_EXPIRY_TOO_SOON"),
    6: .same(proto: "INVALID_REALM"),
    7: .same(proto: "EXPIRY_TOO_SOON"),
    8: .same(proto: "INVALID_ONION_VERSION"),
    9: .same(proto: "INVALID_ONION_HMAC"),
    10: .same(proto: "INVALID_ONION_KEY"),
    11: .same(proto: "AMOUNT_BELOW_MINIMUM"),
    12: .same(proto: "FEE_INSUFFICIENT"),
    13: .same(proto: "INCORRECT_CLTV_EXPIRY"),
    14: .same(proto: "CHANNEL_DISABLED"),
    15: .same(proto: "TEMPORARY_CHANNEL_FAILURE"),
    16: .same(proto: "REQUIRED_NODE_FEATURE_MISSING"),
    17: .same(proto: "REQUIRED_CHANNEL_FEATURE_MISSING"),
    18: .same(proto: "UNKNOWN_NEXT_PEER"),
    19: .same(proto: "TEMPORARY_NODE_FAILURE"),
    20: .same(proto: "PERMANENT_NODE_FAILURE"),
    21: .same(proto: "PERMANENT_CHANNEL_FAILURE"),
    22: .same(proto: "EXPIRY_TOO_FAR"),
    23: .same(proto: "MPP_TIMEOUT"),
    24: .same(proto: "INVALID_ONION_PAYLOAD"),
    997: .same(proto: "INTERNAL_FAILURE"),
    998: .same(proto: "UNKNOWN_FAILURE"),
    999: .same(proto: "UNREADABLE_FAILURE"),
  ]
}

extension Lnrpc_ChannelUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signature"),
    2: .standard(proto: "chain_hash"),
    3: .standard(proto: "chan_id"),
    4: .same(proto: "timestamp"),
    10: .standard(proto: "message_flags"),
    5: .standard(proto: "channel_flags"),
    6: .standard(proto: "time_lock_delta"),
    7: .standard(proto: "htlc_minimum_msat"),
    8: .standard(proto: "base_fee"),
    9: .standard(proto: "fee_rate"),
    11: .standard(proto: "htlc_maximum_msat"),
    12: .standard(proto: "extra_opaque_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.chainHash) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.chanID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.timestamp) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.channelFlags) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.timeLockDelta) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.htlcMinimumMsat) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.baseFee) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.feeRate) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.messageFlags) }()
      case 11: try { try decoder.decodeSingularUInt64Field(value: &self.htlcMaximumMsat) }()
      case 12: try { try decoder.decodeSingularBytesField(value: &self.extraOpaqueData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 1)
    }
    if !self.chainHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.chainHash, fieldNumber: 2)
    }
    if self.chanID != 0 {
      try visitor.visitSingularUInt64Field(value: self.chanID, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestamp, fieldNumber: 4)
    }
    if self.channelFlags != 0 {
      try visitor.visitSingularUInt32Field(value: self.channelFlags, fieldNumber: 5)
    }
    if self.timeLockDelta != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeLockDelta, fieldNumber: 6)
    }
    if self.htlcMinimumMsat != 0 {
      try visitor.visitSingularUInt64Field(value: self.htlcMinimumMsat, fieldNumber: 7)
    }
    if self.baseFee != 0 {
      try visitor.visitSingularUInt32Field(value: self.baseFee, fieldNumber: 8)
    }
    if self.feeRate != 0 {
      try visitor.visitSingularUInt32Field(value: self.feeRate, fieldNumber: 9)
    }
    if self.messageFlags != 0 {
      try visitor.visitSingularUInt32Field(value: self.messageFlags, fieldNumber: 10)
    }
    if self.htlcMaximumMsat != 0 {
      try visitor.visitSingularUInt64Field(value: self.htlcMaximumMsat, fieldNumber: 11)
    }
    if !self.extraOpaqueData.isEmpty {
      try visitor.visitSingularBytesField(value: self.extraOpaqueData, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelUpdate, rhs: Lnrpc_ChannelUpdate) -> Bool {
    if lhs.signature != rhs.signature {return false}
    if lhs.chainHash != rhs.chainHash {return false}
    if lhs.chanID != rhs.chanID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.messageFlags != rhs.messageFlags {return false}
    if lhs.channelFlags != rhs.channelFlags {return false}
    if lhs.timeLockDelta != rhs.timeLockDelta {return false}
    if lhs.htlcMinimumMsat != rhs.htlcMinimumMsat {return false}
    if lhs.baseFee != rhs.baseFee {return false}
    if lhs.feeRate != rhs.feeRate {return false}
    if lhs.htlcMaximumMsat != rhs.htlcMaximumMsat {return false}
    if lhs.extraOpaqueData != rhs.extraOpaqueData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_MacaroonId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MacaroonId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
    2: .same(proto: "storageId"),
    3: .same(proto: "ops"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.nonce) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.storageID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.ops) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nonce.isEmpty {
      try visitor.visitSingularBytesField(value: self.nonce, fieldNumber: 1)
    }
    if !self.storageID.isEmpty {
      try visitor.visitSingularBytesField(value: self.storageID, fieldNumber: 2)
    }
    if !self.ops.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ops, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_MacaroonId, rhs: Lnrpc_MacaroonId) -> Bool {
    if lhs.nonce != rhs.nonce {return false}
    if lhs.storageID != rhs.storageID {return false}
    if lhs.ops != rhs.ops {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_Op: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Op"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entity"),
    2: .same(proto: "actions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.entity) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.actions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entity.isEmpty {
      try visitor.visitSingularStringField(value: self.entity, fieldNumber: 1)
    }
    if !self.actions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.actions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_Op, rhs: Lnrpc_Op) -> Bool {
    if lhs.entity != rhs.entity {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_CheckMacPermRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CheckMacPermRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "macaroon"),
    2: .same(proto: "permissions"),
    3: .same(proto: "fullMethod"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.macaroon) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.permissions) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fullMethod) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.macaroon.isEmpty {
      try visitor.visitSingularBytesField(value: self.macaroon, fieldNumber: 1)
    }
    if !self.permissions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.permissions, fieldNumber: 2)
    }
    if !self.fullMethod.isEmpty {
      try visitor.visitSingularStringField(value: self.fullMethod, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_CheckMacPermRequest, rhs: Lnrpc_CheckMacPermRequest) -> Bool {
    if lhs.macaroon != rhs.macaroon {return false}
    if lhs.permissions != rhs.permissions {return false}
    if lhs.fullMethod != rhs.fullMethod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_CheckMacPermResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CheckMacPermResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "valid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.valid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.valid != false {
      try visitor.visitSingularBoolField(value: self.valid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_CheckMacPermResponse, rhs: Lnrpc_CheckMacPermResponse) -> Bool {
    if lhs.valid != rhs.valid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_RPCMiddlewareRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RPCMiddlewareRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "raw_macaroon"),
    3: .standard(proto: "custom_caveat_condition"),
    4: .standard(proto: "stream_auth"),
    5: .same(proto: "request"),
    6: .same(proto: "response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.rawMacaroon) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.customCaveatCondition) }()
      case 4: try {
        var v: Lnrpc_StreamAuth?
        if let current = self.interceptType {
          try decoder.handleConflictingOneOf()
          if case .streamAuth(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.interceptType = .streamAuth(v)}
      }()
      case 5: try {
        var v: Lnrpc_RPCMessage?
        if let current = self.interceptType {
          try decoder.handleConflictingOneOf()
          if case .request(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.interceptType = .request(v)}
      }()
      case 6: try {
        var v: Lnrpc_RPCMessage?
        if let current = self.interceptType {
          try decoder.handleConflictingOneOf()
          if case .response(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.interceptType = .response(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.requestID != 0 {
      try visitor.visitSingularUInt64Field(value: self.requestID, fieldNumber: 1)
    }
    if !self.rawMacaroon.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawMacaroon, fieldNumber: 2)
    }
    if !self.customCaveatCondition.isEmpty {
      try visitor.visitSingularStringField(value: self.customCaveatCondition, fieldNumber: 3)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.interceptType {
    case .streamAuth?: try {
      guard case .streamAuth(let v)? = self.interceptType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .request?: try {
      guard case .request(let v)? = self.interceptType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .response?: try {
      guard case .response(let v)? = self.interceptType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_RPCMiddlewareRequest, rhs: Lnrpc_RPCMiddlewareRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.rawMacaroon != rhs.rawMacaroon {return false}
    if lhs.customCaveatCondition != rhs.customCaveatCondition {return false}
    if lhs.interceptType != rhs.interceptType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_StreamAuth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamAuth"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "method_full_uri"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.methodFullUri) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.methodFullUri.isEmpty {
      try visitor.visitSingularStringField(value: self.methodFullUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_StreamAuth, rhs: Lnrpc_StreamAuth) -> Bool {
    if lhs.methodFullUri != rhs.methodFullUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_RPCMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RPCMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "method_full_uri"),
    2: .standard(proto: "stream_rpc"),
    3: .standard(proto: "type_name"),
    4: .same(proto: "serialized"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.methodFullUri) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.streamRpc) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.typeName) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.serialized) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.methodFullUri.isEmpty {
      try visitor.visitSingularStringField(value: self.methodFullUri, fieldNumber: 1)
    }
    if self.streamRpc != false {
      try visitor.visitSingularBoolField(value: self.streamRpc, fieldNumber: 2)
    }
    if !self.typeName.isEmpty {
      try visitor.visitSingularStringField(value: self.typeName, fieldNumber: 3)
    }
    if !self.serialized.isEmpty {
      try visitor.visitSingularBytesField(value: self.serialized, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_RPCMessage, rhs: Lnrpc_RPCMessage) -> Bool {
    if lhs.methodFullUri != rhs.methodFullUri {return false}
    if lhs.streamRpc != rhs.streamRpc {return false}
    if lhs.typeName != rhs.typeName {return false}
    if lhs.serialized != rhs.serialized {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_RPCMiddlewareResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RPCMiddlewareResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .same(proto: "register"),
    3: .same(proto: "feedback"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.requestID) }()
      case 2: try {
        var v: Lnrpc_MiddlewareRegistration?
        if let current = self.middlewareMessage {
          try decoder.handleConflictingOneOf()
          if case .register(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.middlewareMessage = .register(v)}
      }()
      case 3: try {
        var v: Lnrpc_InterceptFeedback?
        if let current = self.middlewareMessage {
          try decoder.handleConflictingOneOf()
          if case .feedback(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.middlewareMessage = .feedback(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.requestID != 0 {
      try visitor.visitSingularUInt64Field(value: self.requestID, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.middlewareMessage {
    case .register?: try {
      guard case .register(let v)? = self.middlewareMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .feedback?: try {
      guard case .feedback(let v)? = self.middlewareMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_RPCMiddlewareResponse, rhs: Lnrpc_RPCMiddlewareResponse) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.middlewareMessage != rhs.middlewareMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_MiddlewareRegistration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MiddlewareRegistration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "middleware_name"),
    2: .standard(proto: "custom_macaroon_caveat_name"),
    3: .standard(proto: "read_only_mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.middlewareName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.customMacaroonCaveatName) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.readOnlyMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.middlewareName.isEmpty {
      try visitor.visitSingularStringField(value: self.middlewareName, fieldNumber: 1)
    }
    if !self.customMacaroonCaveatName.isEmpty {
      try visitor.visitSingularStringField(value: self.customMacaroonCaveatName, fieldNumber: 2)
    }
    if self.readOnlyMode != false {
      try visitor.visitSingularBoolField(value: self.readOnlyMode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_MiddlewareRegistration, rhs: Lnrpc_MiddlewareRegistration) -> Bool {
    if lhs.middlewareName != rhs.middlewareName {return false}
    if lhs.customMacaroonCaveatName != rhs.customMacaroonCaveatName {return false}
    if lhs.readOnlyMode != rhs.readOnlyMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_InterceptFeedback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InterceptFeedback"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .standard(proto: "replace_response"),
    3: .standard(proto: "replacement_serialized"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.replaceResponse) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.replacementSerialized) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 1)
    }
    if self.replaceResponse != false {
      try visitor.visitSingularBoolField(value: self.replaceResponse, fieldNumber: 2)
    }
    if !self.replacementSerialized.isEmpty {
      try visitor.visitSingularBytesField(value: self.replacementSerialized, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_InterceptFeedback, rhs: Lnrpc_InterceptFeedback) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.replaceResponse != rhs.replaceResponse {return false}
    if lhs.replacementSerialized != rhs.replacementSerialized {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
