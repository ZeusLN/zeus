// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: walletunlocker.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Lnrpc_GenSeedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///aezeed_passphrase is an optional user provided passphrase that will be used
  ///to encrypt the generated aezeed cipher seed. When using REST, this field
  ///must be encoded as base64.
  var aezeedPassphrase: Data = Data()

  ///
  ///seed_entropy is an optional 16-bytes generated via CSPRNG. If not
  ///specified, then a fresh set of randomness will be used to create the seed.
  ///When using REST, this field must be encoded as base64.
  var seedEntropy: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_GenSeedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
  ///cipher seed obtained by the user. This field is optional, as if not
  ///provided, then the daemon will generate a new cipher seed for the user.
  ///Otherwise, then the daemon will attempt to recover the wallet state linked
  ///to this cipher seed.
  var cipherSeedMnemonic: [String] = []

  ///
  ///enciphered_seed are the raw aezeed cipher seed bytes. This is the raw
  ///cipher text before run through our mnemonic encoding scheme.
  var encipheredSeed: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_InitWalletRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///wallet_password is the passphrase that should be used to encrypt the
  ///wallet. This MUST be at least 8 chars in length. After creation, this
  ///password is required to unlock the daemon. When using REST, this field
  ///must be encoded as base64.
  var walletPassword: Data = Data()

  ///
  ///cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
  ///cipher seed obtained by the user. This may have been generated by the
  ///GenSeed method, or be an existing seed.
  var cipherSeedMnemonic: [String] = []

  ///
  ///aezeed_passphrase is an optional user provided passphrase that will be used
  ///to encrypt the generated aezeed cipher seed. When using REST, this field
  ///must be encoded as base64.
  var aezeedPassphrase: Data = Data()

  ///
  ///recovery_window is an optional argument specifying the address lookahead
  ///when restoring a wallet seed. The recovery window applies to each
  ///individual branch of the BIP44 derivation paths. Supplying a recovery
  ///window of zero indicates that no addresses should be recovered, such after
  ///the first initialization of the wallet.
  var recoveryWindow: Int32 = 0

  ///
  ///channel_backups is an optional argument that allows clients to recover the
  ///settled funds within a set of channels. This should be populated if the
  ///user was unable to close out all channels and sweep funds before partial or
  ///total data loss occurred. If specified, then after on-chain recovery of
  ///funds, lnd begin to carry out the data loss recovery protocol in order to
  ///recover the funds in each channel from a remote force closed transaction.
  var channelBackups: Lnrpc_ChanBackupSnapshot {
    get {return _channelBackups ?? Lnrpc_ChanBackupSnapshot()}
    set {_channelBackups = newValue}
  }
  /// Returns true if `channelBackups` has been explicitly set.
  var hasChannelBackups: Bool {return self._channelBackups != nil}
  /// Clears the value of `channelBackups`. Subsequent reads from it will return its default value.
  mutating func clearChannelBackups() {self._channelBackups = nil}

  ///
  ///stateless_init is an optional argument instructing the daemon NOT to create
  ///any *.macaroon files in its filesystem. If this parameter is set, then the
  ///admin macaroon returned in the response MUST be stored by the caller of the
  ///RPC as otherwise all access to the daemon will be lost!
  var statelessInit: Bool = false

  ///
  ///extended_master_key is an alternative to specifying cipher_seed_mnemonic and
  ///aezeed_passphrase. Instead of deriving the master root key from the entropy
  ///of an aezeed cipher seed, the given extended master root key is used
  ///directly as the wallet's master key. This allows users to import/use a
  ///master key from another wallet. When doing so, lnd still uses its default
  ///SegWit only (BIP49/84) derivation paths and funds from custom/non-default
  ///derivation paths will not automatically appear in the on-chain wallet. Using
  ///an 'xprv' instead of an aezeed also has the disadvantage that the wallet's
  ///birthday is not known as that is an information that's only encoded in the
  ///aezeed, not the xprv. Therefore a birthday needs to be specified in
  ///extended_master_key_birthday_timestamp or a "safe" default value will be
  ///used.
  var extendedMasterKey: String = String()

  ///
  ///extended_master_key_birthday_timestamp is the optional unix timestamp in
  ///seconds to use as the wallet's birthday when using an extended master key
  ///to restore the wallet. lnd will only start scanning for funds in blocks that
  ///are after the birthday which can speed up the process significantly. If the
  ///birthday is not known, this should be left at its default value of 0 in
  ///which case lnd will start scanning from the first SegWit block (481824 on
  ///mainnet).
  var extendedMasterKeyBirthdayTimestamp: UInt64 = 0

  ///
  ///watch_only is the third option of initializing a wallet: by importing
  ///account xpubs only and therefore creating a watch-only wallet that does not
  ///contain any private keys. That means the wallet won't be able to sign for
  ///any of the keys and _needs_ to be run with a remote signer that has the
  ///corresponding private keys and can serve signing RPC requests.
  var watchOnly: Lnrpc_WatchOnly {
    get {return _watchOnly ?? Lnrpc_WatchOnly()}
    set {_watchOnly = newValue}
  }
  /// Returns true if `watchOnly` has been explicitly set.
  var hasWatchOnly: Bool {return self._watchOnly != nil}
  /// Clears the value of `watchOnly`. Subsequent reads from it will return its default value.
  mutating func clearWatchOnly() {self._watchOnly = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _channelBackups: Lnrpc_ChanBackupSnapshot? = nil
  fileprivate var _watchOnly: Lnrpc_WatchOnly? = nil
}

struct Lnrpc_InitWalletResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The binary serialized admin macaroon that can be used to access the daemon
  ///after creating the wallet. If the stateless_init parameter was set to true,
  ///this is the ONLY copy of the macaroon and MUST be stored safely by the
  ///caller. Otherwise a copy of this macaroon is also persisted on disk by the
  ///daemon, together with other macaroon files.
  var adminMacaroon: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_WatchOnly {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The unix timestamp in seconds of when the master key was created. lnd will
  ///only start scanning for funds in blocks that are after the birthday which
  ///can speed up the process significantly. If the birthday is not known, this
  ///should be left at its default value of 0 in which case lnd will start
  ///scanning from the first SegWit block (481824 on mainnet).
  var masterKeyBirthdayTimestamp: UInt64 = 0

  ///
  ///The fingerprint of the root key (also known as the key with derivation path
  ///m/) from which the account public keys were derived from. This may be
  ///required by some hardware wallets for proper identification and signing. The
  ///bytes must be in big-endian order.
  var masterKeyFingerprint: Data = Data()

  ///
  ///The list of accounts to import. There _must_ be an account for all of lnd's
  ///main key scopes: BIP49/BIP84 (m/49'/0'/0', m/84'/0'/0', note that the
  ///coin type is always 0, even for testnet/regtest) and lnd's internal key
  ///scope (m/1017'/<coin_type>'/<account>'), where account is the key family as
  ///defined in `keychain/derivation.go` (currently indices 0 to 9).
  var accounts: [Lnrpc_WatchOnlyAccount] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_WatchOnlyAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///Purpose is the first number in the derivation path, must be either 49, 84
  ///or 1017.
  var purpose: UInt32 = 0

  ///
  ///Coin type is the second number in the derivation path, this is _always_ 0
  ///for purposes 49 and 84. It only needs to be set to 1 for purpose 1017 on
  ///testnet or regtest.
  var coinType: UInt32 = 0

  ///
  ///Account is the third number in the derivation path. For purposes 49 and 84
  ///at least the default account (index 0) needs to be created but optional
  ///additional accounts are allowed. For purpose 1017 there needs to be exactly
  ///one account for each of the key families defined in `keychain/derivation.go`
  ///(currently indices 0 to 9)
  var account: UInt32 = 0

  ///
  ///The extended public key at depth 3 for the given account.
  var xpub: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_UnlockWalletRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///wallet_password should be the current valid passphrase for the daemon. This
  ///will be required to decrypt on-disk material that the daemon requires to
  ///function properly. When using REST, this field must be encoded as base64.
  var walletPassword: Data = Data()

  ///
  ///recovery_window is an optional argument specifying the address lookahead
  ///when restoring a wallet seed. The recovery window applies to each
  ///individual branch of the BIP44 derivation paths. Supplying a recovery
  ///window of zero indicates that no addresses should be recovered, such after
  ///the first initialization of the wallet.
  var recoveryWindow: Int32 = 0

  ///
  ///channel_backups is an optional argument that allows clients to recover the
  ///settled funds within a set of channels. This should be populated if the
  ///user was unable to close out all channels and sweep funds before partial or
  ///total data loss occurred. If specified, then after on-chain recovery of
  ///funds, lnd begin to carry out the data loss recovery protocol in order to
  ///recover the funds in each channel from a remote force closed transaction.
  var channelBackups: Lnrpc_ChanBackupSnapshot {
    get {return _channelBackups ?? Lnrpc_ChanBackupSnapshot()}
    set {_channelBackups = newValue}
  }
  /// Returns true if `channelBackups` has been explicitly set.
  var hasChannelBackups: Bool {return self._channelBackups != nil}
  /// Clears the value of `channelBackups`. Subsequent reads from it will return its default value.
  mutating func clearChannelBackups() {self._channelBackups = nil}

  ///
  ///stateless_init is an optional argument instructing the daemon NOT to create
  ///any *.macaroon files in its file system.
  var statelessInit: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _channelBackups: Lnrpc_ChanBackupSnapshot? = nil
}

struct Lnrpc_UnlockWalletResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChangePasswordRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///current_password should be the current valid passphrase used to unlock the
  ///daemon. When using REST, this field must be encoded as base64.
  var currentPassword: Data = Data()

  ///
  ///new_password should be the new passphrase that will be needed to unlock the
  ///daemon. When using REST, this field must be encoded as base64.
  var newPassword: Data = Data()

  ///
  ///stateless_init is an optional argument instructing the daemon NOT to create
  ///any *.macaroon files in its filesystem. If this parameter is set, then the
  ///admin macaroon returned in the response MUST be stored by the caller of the
  ///RPC as otherwise all access to the daemon will be lost!
  var statelessInit: Bool = false

  ///
  ///new_macaroon_root_key is an optional argument instructing the daemon to
  ///rotate the macaroon root key when set to true. This will invalidate all
  ///previously generated macaroons.
  var newMacaroonRootKey: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChangePasswordResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The binary serialized admin macaroon that can be used to access the daemon
  ///after rotating the macaroon root key. If both the stateless_init and
  ///new_macaroon_root_key parameter were set to true, this is the ONLY copy of
  ///the macaroon that was created from the new root key and MUST be stored
  ///safely by the caller. Otherwise a copy of this macaroon is also persisted on
  ///disk by the daemon, together with other macaroon files.
  var adminMacaroon: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "lnrpc"

extension Lnrpc_GenSeedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenSeedRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "aezeed_passphrase"),
    2: .standard(proto: "seed_entropy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.aezeedPassphrase) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.seedEntropy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.aezeedPassphrase.isEmpty {
      try visitor.visitSingularBytesField(value: self.aezeedPassphrase, fieldNumber: 1)
    }
    if !self.seedEntropy.isEmpty {
      try visitor.visitSingularBytesField(value: self.seedEntropy, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_GenSeedRequest, rhs: Lnrpc_GenSeedRequest) -> Bool {
    if lhs.aezeedPassphrase != rhs.aezeedPassphrase {return false}
    if lhs.seedEntropy != rhs.seedEntropy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_GenSeedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenSeedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cipher_seed_mnemonic"),
    2: .standard(proto: "enciphered_seed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.cipherSeedMnemonic) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.encipheredSeed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cipherSeedMnemonic.isEmpty {
      try visitor.visitRepeatedStringField(value: self.cipherSeedMnemonic, fieldNumber: 1)
    }
    if !self.encipheredSeed.isEmpty {
      try visitor.visitSingularBytesField(value: self.encipheredSeed, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_GenSeedResponse, rhs: Lnrpc_GenSeedResponse) -> Bool {
    if lhs.cipherSeedMnemonic != rhs.cipherSeedMnemonic {return false}
    if lhs.encipheredSeed != rhs.encipheredSeed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_InitWalletRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InitWalletRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "wallet_password"),
    2: .standard(proto: "cipher_seed_mnemonic"),
    3: .standard(proto: "aezeed_passphrase"),
    4: .standard(proto: "recovery_window"),
    5: .standard(proto: "channel_backups"),
    6: .standard(proto: "stateless_init"),
    7: .standard(proto: "extended_master_key"),
    8: .standard(proto: "extended_master_key_birthday_timestamp"),
    9: .standard(proto: "watch_only"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.walletPassword) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.cipherSeedMnemonic) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.aezeedPassphrase) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.recoveryWindow) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._channelBackups) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.statelessInit) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.extendedMasterKey) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.extendedMasterKeyBirthdayTimestamp) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._watchOnly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.walletPassword.isEmpty {
      try visitor.visitSingularBytesField(value: self.walletPassword, fieldNumber: 1)
    }
    if !self.cipherSeedMnemonic.isEmpty {
      try visitor.visitRepeatedStringField(value: self.cipherSeedMnemonic, fieldNumber: 2)
    }
    if !self.aezeedPassphrase.isEmpty {
      try visitor.visitSingularBytesField(value: self.aezeedPassphrase, fieldNumber: 3)
    }
    if self.recoveryWindow != 0 {
      try visitor.visitSingularInt32Field(value: self.recoveryWindow, fieldNumber: 4)
    }
    if let v = self._channelBackups {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.statelessInit != false {
      try visitor.visitSingularBoolField(value: self.statelessInit, fieldNumber: 6)
    }
    if !self.extendedMasterKey.isEmpty {
      try visitor.visitSingularStringField(value: self.extendedMasterKey, fieldNumber: 7)
    }
    if self.extendedMasterKeyBirthdayTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.extendedMasterKeyBirthdayTimestamp, fieldNumber: 8)
    }
    if let v = self._watchOnly {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_InitWalletRequest, rhs: Lnrpc_InitWalletRequest) -> Bool {
    if lhs.walletPassword != rhs.walletPassword {return false}
    if lhs.cipherSeedMnemonic != rhs.cipherSeedMnemonic {return false}
    if lhs.aezeedPassphrase != rhs.aezeedPassphrase {return false}
    if lhs.recoveryWindow != rhs.recoveryWindow {return false}
    if lhs._channelBackups != rhs._channelBackups {return false}
    if lhs.statelessInit != rhs.statelessInit {return false}
    if lhs.extendedMasterKey != rhs.extendedMasterKey {return false}
    if lhs.extendedMasterKeyBirthdayTimestamp != rhs.extendedMasterKeyBirthdayTimestamp {return false}
    if lhs._watchOnly != rhs._watchOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_InitWalletResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InitWalletResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "admin_macaroon"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.adminMacaroon) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.adminMacaroon.isEmpty {
      try visitor.visitSingularBytesField(value: self.adminMacaroon, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_InitWalletResponse, rhs: Lnrpc_InitWalletResponse) -> Bool {
    if lhs.adminMacaroon != rhs.adminMacaroon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_WatchOnly: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WatchOnly"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "master_key_birthday_timestamp"),
    2: .standard(proto: "master_key_fingerprint"),
    3: .same(proto: "accounts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.masterKeyBirthdayTimestamp) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.masterKeyFingerprint) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.accounts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.masterKeyBirthdayTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.masterKeyBirthdayTimestamp, fieldNumber: 1)
    }
    if !self.masterKeyFingerprint.isEmpty {
      try visitor.visitSingularBytesField(value: self.masterKeyFingerprint, fieldNumber: 2)
    }
    if !self.accounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accounts, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_WatchOnly, rhs: Lnrpc_WatchOnly) -> Bool {
    if lhs.masterKeyBirthdayTimestamp != rhs.masterKeyBirthdayTimestamp {return false}
    if lhs.masterKeyFingerprint != rhs.masterKeyFingerprint {return false}
    if lhs.accounts != rhs.accounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_WatchOnlyAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WatchOnlyAccount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "purpose"),
    2: .standard(proto: "coin_type"),
    3: .same(proto: "account"),
    4: .same(proto: "xpub"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.purpose) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.coinType) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.account) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.xpub) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.purpose != 0 {
      try visitor.visitSingularUInt32Field(value: self.purpose, fieldNumber: 1)
    }
    if self.coinType != 0 {
      try visitor.visitSingularUInt32Field(value: self.coinType, fieldNumber: 2)
    }
    if self.account != 0 {
      try visitor.visitSingularUInt32Field(value: self.account, fieldNumber: 3)
    }
    if !self.xpub.isEmpty {
      try visitor.visitSingularStringField(value: self.xpub, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_WatchOnlyAccount, rhs: Lnrpc_WatchOnlyAccount) -> Bool {
    if lhs.purpose != rhs.purpose {return false}
    if lhs.coinType != rhs.coinType {return false}
    if lhs.account != rhs.account {return false}
    if lhs.xpub != rhs.xpub {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_UnlockWalletRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnlockWalletRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "wallet_password"),
    2: .standard(proto: "recovery_window"),
    3: .standard(proto: "channel_backups"),
    4: .standard(proto: "stateless_init"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.walletPassword) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.recoveryWindow) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._channelBackups) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.statelessInit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.walletPassword.isEmpty {
      try visitor.visitSingularBytesField(value: self.walletPassword, fieldNumber: 1)
    }
    if self.recoveryWindow != 0 {
      try visitor.visitSingularInt32Field(value: self.recoveryWindow, fieldNumber: 2)
    }
    if let v = self._channelBackups {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.statelessInit != false {
      try visitor.visitSingularBoolField(value: self.statelessInit, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_UnlockWalletRequest, rhs: Lnrpc_UnlockWalletRequest) -> Bool {
    if lhs.walletPassword != rhs.walletPassword {return false}
    if lhs.recoveryWindow != rhs.recoveryWindow {return false}
    if lhs._channelBackups != rhs._channelBackups {return false}
    if lhs.statelessInit != rhs.statelessInit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_UnlockWalletResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnlockWalletResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_UnlockWalletResponse, rhs: Lnrpc_UnlockWalletResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChangePasswordRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangePasswordRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "current_password"),
    2: .standard(proto: "new_password"),
    3: .standard(proto: "stateless_init"),
    4: .standard(proto: "new_macaroon_root_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.currentPassword) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.newPassword) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.statelessInit) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.newMacaroonRootKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.currentPassword.isEmpty {
      try visitor.visitSingularBytesField(value: self.currentPassword, fieldNumber: 1)
    }
    if !self.newPassword.isEmpty {
      try visitor.visitSingularBytesField(value: self.newPassword, fieldNumber: 2)
    }
    if self.statelessInit != false {
      try visitor.visitSingularBoolField(value: self.statelessInit, fieldNumber: 3)
    }
    if self.newMacaroonRootKey != false {
      try visitor.visitSingularBoolField(value: self.newMacaroonRootKey, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChangePasswordRequest, rhs: Lnrpc_ChangePasswordRequest) -> Bool {
    if lhs.currentPassword != rhs.currentPassword {return false}
    if lhs.newPassword != rhs.newPassword {return false}
    if lhs.statelessInit != rhs.statelessInit {return false}
    if lhs.newMacaroonRootKey != rhs.newMacaroonRootKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChangePasswordResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangePasswordResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "admin_macaroon"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.adminMacaroon) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.adminMacaroon.isEmpty {
      try visitor.visitSingularBytesField(value: self.adminMacaroon, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChangePasswordResponse, rhs: Lnrpc_ChangePasswordResponse) -> Bool {
    if lhs.adminMacaroon != rhs.adminMacaroon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
